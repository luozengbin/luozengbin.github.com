#+TITLE: [検証]backlogに関係するカーネルパラメータ
#+DATE: 2014-09-24
#+SETUPFILE: ~/.emacs.d/blogs/octopress/setupfile.org
#+JEKYLL_LAYOUT: post
#+JEKYLL_CATEGORIES: linux
#+JEKYLL_TAGS: tcp backlog
#+JEKYLL_COMMENTS: true
#+JEKYLL_PUBLISHED: true

* net.core.somaxconn
保留中の接続(3-Wayハンドシェイク完了、ユーザランドで未acceptのソケット)のキューの最大
長を指定する。listen()システムコールの第二引数の上限値である。

=listen()= システムコール [[http://linux.die.net/man/2/listen][man]] の解説
#+begin_example
The behavior of the backlog argument on TCP sockets changed with Linux 2.2.
                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Now it specifies the queue length for completely established sockets waiting to be accepted,
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
instead of the number of incomplete connection requests. The maximum length of the
queue for incomplete sockets can be set using /proc/sys/net/ipv4/tcp_max_syn_backlog.
When syncookies are enabled there is no logical maximum length and this setting is ignored.
See tcp(7) for more information.
#+end_example

このパラメータはlistenシステムコール処理で参照される。カーネル3.12のコードを以下に示
す。 =linux-3.12/net/socket.c=
#+begin_src c
/*
 *	Perform a listen. Basically, we allow the protocol to do anything
 *	necessary for a listen, and if that works, we mark the socket as
 *	ready for listening.
 */

SYSCALL_DEFINE2(listen, int, fd, int, backlog)
{
	struct socket *sock;
	int err, fput_needed;
	int somaxconn;

	sock = sockfd_lookup_light(fd, &err, &fput_needed);
	if (sock) {
        // ★カーネルパラメータ取得
		somaxconn = sock_net(sock->sk)->core.sysctl_somaxconn;

        // ★Listen関数の第二引数と比べる、低い方を採用
		if ((unsigned int)backlog > somaxconn)
			backlog = somaxconn;

		err = security_socket_listen(sock, backlog);
		if (!err)
			err = sock->ops->listen(sock, backlog);

		fput_light(sock->file, fput_needed);
	}
	return err;
}
#+end_src

* net.ipv4.tcp_max_syn_backlog
接続確立時の接続中（Half Openコネクション）のキュー最大サイズ。
SYNC_RECV を保持する数の上限とも言えるでしょう。

キューのサイズの計算は◯◯◯◯の時初期化される。
このパラメータはコネクションを設立する度に参照される。→★要確認

また =tcp_max_syn_backlog= の値は2の冪からマイナス1の値にすべきと思われる。
その理由はコードのコメント★3にて説明する。(TODO:default値で検証する)
カーネル3.12にキューのサイズを初期化するコードを以下に示す。
=linux-3.12/net/core/request_sock.c=
#+begin_src c
/*
 * Maximum number of SYN_RECV sockets in queue per LISTEN socket.
 * One SYN_RECV socket costs about 80bytes on a 32bit machine.
 * It would be better to replace it with a global counter for all sockets
 * but then some measure against one socket starving all other sockets
 * would be needed.
 *
 * The minimum value of it is 128. Experiments with real servers show that
 * it is absolutely not enough even at 100conn/sec. 256 cures most
 * of problems.
 * This value is adjusted to 128 for low memory machines,
 * and it will increase in proportion to the memory of machine.
 * Note : Dont forget somaxconn that may limit backlog too.
 */
int sysctl_max_syn_backlog = 256;
EXPORT_SYMBOL(sysctl_max_syn_backlog);

int reqsk_queue_alloc(struct request_sock_queue *queue,
		      unsigned int nr_table_entries)
{
	size_t lopt_size = sizeof(struct listen_sock);
	struct listen_sock *lopt;

    // ★1:
    // net.ipv4.tcp_max_syn_backlogとlistenコールによる算出されたbacklogの値から
    // 小さい方の値にする
	nr_table_entries = min_t(u32, nr_table_entries, sysctl_max_syn_backlog);

    // ★2: 8より大きい
	nr_table_entries = max_t(u32, nr_table_entries, 8);

    // ★3: 1と2で決まった値を足す1 → この値が2の冪ならそのまま使う、
    //      そでない場合、得た値より大きい2の冪の値にする
    //      127 + 1 = 128 → そのまま値を採用する
    //      128 + 1 = 129 → 2の7乗=128 > 129 > 2の8乗256 なので値が256に変わる
    //      このロジックからアプリからbacklog指定時に奇数を指定すべき、例:127、255、511
	nr_table_entries = roundup_pow_of_two(nr_table_entries + 1);
	lopt_size += nr_table_entries * sizeof(struct request_sock *);
	if (lopt_size > PAGE_SIZE)
		lopt = vzalloc(lopt_size);
	else
		lopt = kzalloc(lopt_size, GFP_KERNEL);
	if (lopt == NULL)
		return -ENOMEM;

	for (lopt->max_qlen_log = 3;
	     (1 << lopt->max_qlen_log) < nr_table_entries;
	     lopt->max_qlen_log++);

	get_random_bytes(&lopt->hash_rnd, sizeof(lopt->hash_rnd));
	rwlock_init(&queue->syn_wait_lock);
	queue->rskq_accept_head = NULL;
	lopt->nr_table_entries = nr_table_entries;

	write_lock_bh(&queue->syn_wait_lock);
	queue->listen_opt = lopt;
	write_unlock_bh(&queue->syn_wait_lock);

	return 0;
}
#+end_src

* Javaプログラムより検証

* systemtapよりカーネルの内部挙動を追う

{{{more}}}

* 参考サイト
- [[http://veithen.blogspot.jp/2014/01/how-tcp-backlog-works-in-linux.html][How TCP backlog works in Linux]]
- [[http://d.hatena.ne.jp/nyant/20111216/1324043063][LinuxのTCP/IPの実装について調べてみた]]

http://blog.clanzx.net/2014/05/17/listen-backlog.html
http://www.cnblogs.com/kinwin/archive/2012/10/17/2727841.html
http://blog.csdn.net/moonvs2010/article/category/1132785/3
http://blog.csdn.net/justlinux2010/article/details/8604676
http://blog.csdn.net/justlinux2010/article/details/8597498
