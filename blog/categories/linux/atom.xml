<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | Akira's Tech Notes]]></title>
  <link href="http://luozengbin.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://luozengbin.github.io/"/>
  <updated>2014-08-09T23:30:30+09:00</updated>
  <id>http://luozengbin.github.io/</id>
  <author>
    <name><![CDATA[luozengbin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[メモ]findでファイル更新日付順で表示する]]></title>
    <link href="http://luozengbin.github.io/blog/2014-08-07-%5B%E3%83%A1%E3%83%A2%5Dfind%E3%81%A7%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E6%9B%B4%E6%96%B0%E6%97%A5%E4%BB%98%E9%A0%86%E3%81%A7%E8%A1%A8%E7%A4%BA%E3%81%99%E3%82%8B.html"/>
    <updated>2014-08-07T00:00:00+09:00</updated>
    <id>http://luozengbin.github.io/blog/[メモ]findでファイル更新日付順で表示する</id>
    <content type="html"><![CDATA[<p>
PJではメンバたち日々の作業成果物がどこかの共有ディレクトリに格納されているでしょう。
共有ディレクトリに最近更新や追加されたファイルを見たい時がよくあることです。
いちいち作業担当者に聞くのもうざいので。 <code>find</code> 、 <code>xargs</code> コマンドを駆使して実現して
みた。
</p>




<pre class="example">
$ find . -type f -print0 | xargs -0 ls -alt
</pre>




<ul class="org-ul">
<li><code>find -type f</code> はファイルのみを対象とする
</li>
<li><code>find -print0</code> は検出されたファイルのフルパスをNULLキャラクターで分割して出力する
</li>
<li><code>xargs -0</code> もしくは <code>xargs --null</code> 入力ストリームの分割はNULLキャラクターを用いる
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[メモ]ffmpegでスクリンキャストを取る]]></title>
    <link href="http://luozengbin.github.io/blog/2014-07-21-%5B%E3%83%A1%E3%83%A2%5Dffmpeg%E3%81%A7%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%B3%E3%82%AD%E3%83%A3%E3%82%B9%E3%83%88%E3%82%92%E5%8F%96%E3%82%8B.html"/>
    <updated>2014-07-21T00:00:00+09:00</updated>
    <id>http://luozengbin.github.io/blog/[メモ]ffmpegでスクリンキャストを取る</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 特定のウィンドウを録画する</a></li>
<li><a href="#sec-2">2. 全画面を録画する</a></li>
<li><a href="#sec-3">3. 録画サンプル</a></li>
</ul>
</div>
</div>


<p>
<code>ffmpeg</code> と <code>xwininfo</code> コマンドでスクリンキャストを取るシェールスクリプトを作成してみた。
</p>




<p>
<!-- more -->
</p>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 特定のウィンドウを録画する</h2>
<div class="outline-text-2" id="text-1">
<p>
第一引数に録画ビデオファイルの保存パスを指定する。
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #888a85;">#</span><span style="color: #888a85;">!/bin/</span><span style="color: #729fcf; font-weight: bold;">sh</span>

<span style="color: #888a85;">###########################################################################</span>
<span style="color: #888a85;"># </span><span style="color: #888a85;">fsc-window.sh - take screen video cast for selected window</span>
<span style="color: #888a85;">#</span>
<span style="color: #888a85;">#    </span><span style="color: #888a85;">Authors: Luo Zengbin <a href="mailto:jalen.cn%40gmail.com">&lt;jalen.cn@gmail.com&gt;</a></span>
<span style="color: #888a85;">#</span>
<span style="color: #888a85;">#    </span><span style="color: #888a85;">This program is free software: you can redistribute it and/or modify</span>
<span style="color: #888a85;">#    </span><span style="color: #888a85;">it under the terms of the GNU General Public License as published by</span>
<span style="color: #888a85;">#    </span><span style="color: #888a85;">the Free Software Foundation, version 3 of the License.</span>
<span style="color: #888a85;">#</span>
<span style="color: #888a85;">#    </span><span style="color: #888a85;">This program is distributed in the hope that it will be useful,</span>
<span style="color: #888a85;">#    </span><span style="color: #888a85;">but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span style="color: #888a85;">#    </span><span style="color: #888a85;">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span style="color: #888a85;">#    </span><span style="color: #888a85;">GNU General Public License for more details.</span>
<span style="color: #888a85;">#</span>
<span style="color: #888a85;">#    </span><span style="color: #888a85;">You should have received a copy of the GNU General Public License</span>
<span style="color: #888a85;">#    </span><span style="color: #888a85;">along with this program.  If not, see <a href="http://www.gnu.org/licenses/">&lt;http://www.gnu.org/licenses/&gt;</a>.</span>
<span style="color: #888a85;">#</span>
<span style="color: #888a85;"># </span><span style="color: #888a85;">Usage:</span>
<span style="color: #888a85;">#    </span><span style="color: #888a85;">$fsc-window.sh $1 &#31532;&#19968;&#24341;&#25968;&#12395;&#37682;&#30011;&#12499;&#12487;&#12458;&#12501;&#12449;&#12452;&#12523;&#12398;&#20445;&#23384;&#12497;&#12473;&#12434;&#25351;&#23450;&#12377;&#12427;&#12290;</span>
<span style="color: #888a85;">###########################################################################</span>

<span style="color: #888a85;">####################################</span>
<span style="color: #888a85;"># </span><span style="color: #888a85;">&#22855;&#25968;&#12434;&#20598;&#25968;&#12395;&#22793;&#25563;&#12377;&#12427;&#20966;&#29702;</span>
<span style="color: #888a85;">####################################</span>
<span style="color: #729fcf; font-weight: bold;">function</span> <span style="color: #edd400; font-weight: bold;">even_round</span> {
    <span style="color: #729fcf; font-weight: bold;">if</span> [ <span style="color: #fa8072;">`expr $1 % 2`</span> == 0 ]; <span style="color: #729fcf; font-weight: bold;">then</span>
        <span style="color: #729fcf;">echo</span> $<span style="color: #ff6347;">1</span>
    <span style="color: #729fcf; font-weight: bold;">else</span>
        <span style="color: #729fcf;">echo</span> $(($<span style="color: #ff6347;">1</span> - 1))
    <span style="color: #729fcf; font-weight: bold;">fi</span>
}

<span style="color: #729fcf;">echo</span> <span style="color: #ad7fa8; font-style: italic;">"&#37682;&#30011;&#23550;&#35937;Window&#12434;&#12459;&#12540;&#12477;&#12523;&#12391;&#36984;&#25246;&#12375;&#12390;&#12367;&#12384;&#12373;&#12356;&#12290;"</span>
<span style="color: #ff6347;">VFILE</span>=$<span style="color: #ff6347;">1</span>
<span style="color: #ff6347;">INFO</span>=$(<span style="color: #fa8072;">xwininfo</span> -frame)

<span style="color: #ff6347;">WIN_GEO</span>=$(<span style="color: #fa8072;">echo</span> $<span style="color: #ff6347;">INFO</span> | grep -oEe <span style="color: #ad7fa8; font-style: italic;">'geometry [0-9]+x[0-9]+'</span> | grep -oEe <span style="color: #ad7fa8; font-style: italic;">'[0-9]+x[0-9]+'</span>)
<span style="color: #ff6347;">WIN_XY</span>=$(<span style="color: #fa8072;">echo</span> $<span style="color: #ff6347;">INFO</span> | grep -oEe <span style="color: #ad7fa8; font-style: italic;">'Corners:\s+\+[0-9]+\+[0-9]+'</span> | grep -oEe <span style="color: #ad7fa8; font-style: italic;">'[0-9]+\+[0-9]+'</span> | sed -e <span style="color: #ad7fa8; font-style: italic;">'s/\+/,/'</span> )

<span style="color: #888a85;"># </span><span style="color: #888a85;">Windows&#12398;&#27178;&#12469;&#12452;&#12474;&#12392;&#32294;&#12469;&#12452;&#12474;&#12434;&#20598;&#25968;&#12395;&#12377;&#12427;</span>
<span style="color: #ff6347;">WIN_GEO_X</span>=$(<span style="color: #fa8072;">echo</span> $<span style="color: #ff6347;">WIN_GEO</span> | cut -d <span style="color: #ad7fa8; font-style: italic;">'x'</span> -f 1)
<span style="color: #ff6347;">WIN_GEO_Y</span>=$(<span style="color: #fa8072;">echo</span> $<span style="color: #ff6347;">WIN_GEO</span> | cut -d <span style="color: #ad7fa8; font-style: italic;">'x'</span> -f 2)

<span style="color: #ff6347;">WIN_GEO</span>=<span style="color: #ad7fa8; font-style: italic;">"$(</span><span style="color: #fa8072;">even_round</span><span style="color: #ad7fa8; font-style: italic;"> $WIN_GEO_X)x$(</span><span style="color: #fa8072;">even_round</span><span style="color: #ad7fa8; font-style: italic;"> $WIN_GEO_Y)"</span>

<span style="color: #729fcf;">echo</span> <span style="color: #ad7fa8; font-style: italic;">"&#30011;&#38754;&#12469;&#12452;&#12474;&#65306;$WIN_GEO"</span>
<span style="color: #729fcf;">echo</span> <span style="color: #ad7fa8; font-style: italic;">"&#30011;&#38754;&#20301;&#32622;  &#65306;$WIN_XY"</span>

<span style="color: #888a85;"># </span><span style="color: #888a85;">&#37682;&#30011;&#38283;&#22987;</span>
ffmpeg -show_region 1 -f x11grab -framerate 25 -video_size $<span style="color: #ff6347;">WIN_GEO</span> -i :0.0+$<span style="color: #ff6347;">WIN_XY</span> <span style="color: #ad7fa8; font-style: italic;">\</span>
       -dcodec copy -pix_fmt yuv420p -c:v libx264 -preset veryfast -qscale 1 -y $<span style="color: #ff6347;">VFILE</span>
</pre>
</div>

<p>
ハマッたところ
</p>
<ul class="org-ul">
<li>ビデオの横と縦のサイズを偶数にしないと、iphoneで再生時に真っグリンな画面しか見れない
</li>
<li>shell関数の戻り値は <code>return</code> じゃなくて、 <code>echo</code> を使うべき。 <code>return</code> はプロセスの
実行結果ステータスと同じ使い方、ステータスを示すに使う
</li>
</ul>

<p>
コマンドの便利なオプション
</p>
<ul class="org-ul">
<li><code>xwininfo -frame</code> 対象のウィンドウをカーソルで選択できるオプション
</li>
<li><code>ffmpeg -show_region 1</code> 録画対象範囲を点線で囲んで分かりやすくするオプション、1は点
線の太さを示す
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 全画面を録画する</h2>
<div class="outline-text-2" id="text-2">
<p>
<code>xwininfo -root</code> でフルスクリーンの情報を取得することができます。
</p>

<div class="org-src-container">

<pre class="src src-sh"><span style="color: #888a85;">#</span><span style="color: #888a85;">!/bin/</span><span style="color: #729fcf; font-weight: bold;">sh</span>

<span style="color: #888a85;">###########################################################################</span>
<span style="color: #888a85;"># </span><span style="color: #888a85;">fsc-full.sh - take full screen video cast</span>
<span style="color: #888a85;">#</span>
<span style="color: #888a85;">#    </span><span style="color: #888a85;">Authors: Luo Zengbin <a href="mailto:jalen.cn%40gmail.com">&lt;jalen.cn@gmail.com&gt;</a></span>
<span style="color: #888a85;">#</span>
<span style="color: #888a85;">#    </span><span style="color: #888a85;">This program is free software: you can redistribute it and/or modify</span>
<span style="color: #888a85;">#    </span><span style="color: #888a85;">it under the terms of the GNU General Public License as published by</span>
<span style="color: #888a85;">#    </span><span style="color: #888a85;">the Free Software Foundation, version 3 of the License.</span>
<span style="color: #888a85;">#</span>
<span style="color: #888a85;">#    </span><span style="color: #888a85;">This program is distributed in the hope that it will be useful,</span>
<span style="color: #888a85;">#    </span><span style="color: #888a85;">but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span style="color: #888a85;">#    </span><span style="color: #888a85;">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span style="color: #888a85;">#    </span><span style="color: #888a85;">GNU General Public License for more details.</span>
<span style="color: #888a85;">#</span>
<span style="color: #888a85;">#    </span><span style="color: #888a85;">You should have received a copy of the GNU General Public License</span>
<span style="color: #888a85;">#    </span><span style="color: #888a85;">along with this program.  If not, see <a href="http://www.gnu.org/licenses/">&lt;http://www.gnu.org/licenses/&gt;</a>.</span>
<span style="color: #888a85;">#</span>
<span style="color: #888a85;"># </span><span style="color: #888a85;">Usage:</span>
<span style="color: #888a85;">#    </span><span style="color: #888a85;">$fsc-full.sh $1 &#31532;&#19968;&#24341;&#25968;&#12395;&#37682;&#30011;&#12499;&#12487;&#12458;&#12501;&#12449;&#12452;&#12523;&#12398;&#20445;&#23384;&#12497;&#12473;&#12434;&#25351;&#23450;&#12377;&#12427;&#12290;</span>
<span style="color: #888a85;">###########################################################################</span>

<span style="color: #ff6347;">WIN_GEO</span>=$(<span style="color: #fa8072;">xwininfo</span> -root | grep <span style="color: #ad7fa8; font-style: italic;">'geometry'</span> | awk <span style="color: #ad7fa8; font-style: italic;">'{print $2;}'</span> | cut -d <span style="color: #ad7fa8; font-style: italic;">'+'</span> -f 1)

<span style="color: #888a85;"># </span><span style="color: #888a85;">&#37682;&#30011;&#38283;&#22987;</span>
ffmpeg -show_region 1 -f x11grab -framerate 25 -video_size $<span style="color: #ff6347;">WIN_GEO</span> -i :0.0 <span style="color: #ad7fa8; font-style: italic;">\</span>
       -dcodec copy -pix_fmt yuv420p -c:v libx264 -preset veryfast -qscale 1 -y $<span style="color: #ff6347;">1</span>
</pre>
</div>
</div>
</div>




<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 録画サンプル</h2>
<div class="outline-text-2" id="text-3">
<p>
録画テストサンプル
</p>
<video controls>
   <source src="video/2014-07-21-ffmpeg-test.mp4">
</video>

<p>
ばっちりだね。 めでたしめでたし。
</p>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[検証]syncシステムコールの性能について]]></title>
    <link href="http://luozengbin.github.io/blog/2014-07-08-%5B%E6%A4%9C%E8%A8%BC%5Dsync%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%82%B3%E3%83%BC%E3%83%AB%E3%81%AE%E6%80%A7%E8%83%BD%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6.html"/>
    <updated>2014-07-08T00:00:00+09:00</updated>
    <id>http://luozengbin.github.io/blog/[検証]syncシステムコールの性能について</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. IOPSとは</a></li>
<li><a href="#sec-2">2. 実機検証</a>
<ul>
<li><a href="#sec-2-1">2.1. 環境確認</a></li>
<li><a href="#sec-2-2">2.2. テスト用プログラム</a></li>
<li><a href="#sec-2-3">2.3. sarコマンドでIOPSを確認する</a></li>
<li><a href="#sec-2-4">2.4. 測定結果</a></li>
</ul>
</li>
<li><a href="#sec-3">3. 参考リンク</a></li>
</ul>
</div>
</div>


<p>
商用（本番運用）にて、なんらかの障害発生時にログがロストしないようにトランザクション
ポイントで <code>sync</code> システムコールを呼び出して汚れたページをディスクへ書き込む方法が
あるのですが、それは普通のHDDに置いては性能的に非現実的です。理由は <code>IOPS</code> です。
</p>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> IOPSとは</h2>
<div class="outline-text-2" id="text-1">
<p>
ハードディスクなどの記憶装置の性能指標の一つで、ある条件の元で1秒間に読み込み・書き込
みできる回数のこと。<a href="http://en.wikipedia.org/wiki/IOPS">wikipedia</a> から参照するとHDDのIOPS数値は以下のようです。
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Device</th>
<th scope="col" class="left">Type</th>
<th scope="col" class="left">IOPS</th>
<th scope="col" class="left">Interface</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">7,200 rpm SATA drives</td>
<td class="left">HDD</td>
<td class="left">~75-100 IOPS</td>
<td class="left">SATA 3 Gbit/s</td>
</tr>

<tr>
<td class="left">10,000 rpm SATA drives</td>
<td class="left">HDD</td>
<td class="left">~125-150 IOPS</td>
<td class="left">SATA 3 Gbit/s</td>
</tr>

<tr>
<td class="left">10,000 rpm SAS drives</td>
<td class="left">HDD</td>
<td class="left">~140 IOPS</td>
<td class="left">SAS</td>
</tr>

<tr>
<td class="left">15,000 rpm SAS drives</td>
<td class="left">HDD</td>
<td class="left">~175-210 IOPS</td>
<td class="left">SAS</td>
</tr>
</tbody>
</table>

<p>
つまり、HDDに置いて秒間同期書き込み回数の上限はしょせん200回（多めに）ぐらいです。
</p>

<p>
さあ、実際はどうなるでしょうか？実機検証してみましょう。
</p>

<p>
<!-- more -->
</p>
</div>
</div>




<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 実機検証</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 環境確認</h3>
<div class="outline-text-3" id="text-2-1">
<p>
ディスクデバイスは <code>7,200rpm</code> のものを使用します。
</p>
<pre class="example">
$ sudo hdparm -I /dev/sda

/dev/sda:

ATA device, with non-removable media
    Model Number:       WDC WD2500AAKX-193CA0
    Serial Number:      WD-**********
    Firmware Revision:  15.01H15
    Transport:          Serial, SATA 1.0a, SATA II Extensions, SATA Rev 2.5, SATA Rev 2.6, SATA Rev 3.0
Standards:
    Supported: 8 7 6 5
    Likely used: 8
Configuration:
    Logical     max current
    cylinders   16383   16383
    heads       16  16
    sectors/track   63  63
    --
    CHS current addressable sectors:   16514064
    LBA    user addressable sectors:  268435455
    LBA48  user addressable sectors:  488397168
    Logical/Physical Sector size:           512 bytes
    device size with M = 1024*1024:      238475 MBytes
    device size with M = 1000*1000:      250059 MBytes (250 GB)
    cache/buffer size  = 16384 KBytes
Capabilities:
    LBA, IORDY(can be disabled)
    Queue depth: 32
    Standby timer values: spec'd by Standard, with device specific minimum
    R/W multiple sector transfer: Max = 16  Current = 16
    DMA: mdma0 mdma1 mdma2 udma0 udma1 udma2 udma3 udma4 udma5 *udma6 
         Cycle time: min=120ns recommended=120ns
    PIO: pio0 pio1 pio2 pio3 pio4 
         Cycle time: no flow control=120ns  IORDY flow control=120ns
Commands/features:
    Enabled Supported:
       *    SMART feature set
            Security Mode feature set
       *    Power Management feature set
       *    Write cache                  ★★★キャッシュを有効に
       *    Look-ahead
       *    Host Protected Area feature set
       *    WRITE_BUFFER command
       *    READ_BUFFER command
       *    NOP cmd
       *    DOWNLOAD_MICROCODE
            Power-Up In Standby feature set
       *    SET_FEATURES required to spinup after power up
            SET_MAX security extension
       *    48-bit Address feature set
       *    Device Configuration Overlay feature set
       *    Mandatory FLUSH_CACHE
       *    FLUSH_CACHE_EXT
       *    SMART error logging
       *    SMART self-test
       *    General Purpose Logging feature set
       *    64-bit World wide name
       *    {READ,WRITE}_DMA_EXT_GPL commands
       *    Segmented DOWNLOAD_MICROCODE
       *    Gen1 signaling speed (1.5Gb/s)
       *    Gen2 signaling speed (3.0Gb/s)
       *    Gen3 signaling speed (6.0Gb/s)
       *    Native Command Queueing (NCQ)
       *    Host-initiated interface power management
       *    Phy event counters
       *    NCQ priority information
       *    DMA Setup Auto-Activate optimization
       *    Software settings preservation
       *    SMART Command Transport (SCT) feature set
       *    SCT Read/Write Long (AC1), obsolete
       *    SCT Write Same (AC2)
       *    SCT Features Control (AC4)
       *    SCT Data Tables (AC5)
            unknown 206[12] (vendor specific)
            unknown 206[13] (vendor specific)
Security: 
    Master password revision code = 65534
        supported
    not enabled
    not locked
        frozen
    not expired: security count
        supported: enhanced erase
    40min for SECURITY ERASE UNIT. 40min for ENHANCED SECURITY ERASE UNIT. 
Logical Unit WWN Device Identifier: 50014ee601e91fb5
    NAA     : 5
    IEEE OUI    : 0014ee
    Unique ID   : 601e91fb5
Checksum: correct
$
</pre>

<p>
カーネルパラメータの確認
</p>
<pre class="example">
$ sudo sysctl -a | grep dirty
vm.dirty_background_bytes = 0
vm.dirty_background_ratio = 10
vm.dirty_bytes = 0
vm.dirty_expire_centisecs = 3000
vm.dirty_ratio = 20
vm.dirty_writeback_centisecs = 500
$
</pre>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> テスト用プログラム</h3>
<div class="outline-text-3" id="text-2-2">
<p>
以下のperlスクリプトに無限ループ内で1KBのデータ（ログ１行に相当する？）をファイルへ
の書き込みを行って、=sync= をコールして <code>pdflush</code> を強制的動かさせる。また秒単位で
の書き込み回数（アプリ視点から）を集計して標準出力に出します。
</p>

<div class="org-src-container">

<pre class="src src-perl"><span style="color: #888a85;">#</span><span style="color: #888a85;">!/usr/bin/perl</span>
<span style="color: #729fcf; font-weight: bold;">use</span> <span style="color: #8ae234;">strict</span>;
<span style="color: #729fcf; font-weight: bold;">use</span> <span style="color: #8ae234;">warnings</span>;
<span style="color: #729fcf; font-weight: bold;">use</span> <span style="color: #8ae234;">IO</span>::File;
<span style="color: #729fcf; font-weight: bold;">use</span> <span style="color: #8ae234;">Time</span>::HiRes qw<span style="color: #ad7fa8; font-style: italic;">( usleep gettimeofday tv_interval )</span>;
<span style="color: #729fcf; font-weight: bold;">use</span> <span style="color: #8ae234;">constant</span> DATA =&gt; <span style="color: #ad7fa8; font-style: italic;">"12345678"</span> x 128;   <span style="color: #888a85;"># 1KB&#12398;&#12487;&#12540;&#12479;</span>

<span style="color: #8ae234; font-weight: bold;">my</span> $<span style="color: #ff6347;">io</span> = IO::File-&gt;new(<span style="color: #ad7fa8; font-style: italic;">"test.dat"</span>, <span style="color: #ad7fa8; font-style: italic;">'w'</span>) or <span style="color: #729fcf; font-weight: bold;">die</span> $!;
<span style="color: #8ae234; font-weight: bold;">my</span> $<span style="color: #ff6347;">write_count</span> = 0;
<span style="color: #8ae234; font-weight: bold;">my</span> $<span style="color: #ff6347;">current_second</span> = 0;
<span style="color: #8ae234; font-weight: bold;">my</span> $<span style="color: #ff6347;">last_second</span> = 0;
<span style="color: #8ae234; font-weight: bold;">my</span> $<span style="color: #ff6347;">start_time</span> = Time::HiRes::time;

<span style="color: #729fcf; font-weight: bold;">while</span> (1) {

    $<span style="color: #ff6347;">io</span>-&gt;syswrite(DATA);
    <span style="color: #888a85;"># &#24375;&#21046;&#26360;&#12365;&#36796;&#12415;</span>
    IO::Handle::sync($<span style="color: #ff6347;">io</span>);

    <span style="color: #888a85;"># &#26178;&#21051;&#24773;&#22577;&#12392;&#26360;&#12365;&#36796;&#12415;&#22238;&#25968;&#12398;&#20986;&#21147;&#20966;&#29702;</span>
    $<span style="color: #ff6347;">current_second</span> = sprintf(<span style="color: #ad7fa8; font-style: italic;">"%.0f"</span>, Time::HiRes::time - $<span style="color: #ff6347;">start_time</span>);
    <span style="color: #729fcf; font-weight: bold;">if</span> ($<span style="color: #ff6347;">current_second</span> != $<span style="color: #ff6347;">last_second</span>) {
        print STDOUT <span style="color: #ad7fa8; font-style: italic;">"$last_second \t$write_count\n"</span>;
        $<span style="color: #ff6347;">last_second</span> = $<span style="color: #ff6347;">current_second</span>;
        $<span style="color: #ff6347;">write_count</span> = 0;
    }
    $<span style="color: #ff6347;">write_count</span> += 1;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> sarコマンドでIOPSを確認する</h3>
<div class="outline-text-3" id="text-2-3">
<p>
<code>sar</code> コマンドを利用して実測IOPS値を確認することが出来ます。出力結果の４列目の <code>wtps</code>
はIOPSに相当します。
</p>
<pre class="example">
$ sar -b 1 10
Linux 3.15.2-1-ARCH (*******)   2014年07月08日   _x86_64_    (4 CPU)

16時47分08秒       tps      rtps      wtps   bread/s   bwrtn/s
16時47分09秒    136.00      1.00    135.00     24.00   1008.00
16時47分10秒    120.00      0.00    120.00      0.00    912.00
16時47分11秒    143.00      0.00    143.00      0.00   1112.00
16時47分12秒    130.00      0.00    130.00      0.00    976.00
16時47分13秒     53.00      0.00     53.00      0.00    400.00
16時47分14秒      0.00      0.00      0.00      0.00      0.00
16時47分15秒      0.00      0.00      0.00      0.00      0.00
16時47分16秒      7.00      7.00      0.00    296.00      0.00
16時47分17秒      0.00      0.00      0.00      0.00      0.00
16時47分18秒      0.00      0.00      0.00      0.00      0.00
平均値:      58.90      0.80     58.10     32.00    440.80
$
</pre>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> 測定結果</h3>
<div class="outline-text-3" id="text-2-4">
<p>
ファイル出力処理スクリプトの出力結果。
</p>
<ul class="org-ul">
<li>１列目： 実行開始からの秒数
</li>
<li>２列目： 秒間 <code>sync</code> コール回数
</li>
</ul>
<pre class="example">
$ ./simple_iops_test.pl
0   13
1   25
2   24
3   24
4   30
5   30
6   22
7   13
8   30
9   26
10  25
11  25
12  27
13  28
$
</pre>

<p>
IOPSの実測値
</p>
<pre class="example">
$ sar -b 1 1000
Linux 3.15.2-1-ARCH (******)    2014年07月08日   _x86_64_    (4 CPU)

16時49分06秒       tps      rtps      wtps   bread/s   bwrtn/s
16時49分07秒     79.00      0.00     79.00      0.00    624.00
16時49分08秒    124.00      0.00    124.00      0.00    936.00
16時49分09秒    122.00      0.00    122.00      0.00   1824.00
16時49分10秒    125.00      0.00    125.00      0.00    944.00
16時49分11秒    150.00      0.00    150.00      0.00   1128.00
16時49分12秒    148.00      0.00    148.00      0.00   1144.00
16時49分13秒    129.00     30.00     99.00   2488.00    856.00
16時49分14秒    125.00     48.00     77.00   6264.00    960.00
16時49分15秒    150.00      0.00    150.00      0.00   1128.00
16時49分16秒    127.00      0.00    127.00      0.00    952.00
16時49分17秒    128.00      0.00    128.00      0.00    992.00
16時49分18秒    125.00      0.00    125.00      0.00    944.00
16時49分19秒    132.00      0.00    132.00      0.00   1008.00
16時49分20秒    140.00      0.00    140.00      0.00   1064.00
16時49分21秒     66.00      0.00     66.00      0.00    488.00

16時49分21秒      0.00      0.00      0.00      0.00      0.00
平均値:     123.60      5.16    118.44    578.45    990.88
$
</pre>

<p>
無限ループ処理中にほどんどんのIOが <code>write</code> であることが分かります。
また、ディスクへの秒間書き込み回数が120〜150ですが、アプリ側の秒間書き込み回数
が約24〜30程度です。
</p>

<font color="red"><strong>
<p>
つまり１回の <code>sync</code> コールで平均5回のディスクIOが発生したのようです。
IOPSが150ぐらいのHDDなら、平均で秒間ログ30件しか吐けない結果になります。
</p>
</strong></font>

<p>
別途単発のWrite処理を確認したところ、確かに１回の <code>sync</code> コール ５回のIOが起きたこと
が確認されました。（※内部の仕組みはまたわかっていないです。iNodeの更新などメタデータ
ブロックの更新によるものと推測しています。）
</p>

<p>
SSD、Fusion-ioの様なIOPSを稼げるストレージについて、机上で計算した結果は以下になりま
す。
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">&#xa0;</th>
<th scope="col" class="left">IOPS</th>
<th scope="col" class="left">秒間syncできる回数</th>
<th scope="col" class="left">備考</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">Fusion-io ioDrive2</td>
<td class="left">9,608,000</td>
<td class="left">1,921,600</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">SSD (SATA 6 Gbit/s)</td>
<td class="left">120,000</td>
<td class="left">24,000</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">SSD (PCIe)</td>
<td class="left">250,000</td>
<td class="left">50,000</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">SSD (SATA 6 Gbit/s)</td>
<td class="left">90,000</td>
<td class="left">18,000</td>
<td class="left">市販のSDD</td>
</tr>
</tbody>
</table>

<p>
秒間１万回以上書けるってホントウ？ SSD持ってないので確認出来ない。
</p>
</div>
</div>
</div>




<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 参考リンク</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li><a href="http://d.hatena.ne.jp/naoya/20070523/1179938637">Linux I/O のお話 write 編</a>
</li>
<li><a href="http://d.hatena.ne.jp/akuwano/20120223/1330016926">iops確認するための1Liner</a>
</li>
</ul>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[検証]SSHトンネル機能でVPN環境の構築]]></title>
    <link href="http://luozengbin.github.io/blog/2014-06-30-%5B%E6%A4%9C%E8%A8%BC%5DSSH%E3%83%88%E3%83%B3%E3%83%8D%E3%83%AB%E6%A9%9F%E8%83%BD%E3%81%A7VPN%E7%92%B0%E5%A2%83%E3%81%AE%E6%A7%8B%E7%AF%89.html"/>
    <updated>2014-06-30T00:00:00+09:00</updated>
    <id>http://luozengbin.github.io/blog/[検証]SSHトンネル機能でVPN環境の構築</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. SSHトンネリング</a></li>
<li><a href="#sec-2">2. TUNデバイス利用方式</a>
<ul>
<li><a href="#sec-2-1">2.1. 1.sshdに対してトンネリングを有効化する</a></li>
<li><a href="#sec-2-2">2.2. 2.rootユーザログインできるように公開鍵を登録する</a></li>
<li><a href="#sec-2-3">2.3. 3.SSHトンネルを開設する</a></li>
<li><a href="#sec-2-4">2.4. 4.各TUNデバイスにIPアドレスを付与する</a></li>
<li><a href="#sec-2-5">2.5. 5.区間１トンネルと区間２トンネルを結び付ける</a></li>
</ul>
</li>
<li><a href="#sec-3">3. TAPデバイス利用方式</a>
<ul>
<li><a href="#sec-3-1">3.1. 区間１の設定</a></li>
<li><a href="#sec-3-2">3.2. 区間２の設定</a></li>
</ul>
</li>
<li><a href="#sec-4">4. おまけに</a></li>
<li><a href="#sec-5">5. 参考リンク</a></li>
</ul>
</div>
</div>


<p>
友人に自宅のLAN内のコンテンツを共有するため、VPNについて検証しました。
自宅のルータはYamahaのRTX810です。このルータのVPN機能を使えば簡単に出来てしまうので面
白くないと思って、敢えてSSHのトンネル機能を使って0円VPN環境を構築してみた。
</p>




<p>
更に難易度を上げて、自宅WAN側のグローバルIPを公開せずにAmazonEC2インスタンスをVPN経路
に挟むことにしました。
</p>




<p>
<!-- more -->
</p>




<p>
通信経路イメージは以下のようになります。
</p>


<ul class="org-ul">
<li>区間１、友人PCとAmazonEC2間SSHトンネリングして通信する
</li>
<li>区間２、AmazonEC2間とRaspberry Pi間SSHトンネリングして通信する
</li>
<li>AmazonEC2インスタンスにて２つのSSHトンネルをethernet bridgeかiptablesによる結び付ける
</li>
<li>区間２のRaspberry PiにてProxy ARPかiptablesによるLANとの通信経路を制御する
</li>
</ul>




<pre class="example">
+-------------区間１---------+      +-------------区間２-----------------------+

                                                        ________________________
                                                       /      自宅LAN
                                                      |
                                                     /
                                __                  /
                            ___/  \_               |
+--------------+          _/        \__           / (DNAT)         +---------------+
|              |         /  (sshd)     \          +---------+      |   (sshd)      |
|  Tomodati    +--ssh--- |  Amazon EC2  ---ssh----+ RTX810  +------+ Raspberry Pi  |
|              |         \_           __/         +---------+      |               |
+--------------+           \__     __/            \                +---------------+
                              \___/                |
                                                    \
                                                     \
                                                      |
                                                       \________________________
</pre>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> SSHトンネリング</h2>
<div class="outline-text-2" id="text-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">方式</th>
<th scope="col" class="left">通信イメージ</th>
<th scope="col" class="left">broadcast</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">ppp over ssh</td>
<td class="left">トンネルの両端に仮想ダイヤルアップPPPで結び付ける</td>
<td class="left">☓</td>
</tr>

<tr>
<td class="left">TUNデバイス</td>
<td class="left">トンネルの両端に仮想TUNデバイスで結び付ける</td>
<td class="left">△</td>
</tr>

<tr>
<td class="left">TAPデバイス</td>
<td class="left">トンネルの両端に仮想tapデバイスで結び付ける</td>
<td class="left">◯</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>Point-to-Point TUN DeviceTUN
<ul class="org-ul">
<li>TUNデバイスはLayer3をエミュレートし、IPフレームを転送します。
</li>
<li>IP-in-IP トンネリング (Point-to-Point: PPP通信と似ている)
</li>
<li>GRE トンネリング (※未確認)
</li>
</ul>
</li>
<li>Ethernet TAP Device
<ul class="org-ul">
<li>TAPデバイスはLayer2(Ethernet)をエミュレートし、Ethernetフレームを転送します。
</li>
</ul>
</li>
</ul>

<p>
TUNデバイスとTAPデバイス利用するに当たって、 <code>tun</code> というカーネルモジュールが必要とし
ます。 SSHトンネリング時に自動的にロードしてくれます。
</p>

<pre class="example">
[akira@tomodati ~]$ modinfo tun
filename:       /lib/modules/3.15.2-1-ARCH/kernel/drivers/net/tun.ko.gz
alias:          devname:net/tun
alias:          char-major-10-200
license:        GPL
author:         (C) 1999-2004 Max Krasnyansky &lt;maxk@qualcomm.com&gt;
description:    Universal TUN/TAP device driver
depends:
intree:         Y
vermagic:       3.15.2-1-ARCH SMP preempt mod_unload modversions
[akira@tomodati ~]$
</pre>

<p>
<code>tun</code> カーネルモジュールのデバイス初期化処理のコード（カーネルバージョン:3.12）
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #888a85;">/* </span><span style="color: #888a85;">Initialize net device. </span><span style="color: #888a85;">*/</span>
<span style="color: #729fcf; font-weight: bold;">static</span> <span style="color: #8ae234; font-weight: bold;">void</span> <span style="color: #edd400; font-weight: bold;">tun_net_init</span>(<span style="color: #729fcf; font-weight: bold;">struct</span> <span style="color: #8ae234; font-weight: bold;">net_device</span> *<span style="color: #ff6347;">dev</span>)
{
    <span style="color: #729fcf; font-weight: bold;">struct</span> <span style="color: #8ae234; font-weight: bold;">tun_struct</span> *<span style="color: #ff6347;">tun</span> = netdev_priv(dev);

    <span style="color: #729fcf; font-weight: bold;">switch</span> (tun-&gt;flags &amp; TUN_TYPE_MASK) {
    <span style="color: #729fcf; font-weight: bold;">case</span> TUN_TUN_DEV:
        dev-&gt;netdev_ops = &amp;tun_netdev_ops;

        <span style="color: #888a85;">/* </span><span style="color: #888a85;">Point-to-Point TUN Device </span><span style="color: #888a85;">*/</span>
        dev-&gt;hard_header_len = 0;
        dev-&gt;addr_len = 0;
        dev-&gt;mtu = 1500;

        <span style="color: #888a85;">/* </span><span style="color: #888a85;">Zero header length </span><span style="color: #888a85;">*/</span>
        dev-&gt;type = ARPHRD_NONE;
        dev-&gt;flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;
        dev-&gt;tx_queue_len = TUN_READQ_SIZE;  <span style="color: #888a85;">/* </span><span style="color: #888a85;">We prefer our own queue length </span><span style="color: #888a85;">*/</span>
        <span style="color: #729fcf; font-weight: bold;">break</span>;

    <span style="color: #729fcf; font-weight: bold;">case</span> TUN_TAP_DEV:
        dev-&gt;netdev_ops = &amp;tap_netdev_ops;
        <span style="color: #888a85;">/* </span><span style="color: #888a85;">Ethernet TAP Device </span><span style="color: #888a85;">*/</span>
        ether_setup(dev);
        dev-&gt;priv_flags &amp;= ~IFF_TX_SKB_SHARING;
        dev-&gt;priv_flags |= IFF_LIVE_ADDR_CHANGE;

        eth_hw_addr_random(dev);

        dev-&gt;tx_queue_len = TUN_READQ_SIZE;  <span style="color: #888a85;">/* </span><span style="color: #888a85;">We prefer our own queue length </span><span style="color: #888a85;">*/</span>
        <span style="color: #729fcf; font-weight: bold;">break</span>;
    }
}
</pre>
</div>

<p>
TUNデバイスのIP-in-IP方式とppp方式どちらもPPPプロトコルを使ってSSHトンネル両端間で通信
するため、本検証ではppp方式を検証対象外としました。
</p>
</div>
</div>




<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> TUNデバイス利用方式</h2>
<div class="outline-text-2" id="text-2">
<p>
TUNデバイスでトンネリングする、iptablesとルーティングテーブルで交通を整理する。
</p>

<ul class="org-ul">
<li>区間１:SSHトンネルでTomodatiとAmazonEC2間Point-To-Pointで通信できるようにする
</li>
<li>区間２:SSHトンネルでAmazonEC2とRaspberryPi間Point-To-Pointで通信できるようにする
</li>
<li>AmazonEC2にて区間１と区間２のパケットをルーティングさせる（★ルータ的な役割）
</li>
</ul>

<p>
以下は通信イメージ図です。区間１と区間２リンク層の物理NICを表していない。
</p>
<pre class="example">
       +-----------区間１---------+                  +----------区間２------+
       |                          |                  |                      |
       |                          |                  |                      |
 &lt;&lt;Tomodati&gt;&gt;              &lt;&lt;AmazonEC2&gt;&gt;                             &lt;&lt;RaspberryPi&gt;&gt;
┏━━━━━━━┓        ┏━━━━━━━━━━━━━━━━┓      ┏━━━━━━━━━━━┓
┃              ┃        ┃[sshd]                          ┃      ┃[sshd]                ┃
┃    ┏━━┓  ┃ &lt;ssh&gt;  ┃  ┏━━┓            ┏━━┓  ┃&lt;ssh&gt; ┃  ┏━━┓   ┏━━┓ ┃
┃    ┃tun0┣━╋━━━━╋━┫tun0┃&gt;&gt;&gt; SNAT &gt;&gt;&gt;┃tun1┣━╋━━━╋━┫tun1┃   ┃eth0┣━━192.168.100.0/24
┃    ┗━━┛  ┃        ┃  ┗━━┛            ┗━━┛  ┃      ┃  ┗━━┛   ┗━━┛ ┃         ^
┃  192.168.3.1 ┃        ┃192.168.3.2          192.168.4.1┃      ┃ 192.168.4.2          ┃         |
┗━━━━━━━┛        ┗━━━━━━━━━━━━━━━━┛      ┗━━━━━━━━━━━┛         |
        |                                                                                              |
        |                      多重VPN経路を通して、192.168.100.0/24へアクセスする                     |
        +----------------------------------------------------------------------------------------------+
</pre>

<p>
構築手順
</p>
<ul class="org-ul">
<li>1. sshdに対してトンネリングを有効化する
</li>
<li>2. rootユーザログインできるように公開鍵を登録する ※1
</li>
<li>3. SSHトンネルを開設する
</li>
<li>4. 各TUNデバイスにIPアドレスを付与する
</li>
<li>5. 区間１トンネルと区間２トンネルを結び付ける
</li>
</ul>

<p>
※1: sshログイン時にtapデバイスファイルを自動生成するためにクライアント側とサーバ側に
     root特権を持つアカウントを利用せざるを得ない。
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 1.sshdに対してトンネリングを有効化する</h3>
<div class="outline-text-3" id="text-2-1">
<p>
AmazonEC2インスタンスとRaspberryPiが設定対象となります。 <code>/etc/ssh/sshd_config</code> ファイ
ルに以下の内容を追加して、 <code>sshd</code> サービスをリロードする。
</p>

<pre class="example">
########################################################################
# トンネリング機能を有効化する
#    point-to-point … Layer 3 のトンネリングのみを許可 (TUNデバイスを使用)
#    ethernet … Layer 2 のトンネリングのみを許可 (tapデバイスを使用)
#    yes … 両方のタイプのトンネリングを許可 (クライアントがトンネリングのタイプを選べる)
#    no … トンネリングを許可しない
########################################################################
PermitTunnel yes
</pre>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 2.rootユーザログインできるように公開鍵を登録する</h3>
<div class="outline-text-3" id="text-2-2">
<p>
区間１はAmazonEC2へのログインですので、EC2インスタンス作成時に生成された秘密鍵でログ
インできる。
</p>

<p>
区間２のログインは公開鍵方式を使うため、以下の手順で鍵生成と登録を実施する。
</p>
<ul class="org-ul">
<li>Tomodatiにて <code>ssh-keygen</code> で鍵ペアを作成する。
</li>
<li>生成された公開鍵 <code>id_rsa.pub</code> の内容をAmazonEC2の <code>/root/.ssh/authorized_keys</code> に追加する。
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> 3.SSHトンネルを開設する</h3>
<div class="outline-text-3" id="text-2-3">
<p>
rootユーザでsshコマンドにオプションを付けてログインすることでSSHトンネルが開設される。
一々オプションを指定するのが面倒なので、 <code>/root/.ssh/config</code> にまとめて書きましょう。
</p>

<p>
区間１のSSHトンネルを開設するための <code>/root/.ssh/config</code>
</p>
<pre class="example">
Host     amazon-vpn
  HostName        xxxxxxxx.compute.amazonaws.com   ★AmazonEC2インスタンスのPublic DNS
  User            root
  IdentityFile    /tmp/private-ec2.pem             ★秘密鍵
  LogLevel        DEBUG
  Tunnel          point-to-point                   ★tun方式
  TunnelDevice    0:0                              ★デバイスペアの番号(tun0 ... tun0)
  RequestTTY      no
  PermitLocalCommand yes
  LocalCommand    /tmp/setup_tun0_client           ★ログイン成功後ローカルで実行するコマンドの定義
</pre>

<p>
区間２のSSHトンネルを開設するための <code>/root/.ssh/config</code>
</p>
<pre class="example">
Host    jitaku-vpn
  HostName        xxxxx.mydns.jp  ★RTX810のWAN側のグローバルIP
  User            root
  Port            22              ★SSHポート
  LogLevel        DEBUG
  Tunnel          point-to-point
  TunnelDevice    1:1
  RequestTTY      no
  PermitLocalCommand yes
  LocalCommand    /tmp/setup_tun1_client
</pre>

<p>
区間１のSSHトンネル起動時のログ
</p>
<pre class="example">
[root@tomodati ~]# ssh amazon-vpn
debug1: permanently_set_uid: 0/0
debug1: permanently_drop_suid: 0
debug1: identity file /tmp/private-ec2.pem type -1
debug1: identity file /tmp/private-ec2.pem-cert type -1
debug1: Enabling compatibility mode for protocol 2.0
debug1: Local version string SSH-2.0-OpenSSH_6.6.1
debug1: Remote protocol version 2.0, remote software version OpenSSH_6.6.1p1 Ubuntu-2ubuntu2
debug1: match: OpenSSH_6.6.1p1 Ubuntu-2ubuntu2 pat OpenSSH_6.6.1* compat 0x04000000
debug1: SSH2_MSG_KEXINIT sent
debug1: SSH2_MSG_KEXINIT received
debug1: kex: server-&gt;client aes128-ctr hmac-md5-etm@openssh.com none
debug1: kex: client-&gt;server aes128-ctr hmac-md5-etm@openssh.com none
debug1: sending SSH2_MSG_KEX_ECDH_INIT
debug1: expecting SSH2_MSG_KEX_ECDH_REPLY
debug1: Server host key: ECDSA d8:71:41:32:08:0d:8a:4c:24:6a:74:45:21:7d:ef:0c
debug1: Host 'xxxxxxxx.compute.amazonaws.com' is known and matches the ECDSA host key.
debug1: Found key in /root/.ssh/known_hosts:3
debug1: ssh_ecdsa_verify: signature correct
debug1: SSH2_MSG_NEWKEYS sent
debug1: expecting SSH2_MSG_NEWKEYS
debug1: SSH2_MSG_NEWKEYS received
debug1: Roaming not allowed by server
debug1: SSH2_MSG_SERVICE_REQUEST sent
debug1: SSH2_MSG_SERVICE_ACCEPT received
debug1: Authentications that can continue: publickey
debug1: Next authentication method: publickey
debug1: Trying private key: /tmp/private-ec2.pem
debug1: key_parse_private2: missing begin marker
debug1: read PEM private key done: type RSA
debug1: Authentication succeeded (publickey).
Authenticated to xxxxxxxx.compute.amazonaws.com.
debug1: Requesting tun unit 0 in mode 1
debug1: sys_tun_open: tun0 mode 1 fd 3
debug1: channel 0: new [tun]
debug1: channel 1: new [client-session]
debug1: Requesting no-more-sessions@openssh.com
debug1: Entering interactive session.
</pre>

<p>
Tomodatiに <code>tun0</code> デバイスが生成されたことを確認する。
</p>
<pre class="example">
[root@tomodati ~]# ip link show | grep tun0
11: tun0: &lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UNKNOWN mode DEFAULT group default qlen 500
</pre>

<p>
区間２開設後、AmazonEC2に <code>tun1</code> デバイスが生成されたことを確認する。
</p>
<pre class="example">
root@ip-xxxxxxxx:~# ip link show | grep tun
★tun0 は区間１開設時生成されたデバイス
26: tun0: &lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UNKNOWN mode DEFAULT group default qlen 500

★tun1 は区間２開設時生成されたデバイス
27: tun1: &lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UNKNOWN mode DEFAULT group default qlen 500
root@ip-xxxxxxxx:~#
</pre>

<p>
RaspberryPiに生成された <code>tun1</code> デバイスを確認する
</p>
<pre class="example">
[root@pipi ~]# ifconfig | grep tun
tun1: flags=4305&lt;UP,POINTOPOINT,RUNNING,NOARP,MULTICAST&gt;  mtu 1500
[root@pipi ~]#
</pre>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> 4.各TUNデバイスにIPアドレスを付与する</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Tomodatiの <code>tun0</code> デバイスに <code>192.168.3.1</code> アドレスを指定する、Point-To-Point通信のた
め、対向側のTUNデバイスのIPアドレスも指定する。
</p>
<pre class="example">
★IPアドレス指定
[root@tomodati ~]# ifconfig tun0 192.168.3.1 pointopoint 192.168.3.2

★IPアドレス確認
[root@tomodati ~]# ifconfig tun0
tun0: flags=4305&lt;UP,POINTOPOINT,RUNNING,NOARP,MULTICAST&gt;  mtu 1500
        inet 192.168.3.1  netmask 255.255.255.255  destination 192.168.3.2
        unspec 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00  txqueuelen 500  (UNSPEC)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

★ルーティングテーブルに自動で追加された経路
[root@tomodati ~]# ip route show | grep tun
192.168.3.2 dev tun0  proto kernel  scope link  src 192.168.3.1
[root@tomodati ~]#
</pre>

<p>
AmazonEC2インスタンスのTUNデバイスにアドレスを指定する。
</p>
<pre class="example">
★区間１：tun0デバイスのIP指定
root@ip-xxxxxxxx:~# ifconfig tun0 192.168.3.2 pointopoint 192.168.3.1
root@ip-xxxxxxxx:~# ifconfig tun0
tun0      Link encap:UNSPEC  HWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00
          inet addr:192.168.3.2  P-t-P:192.168.3.1  Mask:255.255.255.255
          UP POINTOPOINT RUNNING NOARP MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:500 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

★区間２：tun1デバイスのIP指定
root@ip-xxxxxxxx:~# ifconfig tun1 192.168.4.1 pointopoint 192.168.4.2
root@ip-xxxxxxxx:~# ifconfig tun1
tun1      Link encap:UNSPEC  HWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00
          inet addr:192.168.4.1  P-t-P:192.168.4.2  Mask:255.255.255.255
          UP POINTOPOINT RUNNING NOARP MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:500 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

★ルーティングテーブルに自動で追加された経路
root@ip-xxxxxxxx:~# ip route show | grep tun
192.168.3.1 dev tun0  proto kernel  scope link  src 192.168.3.2 
192.168.4.2 dev tun1  proto kernel  scope link  src 192.168.4.1 
root@ip-xxxxxxxx:~#
</pre>

<p>
RaspberryPiのTUNデバイスにアドレスを指定する。
</p>

<pre class="example">
★IPアドレス指定
[root@pipi ~]# ifconfig tun1 192.168.4.2 pointopoint 192.168.4.1
[root@pipi ~]# ifconfig tun1
tun1: flags=4305&lt;UP,POINTOPOINT,RUNNING,NOARP,MULTICAST&gt;  mtu 1500
        inet 192.168.4.2  netmask 255.255.255.255  destination 192.168.4.1
        unspec 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00  txqueuelen 500  (UNSPEC)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

★ルーティングテーブルに自動で追加された経路
[root@pipi ~]# ip route show | grep tun
192.168.4.1 dev tun1  proto kernel  scope link  src 192.168.4.2 
[root@pipi ~]#
</pre>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> 5.区間１トンネルと区間２トンネルを結び付ける</h3>
<div class="outline-text-3" id="text-2-5">
<p>
AmazonEC2にてiptablesのSNAT機能を用いて区間１と区間２のパケットをルーティングさせる。
</p>
<pre class="example">
★ パケット転送を許可する
root@ip-xxxxxxxx:~# sysctl -w net.ipv4.ip_forward=1

★ tun0からtun1へ転送時にMASQUERADEを行う
root@ip-xxxxxxxx:~# iptables -t nat -A POSTROUTING -o tun1 -s 192.168.3.0/24 -j MASQUERADE
</pre>

<p>
区間１と区間２の各ノードに <code>192.168.100.0/24</code> への転送ルートを定義する。
</p>

<p>
Tomodatiに <code>192.168.100.0/24</code> への転送ルートを定義する。
</p>
<pre class="example">
[root@tomodati ~]# ip route add 192.168.100.0/24 via 192.168.3.2 dev tun0
[root@tomodati ~]# ip route show
192.168.3.2 dev tun0  proto kernel  scope link  src 192.168.3.1

★ 192.168.100.0/24への通信はすべてtun0を経路する
192.168.100.0/24 via 192.168.3.2 dev tun0
</pre>

<p>
AmazonEC2に <code>192.168.100.0/24</code> への転送ルートを定義する。
</p>
<pre class="example">
★ 区間１から =192.168.100.0/24= へのパケットを転送を許可する
root@ip-xxxxxxxx:~# iptables -A FORWARD -i tun0 -p tcp -d 192.168.100.0/24 -j ACCEPT

★ =192.168.100.0/24= への転送ルートを追加する
root@ip-xxxxxxxx:~# ip route add 192.168.100.0/24 via 192.168.4.2 dev tun1

★ 192.168.100.0/24への通信はすべてtun1を経路する
root@ip-xxxxxxxx:~# ip route show
192.168.3.1 dev tun0  proto kernel  scope link  src 192.168.3.2
192.168.4.2 dev tun1  proto kernel  scope link  src 192.168.4.1
192.168.100.0/24 via 192.168.4.2 dev tun1
</pre>

<p>
RaspberryPiに <code>192.168.100.0/24</code> への転送ルートを定義する。
</p>

<pre class="example">
★ ローカルサブネットへルーティング時のDNAT設定
[root@pipi ~]# sysctl -w net.ipv4.ip_forward=1

★ tun1 から eth0 出て行く時にMASQUERADEする
[root@pipi ~]# iptables -t nat -A POSTROUTING -o eth0 -s 192.168.4.0/24 -j MASQUERADE
</pre>

<p>
ここまで、区間１から <code>192.168.100.0/24</code> への接続ができるようになります。逆方向の接続
は同じ考え方でiptables、ルーティングテーブルを駆使すればできると思います。
</p>
</div>
</div>
</div>




<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> TAPデバイス利用方式</h2>
<div class="outline-text-2" id="text-3">
<p>
TAPデバイスはLayer2(Ethernet)をエミュレートできるため <code>bridge</code> カーネルモジュールや
ARP Proxy 機能と組み合わせて柔軟なVPNを構成することが可能になります。
</p>

<p>
VPNネットワーク構成概要
</p>
<ul class="org-ul">
<li>VPN部分を自宅LANのサブネットセグメントとして定義する
</li>
<li>区間１、区間２はTAPデバイスよりSSHトンネリングする
</li>
<li>区間１と区間２はBridgeで繋ぐ (★AmazonEC2はハブ的な役割)
</li>
<li>RaspberryPiノード上のtapとeth0間でARP PROXYし、２つセグメントを繋ぐ
</li>
</ul>

<p>
以下は通信イメージ図です。一部リンク層の物理NICを表していない。
</p>
<pre class="example">
   +---------------------------------------------------------------------------------------------------------------------+
   |                                                                            〜自宅のLANセグメント〜                  |
   |   +-----------------------------------------------------------------+                                               |
   |   |         〜多重VPNによるサブネットセグメント〜                   |                                               |
   |   |           network   : 192.168.100.48/29                         |    network   : 192.168.100.0/24               |
   |   |           netmask   : 255.255.255.248                           |    netmask   : 255.255.255.0                  |
   |   |           broadcast : 192.168.100.55                            |    broadcast : 192.168.100.255                |
   |   |           gateway   : 192.168.100.54                            |    gateway   : 192.168.100.1                  |
   |   |           ip range  : 192.168.100.49〜192.168.100.54            |    ip range  : 192.168.100.1〜192.168.100.254 |
   |   |                                                                 |                                               |
   |   |                                                                 |                                               |
   |   +-----------区間１--------+                  +--------区間２------+                                               |
   |   |                         |                  |                    |                                               |
 &lt;&lt;Tomodati&gt;&gt;              &lt;&lt;AmazonEC2&gt;&gt;                             &lt;&lt;RaspberryPi&gt;&gt;                                     |
┏━━━━━━━┓        ┏━━━━━━━━━━━━━━━┓      ┏━━━━━━━━━━━━━━━━┓                   |
┃              ┃        ┃[sshd]                        ┃      ┃[sshd]                          ┃                   |
┃              ┃        ┃        ┏━━━━━┓        ┃      ┃                                ┃                   |
┃              ┃        ┃      ┏┫    br0   ┣┓      ┃      ┃                                ┃                   |
┃              ┃        ┃      ┃┗━━━━━┛┃      ┃      ┃                                ┃                   |
┃192.168.100.49┃        ┃      ┃192.168.100.50┃      ┃      ┃192.168.100.54                  ┃                   |
┃    ┏━━┓  ┃ &lt;ssh&gt;  ┃  ┏━┻┓          ┏┻━┓  ┃&lt;ssh&gt; ┃  ┏━━┓             ┏━━┓ ┃                   |
┃    ┃tap0┣━╋━━━━╋━┫tap0┃          ┃tap1┣━╋━━━╋━┫tap1┃&lt;&lt;ARP PROXY&gt;&gt;┃eth0┣━━192.168.100.0/24--+
┃    ┗━━┛  ┃        ┃  ┗━━┛          ┗━━┛  ┃      ┃  ┗━━┛             ┗━━┛ ┃         ^
┗━━━━━━━┛        ┗━━━━━━━━━━━━━━━┛      ┗━━━━━━━━━━━━━━━━┛         |
        |                                                                                                      |
        |                      多重VPN経路を通して、192.168.100.0/24へアクセスする                             |
        +------------------------------------------------------------------------------------------------------+
</pre>

<p>
区間２のRaspberryPiノード上のtap1とeth0の繋ぐ方法について、=ARP PROXY= 以外にBridge方
式もできる。Bridge方式だと <code>192.168.100.0/24</code> セグメントのブロードキャストパケットが
全部AamzonEC2に転送されて、AWSの課金が飛んでしまう可能性があるため、 <code>ARP PROXY</code> 方
式のほうが適していると勝手な判断です。
</p>

<p>
構築の詳細手順を割愛します。検証で作成したスクリプトを以下に示します。
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 区間１の設定</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Tomodati <code>/root/.ssh/config</code> ：SSHクライアント設定
</p>
<pre class="example">
Host     amazon-vpn-tap
  HostName        xxxxxxxx.compute.amazonaws.com   ★AmazonEC2インスタンスのPublic DNS
  User            root
  IdentityFile    /tmp/private-ec2.pem             ★秘密鍵
  LogLevel        DEBUG
  Tunnel          ethernet                         ★tap方式
  TunnelDevice    0:0                              ★デバイスペアの番号(tap0 ... tap0)
  RequestTTY      no
  PermitLocalCommand yes
  LocalCommand    /tmp/setup_tap0_client           ★ログイン成功後ローカルで実行するコマンドの定義
</pre>

<p>
Tomodati <code>/tmp/setup_tap0_client</code>
</p>
<pre class="example">
#!/bin/sh

## tap0のIPアドレスアサイン
ifconfig tap0 192.168.100.49/29

## 192.168.100.0/24 セグメントへのルート定義
ip route add 192.168.100.0/24 via 192.168.100.54 dev tap0
</pre>

<p>
AmazonEC2 <code>/root/.ssh/authorized_keys</code>
</p>
<pre class="example">
★rootユーザでログイン後 /root/.ssh/setup_tap0 を実行する定義
no-port-forwarding,no-agent-forwarding,no-X11-forwarding,command="/root/.ssh/setup_tap0" ssh-rsa xxxxxxxxx
                                                         ~~~~~~~ ←rootユーザで実行できるコマンドを限定する
</pre>

<p>
AmazonEC2 <code>/root/.ssh/setup_tap0</code> 、brctlコマンドは <code>bridge-utils</code> パッケージに含まれ
ている。
</p>
<pre class="example">
#!/bin/bash

## br0 ブリッジデバイスを作成
brctl addbr br0

## br0 ブリッジデバイスにIPをアサインする
ifconfig br0 192.168.100.51/29

## tap0デバイスを活性化する
ip link set tap0 up

## tap0デバイスを br0 ブリッジに刺す
brctl addif br0 tap0
</pre>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 区間２の設定</h3>
<div class="outline-text-3" id="text-3-2">
<p>
AmazonEC2 <code>/root/.ssh/config</code> ：SSHクライアント設定
</p>
<pre class="example">
Host     jitaku-vpn-tap
  HostName        xxxxx.mydns.jp  ★RTX810のWAN側のグローバルIP
  User            root
  Port            22              ★SSHポート
  LogLevel        DEBUG
  Tunnel          ethernet                         ★tap方式
  TunnelDevice    1:1
  RequestTTY      no
  PermitLocalCommand yes
  LocalCommand    /tmp/setup_tap1_client           ★ログイン成功後ローカルで実行するコマンドの定義
</pre>

<p>
AmazonEC2 <code>/tmp/setup_tap1_client</code>
</p>
<pre class="example">
#!/bin/sh

## tap1デバイスを活性化する
ip link set tap1 up

## tap1デバイスを br0 ブリッジに刺す
brctl addif br0 tap1

## 192.168.100.0/24 セグメントへのルート定義
ip route add 192.168.100.0/24 via 192.168.100.54 dev br0
</pre>

<p>
RaspberryPi <code>/root/.ssh/authorized_keys</code>
</p>
<pre class="example">
★rootユーザでログイン後 /root/.ssh/setup_tap1 を実行する定義
no-port-forwarding,no-agent-forwarding,no-X11-forwarding,command="/root/.ssh/setup_tap1" ssh-rsa xxxxxxxxx
</pre>

<p>
RaspberryPi <code>/root/.ssh/setup_tap1</code>
</p>
<pre class="example">
#!/bin/sh

## tap1デバイスにIPをアサインする
ifconfig tap1 192.168.100.54/29

## APR PROXY機能を有効にする
sysctl -w net.ipv4.ip_forward=1
sysctl -w net.ipv4.conf.eth0.proxy_arp=1
</pre>
</div>
</div>
</div>




<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> おまけに</h2>
<div class="outline-text-2" id="text-4">
<p>
今後機会があれば、TUNデバイス方式とTAPデバイス方式の性能を比較したいと思います。
TAP の方が Ethernetヘッダが付加されるため、TUNより通信量が多いいのでTUNの方がが
性能がいいかもしれない。但しTUN方式はPoint-To-Point通信であるため、BroadCastや
MultiCastが出来ない部分とネットワークセグメント間のパケット転送の設定（iptabels）
が面倒の部分もあります。
</p>
</div>
</div>




<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 参考リンク</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li><a href="http://www.komoto.org/vpn/index.html">VPN技術について</a>
</li>
<li><a href="http://www.unixuser.org/~euske/doc/openssh/book/chap6.html#real-vpn">入門OpenSSH - 第6章 すすんだ使い方</a>
</li>
<li><a href="http://www.usupi.org/sysad/248.html">SSH でVPNを実現する</a>
</li>
<li><a href="http://www.usupi.org/sysad/066.html">お試しネットワーク環境を作る ～ Proxy ARP 編</a>
</li>
<li><a href="http://web.mit.edu/rhel-doc/4/RH-DOCS/rhel-sg-ja-4/s1-firewall-ipt-fwd.html">Red Hat Enterprise Linux 4: セキュリティガイド</a>
</li>
<li><a href="https://access.redhat.com/site/documentation/ja-JP/Red_Hat_Enterprise_Linux/6/html/Security_Guide/sect-Security_Guide-Firewalls-FORWARD_and_NAT_Rules.html">FORWARD および NAT ルール</a>
</li>
<li><a href="http://sgros.blogspot.jp/2011/11/tunneling-everything-with-ssh-or-how-to.html">Tunneling everything with SSH&#x2026; or how to make VPNs&#x2026;</a>
</li>
<li><a href="http://sgros.blogspot.jp/2011/11/ssh-vpns-bridged-connection-to-lan.html">SSH VPNs: Bridged connection to LAN using tap</a>
</li>
</ul>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[メモ]リモートXの接続方法]]></title>
    <link href="http://luozengbin.github.io/blog/2014-06-21-%5B%E3%83%A1%E3%83%A2%5D%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%88x%E3%81%AE%E6%8E%A5%E7%B6%9A%E6%96%B9%E6%B3%95.html"/>
    <updated>2014-06-21T00:00:00+09:00</updated>
    <id>http://luozengbin.github.io/blog/[メモ]リモートxの接続方法</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 検証環境</a></li>
<li><a href="#sec-2">2. xhostによるXアプリを起動する方式</a></li>
<li><a href="#sec-3">3. SSH X11フォワード方式</a></li>
<li><a href="#sec-4">4. VNC方式</a></li>
<li><a href="#sec-5">5. ローカルで異なるユーザでXアプリの起動</a></li>
<li><a href="#sec-6">6. 参考サイト</a></li>
</ul>
</div>
</div>


<p>
リモートLinuxサーバでXアプリを利用するケースはしばしばあります。
実現方式について調べてみた。
</p>




<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="right">No</th>
<th scope="col" class="left">サーバ側</th>
<th scope="col" class="left">クライアント側</th>
<th scope="col" class="left">備考</th>
</tr>
</thead>
<tbody>
<tr>
<td class="right">1</td>
<td class="left">DISPLAY変数の指定</td>
<td class="left">xhostよりアクセス許可</td>
<td class="left">クライアント側6000番ポートの開放が必要</td>
</tr>

<tr>
<td class="right">2</td>
<td class="left">SSH X11 Forwarding</td>
<td class="left">ssh -X で接続する</td>
<td class="left">サーバ側：X11Forwarding yes が必要　</td>
</tr>

<tr>
<td class="right">3</td>
<td class="left">Xdmcp(udp:177)</td>
<td class="left">Xサーバとして動く</td>
<td class="left">Display Managerがエントリ画面になる</td>
</tr>

<tr>
<td class="right">4</td>
<td class="left">VNCサーバ(tcp:5901〜)</td>
<td class="left">VNCビューア</td>
<td class="left">よく使われる</td>
</tr>

<tr>
<td class="right">5</td>
<td class="left">XRDP</td>
<td class="left">XRDPクライアントソフト</td>
<td class="left">WindowsのRemote Desktop Procotol</td>
</tr>
</tbody>
</table>




<p>
VNCとXRDP以外のサーバとクライアントの役割
</p>


<ul class="org-ul">
<li>サーバ側:       Xアプリを動かす側
</li>
<li>クライアント側: Xサーバを動かす側
</li>
</ul>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 検証環境</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>クライアント: GDM経由でGnome3が動いているGUI環境
</li>
<li>サーバ: CUIモードLinux環境
</li>
</ul>

<pre class="example">
┏━━━━━━━┓      ┏━━━━━━━┓
┃ クライアント ┃      ┃   サーバ     ┃
┃  mimi-air    ┣━━━┫    pipi      ┃
┃192.168.100.13┃      ┃192.169.100.4 ┃
┗━━━━━━━┛      ┗━━━━━━━┛
</pre>

<p>
<!-- more -->
</p>
</div>
</div>




<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> xhostによるXアプリを起動する方式</h2>
<div class="outline-text-2" id="text-2">
<p>
通信イメージ
</p>
<pre class="example">
┏━━━━━━━━━━━━━━━━━┓        ┏━━━━━━━┓
┃    クライアント（Xサーバ）       ┃        ┃   サーバ     ┃
┃ Unixソケット                tcp  ┃        ┃   Xアプリ    ┃
┃ /tmp/.X11-unix/X0   &lt;----&gt;  6000 &lt;&lt;━━━━┫$DISPLAY      ┃
┗━━━━━━━━━━━━━━━━━┛        ┗━━━━━━━┛
</pre>

<p>
GDMパラメータにTCP接続許可の設定を行う。
</p>
<ul class="org-ul">
<li><code>/etc/gdm/custom.conf</code> に <code>DisallowTcp=false</code> を追加する。
</li>
<li><code>/usr/share/gdm/gdm.schemas</code> に <code>security/DisallowTCP</code> の値を <code>false</code> へ変更する。
</li>
</ul>

<p>
設定後、GDMを再起動して <code>netstat</code> コマンドで <code>6000</code> ポートがリスニング状態であること
を確認したうえで、 <code>xhost</code> コマンドでサーバからのアクセスを許可するようにする。
XサーバのTCP受け待ちポート番号は <code>6000+スクリン番号</code> 式で決まる。 Xサーバがスクリン１
で起動された場合TCP受け待ちポート番号が6001となります。通常は０番スクリーンが利用され
る。
</p>

<pre class="example">
[akira@mimi-air ~]$ sudo netstat -nutpl | grep 6000
tcp        0      0 0.0.0.0:6000            0.0.0.0:*               LISTEN      2115/Xorg
tcp6       0      0 :::6000                 :::*                    LISTEN      2115/Xorg

★アクセス許可
[akira@mimi-air ~]$ xhost + 192.168.100.4
192.168.100.4 being added to access control list

★アクセス許可リストの確認
[akira@mimi-air ~]$ xhost
access control enabled, only authorized clients can connect
INET:pipi
SI:localuser:akira
SI:localuser:gdm
SI:localuser:root
[akira@mimi-air ~]$
</pre>

<p>
サーバ側の <code>DISPLAY</code> 環境変数をクライアントをXサーバへ指すように変更する。
</p>
<pre class="example">
★環境変数設定
[akira@pipi ~]$ export DISPLAY=192.168.100.13:0.0

★環境変数確認
[akira@pipi ~]$ env | grep DISPLAY
DISPLAY=192.168.100.13:0.0

★Xアプリ起動して確認する
[akira@pipi ~]$ leafpad
</pre>
</div>
</div>




<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> SSH X11フォワード方式</h2>
<div class="outline-text-2" id="text-3">
<p>
通信イメージ
</p>
<pre class="example">
┏━━━━━━━━━━━━━━━━━┓        ┏━━━━━━━━━━━━━━━━━━━━━━┓
┃    クライアント（Xサーバ）       ┃        ┃      サーバ (Xアプリ)                      ┃
┃ Unixソケット                tcp  ┃ ssh -X ┃tcp                      Unixソケット       ┃
┃ /tmp/.X11-unix/X0   &lt;----&gt;  ssh  &lt;&lt;━━━━┫sshd &lt;---&gt; tcp:6010 &lt;--&gt; /tmp/.X11-unix/X10 ┃
┗━━━━━━━━━━━━━━━━━┛        ┗━━━━━━━━━━━━━━━━━━━━━━┛
</pre>

<p>
設定作業と接続手順
</p>
<ul class="org-ul">
<li>サーバ側のSSHにX11フォワードを許可するようにする。
</li>
<li>クライアントから <code>ssh -X</code> で接続する。
</li>
</ul>

<p>
クライアントからサーバに接続するに際にサーバサイトで以下の処理が実装される。
</p>
<ul class="org-ul">
<li>DISPLAY環境変数を <code>localhost:10.0</code> に設定する。
</li>
<li><code>xauth</code> コマンドで <code>~/.Xauthority</code> に認証用クッキーを追加する。
</li>
</ul>

<p>
<code>ssh -X</code> で接続時にエラーが起きた場合、 <code>-v</code> オプションでデバッグメッセージの出力を有
効にするとトラブルの原因究明に効果的かもしれない。
</p>

<pre class="example">
■サーバ側
------------------------------------------------------------

★サーバ側のX11Forwarding設定値を確認する
[akira@pipi ~]$ cat /etc/ssh/sshd_config | grep X11Forwarding
X11Forwarding yes
[akira@pipi ~]$ 

■クライアント側
------------------------------------------------------------
★-Xオプションつけてサーバへ接続する
[akira@mimi-air ~]$ ssh -X pipi
Last login: Sun Jun 22 08:58:59 2014 from 192.168.100.13

■サーバ側
------------------------------------------------------------
★DISPLAY環境変数の確認
[akira@pipi ~]$ env | grep DISPLAY
DISPLAY=localhost:10.0

★~/.Xauthorityに登録されたクッキーの確認
[akira@pipi ~]$ xauth list
pipi/unix:10  MIT-MAGIC-COOKIE-1  75af091faa9e151987efb8fb46c5e2d3

★6010ポートのリスリング状態の確認
[akira@pipi ~]$ sudo netstat -nutpl | grep 6010 
tcp        0      0 127.0.0.1:6010          0.0.0.0:*               LISTEN      9772/sshd: akira@pt 

★Xアプリを起動して見る
[akira@pipi ~]$ leafpad 
Xlib:  extension "RANDR" missing on display "localhost:10.0".
Gtk-Message: Failed to load module "canberra-gtk-module"
leafpad: can't save config file - /home/akira/.config/leafpad/leafpadrc
</pre>

<p>
サーバ側X11フォワードが有効でない、クライアントにて <code>ssh -X localhost</code> でX11のunixソケッ
トをTCPの6010ポートに変換する。クライアントからサーバへ接続時にローカルの6010ポートを
サーバ側にフォワードする方式もあります。この場合、サーバ側の <code>DISPLAY</code> 環境変数と
<code>~/.Xauthority</code> の認証クッキーの追加を手動で行う必要があります。
</p>

<p>
以下はその接続イメージです。
</p>
<pre class="example">
┏━━━━━━━━━━━━━━┓    ┏━━━━━━━━━━━━━━┓
┃    クライアント（Xサーバ） ┃    ┃     サーバ(Xアプリ)        ┃
┃ Unixソケット               ┃    ┃                            ┃
┃ /tmp/.X11-unix/X0          ┃    ┃        /tmp/.X11-unix/X10  ┃
┃     ↓                     ┃    ┃                ↑          ┃
┃  tcp:6010 &lt;-------&gt; ssh    ┣━━┫ sshd &lt;---&gt; localhost:6010  ┃
┗━━━━━━━━━━━━━━┛    ┗━━━━━━━━━━━━━━┛
</pre>

<p>
設定作業と接続手順
</p>
<ul class="org-ul">
<li>ローカルののSSHにX11フォワードを許可するようにする。
</li>
<li>クライアントにて <code>ssh -X localhost</code> で接続する。
</li>
<li><code>ssh -R 6010</code> でサーバへ接続する
</li>
<li>サーバ側の <code>DISPLAY</code> 環境変数を設定する
</li>
<li>サーバ側の <code>~/.Xauthority</code> 認証クッキーを追加する
</li>
</ul>

<pre class="example">
■クライアント側
------------------------------------------------------------
★クライアント側のssh設定の確認
[akira@mimi-air ~]$ cat /etc/ssh/sshd_config | grep X11Forwarding
X11Forwarding yes

★X11のUnixソケットをTCPへ変換する
[akira@mimi-air ~]$ ssh -X localhost
Last login: Sat Jun 21 13:10:45 2014 from localhost.localdomain

[akira@mimi-air ~]$ sudo netstat -nutpl | grep 6010
[sudo] password for akira: 
tcp        0      0 127.0.0.1:6010          0.0.0.0:*               LISTEN      18706/sshd: akira@p 
tcp6       0      0 ::1:6010                :::*                    LISTEN      18706/sshd: akira@p 

★sshポートフォワーディングしてサーバへ接続する
[akira@mimi-air ~]$ ssh -R 6010:localhost:6010 pipi
Last login: Sun Jun 22 09:52:34 2014 from 192.168.100.13

■サーバ側
------------------------------------------------------------
★ポートフォワーディング有効であることを確認する
[akira@pipi ~]$ sudo netstat -nutpl | grep 6010
tcp        0      0 127.0.0.1:6010          0.0.0.0:*               LISTEN      11106/sshd: akira@p 

★DISPLAY環境変数の指定
[akira@pipi ~]$ export DISPLAY=localhost:10.0

★Xアプリ起動失敗：X認証失敗が原因です
[akira@pipi ~]$ leafpad 
leafpad: Cannot open display: 

■クライアント側
------------------------------------------------------------
[akira@mimi-air ~]$ X11 connection rejected because of wrong authentication.

★X認証用クッキーを確認する
[akira@mimi-air ~]$ xauth list
mimi-air/unix:10  MIT-MAGIC-COOKIE-1  47ed008f47dc3eae07294ee49b26fb35
[akira@mimi-air ~]$ 

■サーバ側
------------------------------------------------------------
★既存のサーバサイトのX認証クッキーを削除する
[akira@pipi ~]$ xauth list
pipi/unix:10  MIT-MAGIC-COOKIE-1  75af091faa9e151987efb8fb46c5e2d3
[akira@pipi ~]$ xauth remove unix:10

★クライアント側登録されたX認証クッキーをサーバ側にも登録する
[akira@pipi ~]$ xauth add unix:10 MIT-MAGIC-COOKIE-1  47ed008f47dc3eae07294ee49b26fb35

★Xアプリ起動成功
[akira@pipi ~]$ leafpad 
Xlib:  extension "RANDR" missing on display "localhost:10.0".
Gtk-Message: Failed to load module "canberra-gtk-module"
leafpad: can't save config file - /home/akira/.config/leafpad/leafpadrc
[akira@pipi ~]$
</pre>
</div>
</div>




<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> VNC方式</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li><a href="https://wiki.archlinux.org/index.php/Vncserver_%2528%25E6%2597%25A5%25E6%259C%25AC%25E8%25AA%259E%2529">Archlinux Wiki: Vncserver (日本語)</a>
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> ローカルで異なるユーザでXアプリの起動</h2>
<div class="outline-text-2" id="text-5">
<p>
以下のようにコンソールからローカルの環境の別ユーザでXアプリを起動しようとするとエラー
になります。
</p>

<pre class="example">
★sudo -u で試す
[akira@mimi-air ~]$ sudo -u milan leafpad 
[sudo] password for akira: 
No protocol specified
leafpad: ディスプレイをオープンできません: 

★suでユーザ切り替えたから試す
[akira@mimi-air ~]$ su - milan
パスワード:
[milan@mimi-air ~]$ leafpad 
leafpad: ディスプレイをオープンできません: 
[milan@mimi-air ~]$
</pre>

<p>
次の手順で設定すれば、普通に起動出来ます。
</p>
<ul class="org-ul">
<li><code>DISPLAY</code> 環境変数の指定
</li>
<li><code>xauth</code> でX認証クッキーの登録
</li>
</ul>

<pre class="example">
[akira@mimi-air ~]$ su - milan
パスワード:
[milan@mimi-air ~]$ export DISPLAY=:0
[milan@mimi-air ~]$ xauth list
[milan@mimi-air ~]$ xauth add unix:0 MIT-MAGIC-COOKIE-1  75de7d9075e9582838e38aad909df062
[milan@mimi-air ~]$ leafpad 
[milan@mimi-air ~]$
</pre>
</div>
</div>




<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 参考サイト</h2>
<div class="outline-text-2" id="text-6">
<ul class="org-ul">
<li><a href="http://vega.sra-tohoku.co.jp/~kabe/vsd/ssh-x.html">最近の豪華なX11環境でsshを使ってＸプロトコルを中継する</a>
</li>
<li><a href="http://www.ibm.com/developerworks/jp/linux/tutorials/l-basics/">Linux ビギナーのための基本タスク</a>
</li>
</ul>
</div>
</div>

]]></content>
  </entry>
  
</feed>
