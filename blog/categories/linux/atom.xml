<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | Akira's Tech Notes]]></title>
  <link href="http://luozengbin.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://luozengbin.github.io/"/>
  <updated>2014-07-01T12:17:54+09:00</updated>
  <id>http://luozengbin.github.io/</id>
  <author>
    <name><![CDATA[luozengbin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[検証]SSHトンネル機能でVPN環境の構築]]></title>
    <link href="http://luozengbin.github.io/blog/2014-06-30-%5B%E6%A4%9C%E8%A8%BC%5DSSH%E3%83%88%E3%83%B3%E3%83%8D%E3%83%AB%E6%A9%9F%E8%83%BD%E3%81%A7VPN%E7%92%B0%E5%A2%83%E3%81%AE%E6%A7%8B%E7%AF%89.html"/>
    <updated>2014-06-30T00:00:00+09:00</updated>
    <id>http://luozengbin.github.io/blog/[検証]SSHトンネル機能でVPN環境の構築</id>
    <content type="html"><![CDATA[<p>
友人に自宅のLAN内のコンテンツを共有するため、VPNについて検証しました。
自宅のルータはYamahaのRTX810です。このルータのVPN機能を使えば簡単に出来てしまうので面
白くないと思って、敢えてSSHのトンネル機能を使って0円VPN環境を構築してみた。
</p>




<p>
更に難易度を上げて、自宅WAN側のグローバルIPを公開せずにAmazonEC2インスタンスをVPN経路
に挟むことにしました。
</p>




<p>
<!-- more -->
</p>




<p>
通信経路イメージは以下のようになります。
</p>


<ul class="org-ul">
<li>区間１、友人PCとAmazonEC2間SSHトンネリングして通信する
</li>
<li>区間２、AmazonEC2間とRaspberry Pi間SSHトンネリングして通信する
</li>
<li>AmazonEC2インスタンスにて２つのSSHトンネルをethernet bridgeかiptablesによる結び付ける
</li>
<li>区間２のRaspberry PiにてProxy ARPかiptablesによるLANとの通信経路を制御する
</li>
</ul>




<pre class="example">
+-------------区間１---------+      +-------------区間２-----------------------+

                                                        ________________________
                                                       /      自宅LAN
                                                      |
                                                     /
                                __                  /
                            ___/  \_               |
+--------------+          _/        \__           / (DNAT)         +---------------+
|              |         /  (sshd)     \          +---------+      |   (sshd)      |
|  Tomodati    +--ssh--- |  Amazon EC2  ---ssh----+ RTX810  +------+ Raspberry Pi  |
|              |         \_           __/         +---------+      |               |
+--------------+           \__     __/            \                +---------------+
                              \___/                |
                                                    \
                                                     \
                                                      |
                                                       \________________________
</pre>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">SSHトンネリング</h2>
<div class="outline-text-2" id="text-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">方式</th>
<th scope="col" class="left">通信イメージ</th>
<th scope="col" class="left">broadcast</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">ppp over ssh</td>
<td class="left">トンネルの両端に仮想ダイヤルアップPPPで結び付ける</td>
<td class="left">☓</td>
</tr>

<tr>
<td class="left">TUNデバイス</td>
<td class="left">トンネルの両端に仮想TUNデバイスで結び付ける</td>
<td class="left">△</td>
</tr>

<tr>
<td class="left">TAPデバイス</td>
<td class="left">トンネルの両端に仮想tapデバイスで結び付ける</td>
<td class="left">◯</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>Point-to-Point TUN DeviceTUN
<ul class="org-ul">
<li>TUNデバイスはLayer3をエミュレートし、IPフレームを転送します。
</li>
<li>IP-in-IP トンネリング (Point-to-Point: PPP通信と似ている)
</li>
<li>GRE トンネリング (※未確認)
</li>
</ul>
</li>
<li>Ethernet TAP Device
<ul class="org-ul">
<li>TAPデバイスはLayer2(Ethernet)をエミュレートし、Ethernetフレームを転送します。
</li>
</ul>
</li>
</ul>

<p>
TUNデバイスとTAPデバイス利用するに当たって、 <code>tun</code> というカーネルモジュールが必要とし
ます。 SSHトンネリング時に自動的にロードしてくれます。
</p>

<pre class="example">
[akira@tomodati ~]$ modinfo tun
filename:       /lib/modules/3.15.2-1-ARCH/kernel/drivers/net/tun.ko.gz
alias:          devname:net/tun
alias:          char-major-10-200
license:        GPL
author:         (C) 1999-2004 Max Krasnyansky &lt;maxk@qualcomm.com&gt;
description:    Universal TUN/TAP device driver
depends:
intree:         Y
vermagic:       3.15.2-1-ARCH SMP preempt mod_unload modversions
[akira@tomodati ~]$
</pre>

<p>
<code>tun</code> カーネルモジュールのデバイス初期化処理のコード（カーネルバージョン:3.12）
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #888a85;">/* </span><span style="color: #888a85;">Initialize net device. </span><span style="color: #888a85;">*/</span>
<span style="color: #00bfff; font-weight: bold;">static</span> <span style="color: #8ae234; font-weight: bold;">void</span> <span style="color: #edd400; font-weight: bold;">tun_net_init</span>(<span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #8ae234; font-weight: bold;">net_device</span> *<span style="color: #ff6347;">dev</span>)
{
    <span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #8ae234; font-weight: bold;">tun_struct</span> *<span style="color: #ff6347;">tun</span> = netdev_priv(dev);

    <span style="color: #00bfff; font-weight: bold;">switch</span> (tun-&gt;flags &amp; TUN_TYPE_MASK) {
    <span style="color: #00bfff; font-weight: bold;">case</span> TUN_TUN_DEV:
        dev-&gt;netdev_ops = &amp;tun_netdev_ops;

        <span style="color: #888a85;">/* </span><span style="color: #888a85;">Point-to-Point TUN Device </span><span style="color: #888a85;">*/</span>
        dev-&gt;hard_header_len = 0;
        dev-&gt;addr_len = 0;
        dev-&gt;mtu = 1500;

        <span style="color: #888a85;">/* </span><span style="color: #888a85;">Zero header length </span><span style="color: #888a85;">*/</span>
        dev-&gt;type = ARPHRD_NONE;
        dev-&gt;flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;
        dev-&gt;tx_queue_len = TUN_READQ_SIZE;  <span style="color: #888a85;">/* </span><span style="color: #888a85;">We prefer our own queue length </span><span style="color: #888a85;">*/</span>
        <span style="color: #00bfff; font-weight: bold;">break</span>;

    <span style="color: #00bfff; font-weight: bold;">case</span> TUN_TAP_DEV:
        dev-&gt;netdev_ops = &amp;tap_netdev_ops;
        <span style="color: #888a85;">/* </span><span style="color: #888a85;">Ethernet TAP Device </span><span style="color: #888a85;">*/</span>
        ether_setup(dev);
        dev-&gt;priv_flags &amp;= ~IFF_TX_SKB_SHARING;
        dev-&gt;priv_flags |= IFF_LIVE_ADDR_CHANGE;

        eth_hw_addr_random(dev);

        dev-&gt;tx_queue_len = TUN_READQ_SIZE;  <span style="color: #888a85;">/* </span><span style="color: #888a85;">We prefer our own queue length </span><span style="color: #888a85;">*/</span>
        <span style="color: #00bfff; font-weight: bold;">break</span>;
    }
}
</pre>
</div>

<p>
TUNデバイスのIP-in-IP方式とppp方式どちらもPPPプロトコルを使ってSSHトンネル両端間で通信
するため、本検証ではppp方式を検証対象外としました。
</p>
</div>
</div>




<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">TUNデバイス利用方式</h2>
<div class="outline-text-2" id="text-2">
<p>
TUNデバイスでトンネリングする、iptablesとルーティングテーブルで交通を整理する。
</p>

<ul class="org-ul">
<li>区間１:SSHトンネルでTomodatiとAmazonEC2間Point-To-Pointで通信できるようにする
</li>
<li>区間２:SSHトンネルでAmazonEC2とRaspberryPi間Point-To-Pointで通信できるようにする
</li>
<li>AmazonEC2にて区間１と区間２のパケットをルーティングさせる（★ルータ的な役割）
</li>
</ul>

<p>
以下は通信イメージ図です。区間１と区間２リンク層の物理NICを表していない。
</p>
<pre class="example">
       +-----------区間１---------+                  +----------区間２------+
       |                          |                  |                      |
       |                          |                  |                      |
 &lt;&lt;Tomodati&gt;&gt;              &lt;&lt;AmazonEC2&gt;&gt;                             &lt;&lt;RaspberryPi&gt;&gt;
┏━━━━━━━┓        ┏━━━━━━━━━━━━━━━━┓      ┏━━━━━━━━━━━┓
┃              ┃        ┃[sshd]                          ┃      ┃[sshd]                ┃
┃    ┏━━┓  ┃ &lt;ssh&gt;  ┃  ┏━━┓            ┏━━┓  ┃&lt;ssh&gt; ┃  ┏━━┓   ┏━━┓ ┃
┃    ┃tun0┣━╋━━━━╋━┫tun0┃&gt;&gt;&gt; SNAT &gt;&gt;&gt;┃tun1┣━╋━━━╋━┫tun1┃   ┃eth0┣━━192.168.100.0/24
┃    ┗━━┛  ┃        ┃  ┗━━┛            ┗━━┛  ┃      ┃  ┗━━┛   ┗━━┛ ┃         ^
┃  192.168.3.1 ┃        ┃192.168.3.2          192.168.4.1┃      ┃ 192.168.4.2          ┃         |
┗━━━━━━━┛        ┗━━━━━━━━━━━━━━━━┛      ┗━━━━━━━━━━━┛         |
        |                                                                                              |
        |                      多重VPN経路を通して、192.168.100.0/24へアクセスする                     |
        +----------------------------------------------------------------------------------------------+
</pre>

<p>
構築手順
</p>
<ul class="org-ul">
<li>1. sshdに対してトンネリングを有効化する
</li>
<li>2. rootユーザログインできるように公開鍵を登録する ※1
</li>
<li>3. SSHトンネルを開設する
</li>
<li>4. 各TUNデバイスにIPアドレスを付与する
</li>
<li>5. 区間１トンネルと区間２トンネルを結び付ける
</li>
</ul>

<p>
※1: sshログイン時にtapデバイスファイルを自動生成するためにクライアント側とサーバ側に
     root特権を持つアカウントを利用せざるを得ない。
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">sshdに対してトンネリングを有効化する</h3>
<div class="outline-text-3" id="text-2-1">
<p>
AmazonEC2インスタンスとRaspberryPiが設定対象となります。 <code>/etc/ssh/sshd_config</code> ファイ
ルに以下の内容を追加して、 <code>sshd</code> サービスをリロードする。
</p>

<pre class="example">
########################################################################
# トンネリング機能を有効化する
#    point-to-point … Layer 3 のトンネリングのみを許可 (TUNデバイスを使用)
#    ethernet … Layer 2 のトンネリングのみを許可 (tapデバイスを使用)
#    yes … 両方のタイプのトンネリングを許可 (クライアントがトンネリングのタイプを選べる)
#    no … トンネリングを許可しない
########################################################################
PermitTunnel yes
</pre>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">rootユーザログインできるように公開鍵を登録する</h3>
<div class="outline-text-3" id="text-2-2">
<p>
区間１はAmazonEC2へのログインですので、EC2インスタンス作成時に生成された秘密鍵でログ
インできる。
</p>

<p>
区間２のログインは公開鍵方式を使うため、以下の手順で鍵生成と登録を実施する。
</p>
<ul class="org-ul">
<li>Tomodatiにて <code>ssh-keygen</code> で鍵ペアを作成する。
</li>
<li>生成された公開鍵 <code>id_rsa.pub</code> の内容をAmazonEC2の <code>/root/.ssh/authorized_keys</code> に追加する。
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">SSHトンネルを開設する</h3>
<div class="outline-text-3" id="text-2-3">
<p>
rootユーザでsshコマンドにオプションを付けてログインすることでSSHトンネルが開設される。
一々オプションを指定するのが面倒なので、 <code>/root/.ssh/config</code> にまとめて書きましょう。
</p>

<p>
区間１のSSHトンネルを開設するための <code>/root/.ssh/config</code>
</p>
<pre class="example">
Host     amazon-vpn
  HostName        xxxxxxxx.compute.amazonaws.com   ★AmazonEC2インスタンスのPublic DNS
  User            root
  IdentityFile    /tmp/private-ec2.pem             ★秘密鍵
  LogLevel        DEBUG
  Tunnel          point-to-point                   ★tun方式
  TunnelDevice    0:0                              ★デバイスペアの番号(tun0 ... tun0)
  RequestTTY      no
  PermitLocalCommand yes
  LocalCommand    /tmp/setup_tun0_client           ★ログイン成功後ローカルで実行するコマンドの定義
</pre>

<p>
区間２のSSHトンネルを開設するための <code>/root/.ssh/config</code>
</p>
<pre class="example">
Host    jitaku-vpn
  HostName        xxxxx.mydns.jp  ★RTX810のWAN側のグローバルIP
  User            root
  Port            22              ★SSHポート
  LogLevel        DEBUG
  Tunnel          point-to-point
  TunnelDevice    1:1
  RequestTTY      no
  PermitLocalCommand yes
  LocalCommand    /tmp/setup_tun1_client
</pre>

<p>
区間１のSSHトンネル起動時のログ
</p>
<pre class="example">
[root@tomodati ~]# ssh amazon-vpn
debug1: permanently_set_uid: 0/0
debug1: permanently_drop_suid: 0
debug1: identity file /tmp/private-ec2.pem type -1
debug1: identity file /tmp/private-ec2.pem-cert type -1
debug1: Enabling compatibility mode for protocol 2.0
debug1: Local version string SSH-2.0-OpenSSH_6.6.1
debug1: Remote protocol version 2.0, remote software version OpenSSH_6.6.1p1 Ubuntu-2ubuntu2
debug1: match: OpenSSH_6.6.1p1 Ubuntu-2ubuntu2 pat OpenSSH_6.6.1* compat 0x04000000
debug1: SSH2_MSG_KEXINIT sent
debug1: SSH2_MSG_KEXINIT received
debug1: kex: server-&gt;client aes128-ctr hmac-md5-etm@openssh.com none
debug1: kex: client-&gt;server aes128-ctr hmac-md5-etm@openssh.com none
debug1: sending SSH2_MSG_KEX_ECDH_INIT
debug1: expecting SSH2_MSG_KEX_ECDH_REPLY
debug1: Server host key: ECDSA d8:71:41:32:08:0d:8a:4c:24:6a:74:45:21:7d:ef:0c
debug1: Host 'xxxxxxxx.compute.amazonaws.com' is known and matches the ECDSA host key.
debug1: Found key in /root/.ssh/known_hosts:3
debug1: ssh_ecdsa_verify: signature correct
debug1: SSH2_MSG_NEWKEYS sent
debug1: expecting SSH2_MSG_NEWKEYS
debug1: SSH2_MSG_NEWKEYS received
debug1: Roaming not allowed by server
debug1: SSH2_MSG_SERVICE_REQUEST sent
debug1: SSH2_MSG_SERVICE_ACCEPT received
debug1: Authentications that can continue: publickey
debug1: Next authentication method: publickey
debug1: Trying private key: /tmp/private-ec2.pem
debug1: key_parse_private2: missing begin marker
debug1: read PEM private key done: type RSA
debug1: Authentication succeeded (publickey).
Authenticated to xxxxxxxx.compute.amazonaws.com.
debug1: Requesting tun unit 0 in mode 1
debug1: sys_tun_open: tun0 mode 1 fd 3
debug1: channel 0: new [tun]
debug1: channel 1: new [client-session]
debug1: Requesting no-more-sessions@openssh.com
debug1: Entering interactive session.
</pre>

<p>
Tomodatiに <code>tun0</code> デバイスが生成されたことを確認する。
</p>
<pre class="example">
[root@tomodati ~]# ip link show | grep tun0
11: tun0: &lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UNKNOWN mode DEFAULT group default qlen 500
</pre>

<p>
区間２開設後、AmazonEC2に <code>tun1</code> デバイスが生成されたことを確認する。
</p>
<pre class="example">
root@ip-xxxxxxxx:~# ip link show | grep tun
★tun0 は区間１開設時生成されたデバイス
26: tun0: &lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UNKNOWN mode DEFAULT group default qlen 500

★tun1 は区間２開設時生成されたデバイス
27: tun1: &lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UNKNOWN mode DEFAULT group default qlen 500
root@ip-xxxxxxxx:~#
</pre>

<p>
RaspberryPiに生成された <code>tun1</code> デバイスを確認する
</p>
<pre class="example">
[root@pipi ~]# ifconfig | grep tun
tun1: flags=4305&lt;UP,POINTOPOINT,RUNNING,NOARP,MULTICAST&gt;  mtu 1500
[root@pipi ~]#
</pre>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">各TUNデバイスにIPアドレスを付与する</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Tomodatiの <code>tun0</code> デバイスに <code>192.168.3.1</code> アドレスを指定する、Point-To-Point通信のた
め、対向側のTUNデバイスのIPアドレスも指定する。
</p>
<pre class="example">
★IPアドレス指定
[root@tomodati ~]# ifconfig tun0 192.168.3.1 pointopoint 192.168.3.2

★IPアドレス確認
[root@tomodati ~]# ifconfig tun0
tun0: flags=4305&lt;UP,POINTOPOINT,RUNNING,NOARP,MULTICAST&gt;  mtu 1500
        inet 192.168.3.1  netmask 255.255.255.255  destination 192.168.3.2
        unspec 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00  txqueuelen 500  (UNSPEC)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

★ルーティングテーブルに自動で追加された経路
[root@tomodati ~]# ip route show | grep tun
192.168.3.2 dev tun0  proto kernel  scope link  src 192.168.3.1
[root@tomodati ~]#
</pre>

<p>
AmazonEC2インスタンスのTUNデバイスにアドレスを指定する。
</p>
<pre class="example">
★区間１：tun0デバイスのIP指定
root@ip-xxxxxxxx:~# ifconfig tun0 192.168.3.2 pointopoint 192.168.3.1
root@ip-xxxxxxxx:~# ifconfig tun0
tun0      Link encap:UNSPEC  HWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00
          inet addr:192.168.3.2  P-t-P:192.168.3.1  Mask:255.255.255.255
          UP POINTOPOINT RUNNING NOARP MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:500 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

★区間２：tun1デバイスのIP指定
root@ip-xxxxxxxx:~# ifconfig tun1 192.168.4.1 pointopoint 192.168.4.2
root@ip-xxxxxxxx:~# ifconfig tun1
tun1      Link encap:UNSPEC  HWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00
          inet addr:192.168.4.1  P-t-P:192.168.4.2  Mask:255.255.255.255
          UP POINTOPOINT RUNNING NOARP MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:500 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

★ルーティングテーブルに自動で追加された経路
root@ip-xxxxxxxx:~# ip route show | grep tun
192.168.3.1 dev tun0  proto kernel  scope link  src 192.168.3.2 
192.168.4.2 dev tun1  proto kernel  scope link  src 192.168.4.1 
root@ip-xxxxxxxx:~#
</pre>

<p>
RaspberryPiのTUNデバイスにアドレスを指定する。
</p>

<pre class="example">
★IPアドレス指定
[root@pipi ~]# ifconfig tun1 192.168.4.2 pointopoint 192.168.4.1
[root@pipi ~]# ifconfig tun1
tun1: flags=4305&lt;UP,POINTOPOINT,RUNNING,NOARP,MULTICAST&gt;  mtu 1500
        inet 192.168.4.2  netmask 255.255.255.255  destination 192.168.4.1
        unspec 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00  txqueuelen 500  (UNSPEC)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

★ルーティングテーブルに自動で追加された経路
[root@pipi ~]# ip route show | grep tun
192.168.4.1 dev tun1  proto kernel  scope link  src 192.168.4.2 
[root@pipi ~]#
</pre>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">区間１トンネルと区間２トンネルを結び付ける</h3>
<div class="outline-text-3" id="text-2-5">
<p>
AmazonEC2にてiptablesのSNAT機能を用いて区間１と区間２のパケットをルーティングさせる。
</p>
<pre class="example">
★ パケット転送を許可する
root@ip-xxxxxxxx:~# sysctl -w net.ipv4.ip_forward=1

★ tun0からtun1へ転送時にMASQUERADEを行う
root@ip-xxxxxxxx:~# iptables -t nat -A POSTROUTING -o tun1 -s 192.168.3.0/24 -j MASQUERADE
</pre>

<p>
区間１と区間２の各ノードに <code>192.168.100.0/24</code> への転送ルートを定義する。
</p>

<p>
Tomodatiに <code>192.168.100.0/24</code> への転送ルートを定義する。
</p>
<pre class="example">
[root@tomodati ~]# ip route add 192.168.100.0/24 via 192.168.3.2 dev tun0
[root@tomodati ~]# ip route show
192.168.3.2 dev tun0  proto kernel  scope link  src 192.168.3.1

★ 192.168.100.0/24への通信はすべてtun0を経路する
192.168.100.0/24 via 192.168.3.2 dev tun0
</pre>

<p>
AmazonEC2に <code>192.168.100.0/24</code> への転送ルートを定義する。
</p>
<pre class="example">
★ 区間１から =192.168.100.0/24= へのパケットを転送を許可する
root@ip-xxxxxxxx:~# iptables -A FORWARD -i tun0 -p tcp -d 192.168.100.0/24 -j ACCEPT

★ =192.168.100.0/24= への転送ルートを追加する
root@ip-xxxxxxxx:~# ip route add 192.168.100.0/24 via 192.168.4.2 dev tun1

★ 192.168.100.0/24への通信はすべてtun1を経路する
root@ip-xxxxxxxx:~# ip route show
192.168.3.1 dev tun0  proto kernel  scope link  src 192.168.3.2
192.168.4.2 dev tun1  proto kernel  scope link  src 192.168.4.1
192.168.100.0/24 via 192.168.4.2 dev tun1
</pre>

<p>
RaspberryPiに <code>192.168.100.0/24</code> への転送ルートを定義する。
</p>

<pre class="example">
★ ローカルサブネットへルーティング時のDNAT設定
[root@pipi ~]# sysctl -w net.ipv4.ip_forward=1

★ tun1 から eth0 出て行く時にMASQUERADEする
[root@pipi ~]# iptables -t nat -A POSTROUTING -o eth0 -s 192.168.4.0/24 -j MASQUERADE
</pre>

<p>
ここまで、区間１から <code>192.168.100.0/24</code> への接続ができるようになります。逆方向の接続
は同じ考え方でiptables、ルーティングテーブルを駆使すればできると思います。
</p>
</div>
</div>
</div>




<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">TAPデバイス利用方式</h2>
<div class="outline-text-2" id="text-3">
<p>
TAPデバイスはLayer2(Ethernet)をエミュレートできるため <code>bridge</code> カーネルモジュールや
ARP Proxy 機能と組み合わせて柔軟なVPNを構成することが可能になります。
</p>

<p>
VPNネットワーク構成概要
</p>
<ul class="org-ul">
<li>VPN部分を自宅LANのサブネットセグメントとして定義する
</li>
<li>区間１、区間２はTAPデバイスよりSSHトンネリングする
</li>
<li>区間１と区間２はBridgeで繋ぐ (★AmazonEC2はハブ的な役割)
</li>
<li>RaspberryPiノード上のtapとeth0間でARP PROXYし、２つセグメントを繋ぐ
</li>
</ul>

<p>
以下は通信イメージ図です。一部リンク層の物理NICを表していない。
</p>
<pre class="example">
   +---------------------------------------------------------------------------------------------------------------------+
   |                                                                            〜自宅のLANセグメント〜                  |
   |   +-----------------------------------------------------------------+                                               |
   |   |         〜多重VPNによるサブネットセグメント〜                   |                                               |
   |   |           network   : 192.168.100.48/29                         |    network   : 192.168.100.0/24               |
   |   |           netmask   : 255.255.255.248                           |    netmask   : 255.255.255.0                  |
   |   |           broadcast : 192.168.100.55                            |    broadcast : 192.168.100.255                |
   |   |           gateway   : 192.168.100.54                            |    gateway   : 192.168.100.1                  |
   |   |           ip range  : 192.168.100.49〜192.168.100.54            |    ip range  : 192.168.100.1〜192.168.100.254 |
   |   |                                                                 |                                               |
   |   |                                                                 |                                               |
   |   +-----------区間１--------+                  +--------区間２------+                                               |
   |   |                         |                  |                    |                                               |
 &lt;&lt;Tomodati&gt;&gt;              &lt;&lt;AmazonEC2&gt;&gt;                             &lt;&lt;RaspberryPi&gt;&gt;                                     |
┏━━━━━━━┓        ┏━━━━━━━━━━━━━━━┓      ┏━━━━━━━━━━━━━━━━┓                   |
┃              ┃        ┃[sshd]                        ┃      ┃[sshd]                          ┃                   |
┃              ┃        ┃        ┏━━━━━┓        ┃      ┃                                ┃                   |
┃              ┃        ┃      ┏┫    br0   ┣┓      ┃      ┃                                ┃                   |
┃              ┃        ┃      ┃┗━━━━━┛┃      ┃      ┃                                ┃                   |
┃192.168.100.49┃        ┃      ┃192.168.100.50┃      ┃      ┃192.168.100.54                  ┃                   |
┃    ┏━━┓  ┃ &lt;ssh&gt;  ┃  ┏━┻┓          ┏┻━┓  ┃&lt;ssh&gt; ┃  ┏━━┓             ┏━━┓ ┃                   |
┃    ┃tap0┣━╋━━━━╋━┫tap0┃          ┃tap1┣━╋━━━╋━┫tap1┃&lt;&lt;ARP PROXY&gt;&gt;┃eth0┣━━192.168.100.0/24--+
┃    ┗━━┛  ┃        ┃  ┗━━┛          ┗━━┛  ┃      ┃  ┗━━┛             ┗━━┛ ┃         ^
┗━━━━━━━┛        ┗━━━━━━━━━━━━━━━┛      ┗━━━━━━━━━━━━━━━━┛         |
        |                                                                                                      |
        |                      多重VPN経路を通して、192.168.100.0/24へアクセスする                             |
        +------------------------------------------------------------------------------------------------------+
</pre>

<p>
区間２のRaspberryPiノード上のtap1とeth0の繋ぐ方法について、=ARP PROXY= 以外にBridge方
式もできる。Bridge方式だと <code>192.168.100.0/24</code> セグメントのブロードキャストパケットが
全部AamzonEC2に転送されて、AWSの課金が飛んでしまう可能性があるため、 <code>ARP PROXY</code> 方
式のほうが適していると勝手な判断です。
</p>

<p>
構築の詳細手順を割愛します。検証で作成したスクリプトを以下に示します。
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">区間１の設定</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Tomodati <code>/root/.ssh/config</code> ：SSHクライアント設定
</p>
<pre class="example">
Host     amazon-vpn-tap
  HostName        xxxxxxxx.compute.amazonaws.com   ★AmazonEC2インスタンスのPublic DNS
  User            root
  IdentityFile    /tmp/private-ec2.pem             ★秘密鍵
  LogLevel        DEBUG
  Tunnel          ethernet                         ★tap方式
  TunnelDevice    0:0                              ★デバイスペアの番号(tap0 ... tap0)
  RequestTTY      no
  PermitLocalCommand yes
  LocalCommand    /tmp/setup_tap0_client           ★ログイン成功後ローカルで実行するコマンドの定義
</pre>

<p>
Tomodati <code>/tmp/setup_tap0_client</code>
</p>
<pre class="example">
#!/bin/sh

## tap0のIPアドレスアサイン
ifconfig tap0 192.168.100.49/29

## 192.168.100.0/24 セグメントへのルート定義
ip route add 192.168.100.0/24 via 192.168.100.54 dev tap0
</pre>

<p>
AmazonEC2 <code>/root/.ssh/authorized_keys</code>
</p>
<pre class="example">
★rootユーザでログイン後 /root/.ssh/setup_tap0 を実行する定義
no-port-forwarding,no-agent-forwarding,no-X11-forwarding,command="/root/.ssh/setup_tap0" ssh-rsa xxxxxxxxx
                                                         ~~~~~~~ ←rootユーザで実行できるコマンドを限定する
</pre>

<p>
AmazonEC2 <code>/root/.ssh/setup_tap0</code> 、brctlコマンドは <code>bridge-utils</code> パッケージに含まれ
ている。
</p>
<pre class="example">
#!/bin/bash

## br0 ブリッジデバイスを作成
brctl addbr br0

## br0 ブリッジデバイスにIPをアサインする
ifconfig br0 192.168.100.51/29

## tap0デバイスを活性化する
ip link set tap0 up

## tap0デバイスを br0 ブリッジに刺す
brctl addif br0 tap0
</pre>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">区間２の設定</h3>
<div class="outline-text-3" id="text-3-2">
<p>
AmazonEC2 <code>/root/.ssh/config</code> ：SSHクライアント設定
</p>
<pre class="example">
Host     jitaku-vpn-tap
  HostName        xxxxx.mydns.jp  ★RTX810のWAN側のグローバルIP
  User            root
  Port            22              ★SSHポート
  LogLevel        DEBUG
  Tunnel          ethernet                         ★tap方式
  TunnelDevice    1:1
  RequestTTY      no
  PermitLocalCommand yes
  LocalCommand    /tmp/setup_tap1_client           ★ログイン成功後ローカルで実行するコマンドの定義
</pre>

<p>
AmazonEC2 <code>/tmp/setup_tap1_client</code>
</p>
<pre class="example">
#!/bin/sh

## tap1デバイスを活性化する
ip link set tap1 up

## tap1デバイスを br0 ブリッジに刺す
brctl addif br0 tap1

## 192.168.100.0/24 セグメントへのルート定義
ip route add 192.168.100.0/24 via 192.168.100.54 dev br0
</pre>

<p>
RaspberryPi <code>/root/.ssh/authorized_keys</code>
</p>
<pre class="example">
★rootユーザでログイン後 /root/.ssh/setup_tap1 を実行する定義
no-port-forwarding,no-agent-forwarding,no-X11-forwarding,command="/root/.ssh/setup_tap1" ssh-rsa xxxxxxxxx
</pre>

<p>
RaspberryPi <code>/root/.ssh/setup_tap1</code>
</p>
<pre class="example">
#!/bin/sh

## tap1デバイスにIPをアサインする
ifconfig tap1 192.168.100.54/29

## APR PROXY機能を有効にする
sysctl -w net.ipv4.ip_forward=1
sysctl -w net.ipv4.conf.eth0.proxy_arp=1
</pre>
</div>
</div>
</div>




<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">おまけに</h2>
<div class="outline-text-2" id="text-4">
<p>
今後機会があれば、TUNデバイス方式とTAPデバイス方式の性能を比較したいと思います。
TAP の方が Ethernetヘッダが付加されるため、TUNより通信量が多いいのでTUNの方がが
性能がいいかもしれない。但しTUN方式はPoint-To-Point通信であるため、BroadCastや
MultiCastが出来ない部分とネットワークセグメント間のパケット転送の設定（iptabels）
が面倒の部分もあります。
</p>
</div>
</div>




<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">参考リンク</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li><a href="http://www.komoto.org/vpn/index.html">VPN技術について</a>
</li>
<li><a href="http://www.unixuser.org/~euske/doc/openssh/book/chap6.html#real-vpn">入門OpenSSH - 第6章 すすんだ使い方</a>
</li>
<li><a href="http://www.usupi.org/sysad/248.html">SSH でVPNを実現する</a>
</li>
<li><a href="http://www.usupi.org/sysad/066.html">お試しネットワーク環境を作る ～ Proxy ARP 編</a>
</li>
<li><a href="http://web.mit.edu/rhel-doc/4/RH-DOCS/rhel-sg-ja-4/s1-firewall-ipt-fwd.html">Red Hat Enterprise Linux 4: セキュリティガイド</a>
</li>
<li><a href="https://access.redhat.com/site/documentation/ja-JP/Red_Hat_Enterprise_Linux/6/html/Security_Guide/sect-Security_Guide-Firewalls-FORWARD_and_NAT_Rules.html">FORWARD および NAT ルール</a>
</li>
</ul>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[メモ]リモートXの接続方法]]></title>
    <link href="http://luozengbin.github.io/blog/2014-06-21-%5B%E3%83%A1%E3%83%A2%5D%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%88x%E3%81%AE%E6%8E%A5%E7%B6%9A%E6%96%B9%E6%B3%95.html"/>
    <updated>2014-06-21T00:00:00+09:00</updated>
    <id>http://luozengbin.github.io/blog/[メモ]リモートxの接続方法</id>
    <content type="html"><![CDATA[<p>
リモートLinuxサーバでXアプリを利用するケースはしばしばあります。
実現方式について調べてみた。
</p>




<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="right">No</th>
<th scope="col" class="left">サーバ側</th>
<th scope="col" class="left">クライアント側</th>
<th scope="col" class="left">備考</th>
</tr>
</thead>
<tbody>
<tr>
<td class="right">1</td>
<td class="left">DISPLAY変数の指定</td>
<td class="left">xhostよりアクセス許可</td>
<td class="left">クライアント側6000番ポートの開放が必要</td>
</tr>

<tr>
<td class="right">2</td>
<td class="left">SSH X11 Forwarding</td>
<td class="left">ssh -X で接続する</td>
<td class="left">サーバ側：X11Forwarding yes が必要　</td>
</tr>

<tr>
<td class="right">3</td>
<td class="left">Xdmcp(udp:177)</td>
<td class="left">Xサーバとして動く</td>
<td class="left">Display Managerがエントリ画面になる</td>
</tr>

<tr>
<td class="right">4</td>
<td class="left">VNCサーバ(tcp:5901〜)</td>
<td class="left">VNCビューア</td>
<td class="left">よく使われる</td>
</tr>

<tr>
<td class="right">5</td>
<td class="left">XRDP</td>
<td class="left">XRDPクライアントソフト</td>
<td class="left">WindowsのRemote Desktop Procotol</td>
</tr>
</tbody>
</table>




<p>
VNCとXRDP以外のサーバとクライアントの役割
</p>


<ul class="org-ul">
<li>サーバ側:       Xアプリを動かす側
</li>
<li>クライアント側: Xサーバを動かす側
</li>
</ul>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">検証環境</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>クライアント: GDM経由でGnome3が動いているGUI環境
</li>
<li>サーバ: CUIモードLinux環境
</li>
</ul>

<pre class="example">
┏━━━━━━━┓      ┏━━━━━━━┓
┃ クライアント ┃      ┃   サーバ     ┃
┃  mimi-air    ┣━━━┫    pipi      ┃
┃192.168.100.13┃      ┃192.169.100.4 ┃
┗━━━━━━━┛      ┗━━━━━━━┛
</pre>

<p>
<!-- more -->
</p>
</div>
</div>




<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">xhostによるXアプリを起動する方式</h2>
<div class="outline-text-2" id="text-2">
<p>
通信イメージ
</p>
<pre class="example">
┏━━━━━━━━━━━━━━━━━┓        ┏━━━━━━━┓
┃    クライアント（Xサーバ）       ┃        ┃   サーバ     ┃
┃ Unixソケット                tcp  ┃        ┃   Xアプリ    ┃
┃ /tmp/.X11-unix/X0   &lt;----&gt;  6000 &lt;&lt;━━━━┫$DISPLAY      ┃
┗━━━━━━━━━━━━━━━━━┛        ┗━━━━━━━┛
</pre>

<p>
GDMパラメータにTCP接続許可の設定を行う。
</p>
<ul class="org-ul">
<li><code>/etc/gdm/custom.conf</code> に <code>DisallowTcp=false</code> を追加する。
</li>
<li><code>/usr/share/gdm/gdm.schemas</code> に <code>security/DisallowTCP</code> の値を <code>false</code> へ変更する。
</li>
</ul>

<p>
設定後、GDMを再起動して <code>netstat</code> コマンドで <code>6000</code> ポートがリスニング状態であること
を確認したうえで、 <code>xhost</code> コマンドでサーバからのアクセスを許可するようにする。
XサーバのTCP受け待ちポート番号は <code>6000+スクリン番号</code> 式で決まる。 Xサーバがスクリン１
で起動された場合TCP受け待ちポート番号が6001となります。通常は０番スクリーンが利用され
る。
</p>

<pre class="example">
[akira@mimi-air ~]$ sudo netstat -nutpl | grep 6000
tcp        0      0 0.0.0.0:6000            0.0.0.0:*               LISTEN      2115/Xorg
tcp6       0      0 :::6000                 :::*                    LISTEN      2115/Xorg

★アクセス許可
[akira@mimi-air ~]$ xhost + 192.168.100.4
192.168.100.4 being added to access control list

★アクセス許可リストの確認
[akira@mimi-air ~]$ xhost
access control enabled, only authorized clients can connect
INET:pipi
SI:localuser:akira
SI:localuser:gdm
SI:localuser:root
[akira@mimi-air ~]$
</pre>

<p>
サーバ側の <code>DISPLAY</code> 環境変数をクライアントをXサーバへ指すように変更する。
</p>
<pre class="example">
★環境変数設定
[akira@pipi ~]$ export DISPLAY=192.168.100.13:0.0

★環境変数確認
[akira@pipi ~]$ env | grep DISPLAY
DISPLAY=192.168.100.13:0.0

★Xアプリ起動して確認する
[akira@pipi ~]$ leafpad
</pre>
</div>
</div>




<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">SSH X11フォワード方式</h2>
<div class="outline-text-2" id="text-3">
<p>
通信イメージ
</p>
<pre class="example">
┏━━━━━━━━━━━━━━━━━┓        ┏━━━━━━━━━━━━━━━━━━━━━━┓
┃    クライアント（Xサーバ）       ┃        ┃      サーバ (Xアプリ)                      ┃
┃ Unixソケット                tcp  ┃ ssh -X ┃tcp                      Unixソケット       ┃
┃ /tmp/.X11-unix/X0   &lt;----&gt;  ssh  &lt;&lt;━━━━┫sshd &lt;---&gt; tcp:6010 &lt;--&gt; /tmp/.X11-unix/X10 ┃
┗━━━━━━━━━━━━━━━━━┛        ┗━━━━━━━━━━━━━━━━━━━━━━┛
</pre>

<p>
設定作業と接続手順
</p>
<ul class="org-ul">
<li>サーバ側のSSHにX11フォワードを許可するようにする。
</li>
<li>クライアントから <code>ssh -X</code> で接続する。
</li>
</ul>

<p>
クライアントからサーバに接続するに際にサーバサイトで以下の処理が実装される。
</p>
<ul class="org-ul">
<li>DISPLAY環境変数を <code>localhost:10.0</code> に設定する。
</li>
<li><code>xauth</code> コマンドで <code>~/.Xauthority</code> に認証用クッキーを追加する。
</li>
</ul>

<p>
<code>ssh -X</code> で接続時にエラーが起きた場合、 <code>-v</code> オプションでデバッグメッセージの出力を有
効にするとトラブルの原因究明に効果的かもしれない。
</p>

<pre class="example">
■サーバ側
------------------------------------------------------------

★サーバ側のX11Forwarding設定値を確認する
[akira@pipi ~]$ cat /etc/ssh/sshd_config | grep X11Forwarding
X11Forwarding yes
[akira@pipi ~]$ 

■クライアント側
------------------------------------------------------------
★-Xオプションつけてサーバへ接続する
[akira@mimi-air ~]$ ssh -X pipi
Last login: Sun Jun 22 08:58:59 2014 from 192.168.100.13

■サーバ側
------------------------------------------------------------
★DISPLAY環境変数の確認
[akira@pipi ~]$ env | grep DISPLAY
DISPLAY=localhost:10.0

★~/.Xauthorityに登録されたクッキーの確認
[akira@pipi ~]$ xauth list
pipi/unix:10  MIT-MAGIC-COOKIE-1  75af091faa9e151987efb8fb46c5e2d3

★6010ポートのリスリング状態の確認
[akira@pipi ~]$ sudo netstat -nutpl | grep 6010 
tcp        0      0 127.0.0.1:6010          0.0.0.0:*               LISTEN      9772/sshd: akira@pt 

★Xアプリを起動して見る
[akira@pipi ~]$ leafpad 
Xlib:  extension "RANDR" missing on display "localhost:10.0".
Gtk-Message: Failed to load module "canberra-gtk-module"
leafpad: can't save config file - /home/akira/.config/leafpad/leafpadrc
</pre>

<p>
サーバ側X11フォワードが有効でない、クライアントにて <code>ssh -X localhost</code> でX11のunixソケッ
トをTCPの6010ポートに変換する。クライアントからサーバへ接続時にローカルの6010ポートを
サーバ側にフォワードする方式もあります。この場合、サーバ側の <code>DISPLAY</code> 環境変数と
<code>~/.Xauthority</code> の認証クッキーの追加を手動で行う必要があります。
</p>

<p>
以下はその接続イメージです。
</p>
<pre class="example">
┏━━━━━━━━━━━━━━┓    ┏━━━━━━━━━━━━━━┓
┃    クライアント（Xサーバ） ┃    ┃     サーバ(Xアプリ)        ┃
┃ Unixソケット               ┃    ┃                            ┃
┃ /tmp/.X11-unix/X0          ┃    ┃        /tmp/.X11-unix/X10  ┃
┃     ↓                     ┃    ┃                ↑          ┃
┃  tcp:6010 &lt;-------&gt; ssh    ┣━━┫ sshd &lt;---&gt; localhost:6010  ┃
┗━━━━━━━━━━━━━━┛    ┗━━━━━━━━━━━━━━┛
</pre>

<p>
設定作業と接続手順
</p>
<ul class="org-ul">
<li>ローカルののSSHにX11フォワードを許可するようにする。
</li>
<li>クライアントにて <code>ssh -X localhost</code> で接続する。
</li>
<li><code>ssh -R 6010</code> でサーバへ接続する
</li>
<li>サーバ側の <code>DISPLAY</code> 環境変数を設定する
</li>
<li>サーバ側の <code>~/.Xauthority</code> 認証クッキーを追加する
</li>
</ul>

<pre class="example">
■クライアント側
------------------------------------------------------------
★クライアント側のssh設定の確認
[akira@mimi-air ~]$ cat /etc/ssh/sshd_config | grep X11Forwarding
X11Forwarding yes

★X11のUnixソケットをTCPへ変換する
[akira@mimi-air ~]$ ssh -X localhost
Last login: Sat Jun 21 13:10:45 2014 from localhost.localdomain

[akira@mimi-air ~]$ sudo netstat -nutpl | grep 6010
[sudo] password for akira: 
tcp        0      0 127.0.0.1:6010          0.0.0.0:*               LISTEN      18706/sshd: akira@p 
tcp6       0      0 ::1:6010                :::*                    LISTEN      18706/sshd: akira@p 

★sshポートフォワーディングしてサーバへ接続する
[akira@mimi-air ~]$ ssh -R 6010:localhost:6010 pipi
Last login: Sun Jun 22 09:52:34 2014 from 192.168.100.13

■サーバ側
------------------------------------------------------------
★ポートフォワーディング有効であることを確認する
[akira@pipi ~]$ sudo netstat -nutpl | grep 6010
tcp        0      0 127.0.0.1:6010          0.0.0.0:*               LISTEN      11106/sshd: akira@p 

★DISPLAY環境変数の指定
[akira@pipi ~]$ export DISPLAY=localhost:10.0

★Xアプリ起動失敗：X認証失敗が原因です
[akira@pipi ~]$ leafpad 
leafpad: Cannot open display: 

■クライアント側
------------------------------------------------------------
[akira@mimi-air ~]$ X11 connection rejected because of wrong authentication.

★X認証用クッキーを確認する
[akira@mimi-air ~]$ xauth list
mimi-air/unix:10  MIT-MAGIC-COOKIE-1  47ed008f47dc3eae07294ee49b26fb35
[akira@mimi-air ~]$ 

■サーバ側
------------------------------------------------------------
★既存のサーバサイトのX認証クッキーを削除する
[akira@pipi ~]$ xauth list
pipi/unix:10  MIT-MAGIC-COOKIE-1  75af091faa9e151987efb8fb46c5e2d3
[akira@pipi ~]$ xauth remove unix:10

★クライアント側登録されたX認証クッキーをサーバ側にも登録する
[akira@pipi ~]$ xauth add unix:10 MIT-MAGIC-COOKIE-1  47ed008f47dc3eae07294ee49b26fb35

★Xアプリ起動成功
[akira@pipi ~]$ leafpad 
Xlib:  extension "RANDR" missing on display "localhost:10.0".
Gtk-Message: Failed to load module "canberra-gtk-module"
leafpad: can't save config file - /home/akira/.config/leafpad/leafpadrc
[akira@pipi ~]$
</pre>
</div>
</div>




<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">VNC方式</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li><a href="https://wiki.archlinux.org/index.php/Vncserver_%2528%25E6%2597%25A5%25E6%259C%25AC%25E8%25AA%259E%2529">Archlinux Wiki: Vncserver (日本語)</a>
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">ローカルで異なるユーザでXアプリの起動</h2>
<div class="outline-text-2" id="text-5">
<p>
以下のようにコンソールからローカルの環境の別ユーザでXアプリを起動しようとするとエラー
になります。
</p>

<pre class="example">
★sudo -u で試す
[akira@mimi-air ~]$ sudo -u milan leafpad 
[sudo] password for akira: 
No protocol specified
leafpad: ディスプレイをオープンできません: 

★suでユーザ切り替えたから試す
[akira@mimi-air ~]$ su - milan
パスワード:
[milan@mimi-air ~]$ leafpad 
leafpad: ディスプレイをオープンできません: 
[milan@mimi-air ~]$
</pre>

<p>
次の手順で設定すれば、普通に起動出来ます。
</p>
<ul class="org-ul">
<li><code>DISPLAY</code> 環境変数の指定
</li>
<li><code>xauth</code> でX認証クッキーの登録
</li>
</ul>

<pre class="example">
[akira@mimi-air ~]$ su - milan
パスワード:
[milan@mimi-air ~]$ export DISPLAY=:0
[milan@mimi-air ~]$ xauth list
[milan@mimi-air ~]$ xauth add unix:0 MIT-MAGIC-COOKIE-1  75de7d9075e9582838e38aad909df062
[milan@mimi-air ~]$ leafpad 
[milan@mimi-air ~]$
</pre>
</div>
</div>




<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">参考サイト</h2>
<div class="outline-text-2" id="text-6">
<ul class="org-ul">
<li><a href="http://vega.sra-tohoku.co.jp/~kabe/vsd/ssh-x.html">最近の豪華なX11環境でsshを使ってＸプロトコルを中継する</a>
</li>
<li><a href="http://www.ibm.com/developerworks/jp/linux/tutorials/l-basics/">Linux ビギナーのための基本タスク</a>
</li>
</ul>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[検証]firewalldを遊んでみた]]></title>
    <link href="http://luozengbin.github.io/blog/2014-06-16-%5B%E6%A4%9C%E8%A8%BC%5Dfirewalld%E3%82%92%E9%81%8A%E3%82%93%E3%81%A7%E3%81%BF%E3%81%9F.html"/>
    <updated>2014-06-16T00:00:00+09:00</updated>
    <id>http://luozengbin.github.io/blog/[検証]firewalldを遊んでみた</id>
    <content type="html"><![CDATA[<p>
自宅の <code>Raspberry Pi</code> にfirewalldを入れて遊んで見ました。
</p>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">firewalld情報収集から始まる</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>iptablesが土台となります、firewalldの設定はipatbles設定へ変換される
</li>
<li>D-BUSのAPI経由でアプリケーションから制御が可能
</li>
<li>受送信ルールはゾーンファイルにて定義する
</li>
<li>受送信サービスタイプ（サービス名＋ポートより識別する）による通信制限が可能
</li>
<li>受送信ICMPタイプによる通信制限が可能
</li>
<li>通信元のIPサブネットによる通信制限が可能
</li>
<li>NICポートごとにゾーンファイルを適用することが可能
（複数同時適用可能かは未検証）
</li>
</ul>

<p>
<!-- more -->
</p>
</div>
</div>




<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">検証環境</h2>
<div class="outline-text-2" id="text-2">
<ul class="org-ul">
<li>Archlinux : <a href="https://www.archlinux.org/">https://www.archlinux.org/</a>
</li>
<li>firewalld-0.3.10-1 : <a href="https://www.archlinux.org/packages/community/any/firewalld/">https://www.archlinux.org/packages/community/any/firewalld/</a>
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">firewalldのパッケージ構成</h2>
<div class="outline-text-2" id="text-3">
<pre class="example">
/etc/
/etc/conf.d/
/etc/conf.d/firewalld           ★firewalldサービス起動パラメータの定義
/etc/dbus-1/
/etc/dbus-1/system.d/
/etc/dbus-1/system.d/FirewallD.conf
/etc/firewalld/
/etc/firewalld/firewalld.conf
/etc/firewalld/icmptypes/      ★独自ICMPタイプの定義はここに追加
/etc/firewalld/lockdown-whitelist.xml
/etc/firewalld/services/       ★独自サービス定義はここに追加
/etc/firewalld/zones/          ★独自のゾーンファイルはここに追加
/etc/xdg/
/etc/xdg/autostart/
/etc/xdg/autostart/firewall-applet.desktop
/usr/
/usr/bin/
/usr/bin/firewall-applet       ★GUIツール
/usr/bin/firewall-cmd
/usr/bin/firewall-config
/usr/bin/firewall-offline-cmd
/usr/bin/firewalld
/usr/lib/
/usr/lib/firewalld/
/usr/lib/firewalld/icmptypes/  ★ICMPタイプの定義
/usr/lib/firewalld/icmptypes/destination-unreachable.xml
/usr/lib/firewalld/icmptypes/echo-reply.xml
/usr/lib/firewalld/icmptypes/echo-request.xml
/usr/lib/firewalld/icmptypes/parameter-problem.xml
/usr/lib/firewalld/icmptypes/redirect.xml
/usr/lib/firewalld/icmptypes/router-advertisement.xml
/usr/lib/firewalld/icmptypes/router-solicitation.xml
/usr/lib/firewalld/icmptypes/source-quench.xml
/usr/lib/firewalld/icmptypes/time-exceeded.xml
/usr/lib/firewalld/services/  ★サービス定義
/usr/lib/firewalld/services/amanda-client.xml
/usr/lib/firewalld/services/amanda-k5-client.xml
/usr/lib/firewalld/services/bacula-client.xml
/usr/lib/firewalld/services/bacula.xml
/usr/lib/firewalld/services/dhcp.xml
/usr/lib/firewalld/services/dhcpv6-client.xml
/usr/lib/firewalld/services/dhcpv6.xml
/usr/lib/firewalld/services/dns.xml
/usr/lib/firewalld/services/freeipa-ldap.xml
/usr/lib/firewalld/services/freeipa-ldaps.xml
/usr/lib/firewalld/services/freeipa-replication.xml
/usr/lib/firewalld/services/ftp.xml
/usr/lib/firewalld/services/high-availability.xml
/usr/lib/firewalld/services/http.xml
/usr/lib/firewalld/services/https.xml
/usr/lib/firewalld/services/imaps.xml
/usr/lib/firewalld/services/ipp-client.xml
/usr/lib/firewalld/services/ipp.xml
/usr/lib/firewalld/services/ipsec.xml
/usr/lib/firewalld/services/kerberos.xml
/usr/lib/firewalld/services/kpasswd.xml
/usr/lib/firewalld/services/ldap.xml
/usr/lib/firewalld/services/ldaps.xml
/usr/lib/firewalld/services/libvirt-tls.xml
/usr/lib/firewalld/services/libvirt.xml
/usr/lib/firewalld/services/mdns.xml
/usr/lib/firewalld/services/mountd.xml
/usr/lib/firewalld/services/ms-wbt.xml
/usr/lib/firewalld/services/mysql.xml
/usr/lib/firewalld/services/nfs.xml
/usr/lib/firewalld/services/ntp.xml
/usr/lib/firewalld/services/openvpn.xml
/usr/lib/firewalld/services/pmcd.xml
/usr/lib/firewalld/services/pmproxy.xml
/usr/lib/firewalld/services/pmwebapi.xml
/usr/lib/firewalld/services/pmwebapis.xml
/usr/lib/firewalld/services/pop3s.xml
/usr/lib/firewalld/services/postgresql.xml
/usr/lib/firewalld/services/privoxy.xml
/usr/lib/firewalld/services/proxy-dhcp.xml
/usr/lib/firewalld/services/puppetmaster.xml
/usr/lib/firewalld/services/radius.xml
/usr/lib/firewalld/services/rpc-bind.xml
/usr/lib/firewalld/services/samba-client.xml
/usr/lib/firewalld/services/samba.xml
/usr/lib/firewalld/services/sane.xml
/usr/lib/firewalld/services/smtp.xml
/usr/lib/firewalld/services/ssh.xml
/usr/lib/firewalld/services/synergy.xml
/usr/lib/firewalld/services/telnet.xml
/usr/lib/firewalld/services/tftp-client.xml
/usr/lib/firewalld/services/tftp.xml
/usr/lib/firewalld/services/tor-socks.xml
/usr/lib/firewalld/services/transmission-client.xml
/usr/lib/firewalld/services/vnc-server.xml
/usr/lib/firewalld/services/wbem-https.xml
/usr/lib/firewalld/services/xmpp-bosh.xml
/usr/lib/firewalld/services/xmpp-client.xml
/usr/lib/firewalld/services/xmpp-local.xml
/usr/lib/firewalld/services/xmpp-server.xml
/usr/lib/firewalld/zones/                          ★デフォルトで用意されたゾーンの定義ファイル
/usr/lib/firewalld/zones/block.xml
/usr/lib/firewalld/zones/dmz.xml
/usr/lib/firewalld/zones/drop.xml
/usr/lib/firewalld/zones/external.xml
/usr/lib/firewalld/zones/home.xml
/usr/lib/firewalld/zones/internal.xml
/usr/lib/firewalld/zones/public.xml                ★デフォルトはこちらのゾーンが適用される
/usr/lib/firewalld/zones/trusted.xml
/usr/lib/firewalld/zones/work.xml
/usr/lib/python3.4/
/usr/lib/python3.4/site-packages/
/usr/lib/python3.4/site-packages/firewall/
/usr/lib/python3.4/site-packages/firewall/__init__.py
/usr/lib/python3.4/site-packages/firewall/client.py
/usr/lib/python3.4/site-packages/firewall/config/
/usr/lib/python3.4/site-packages/firewall/config/__init__.py
/usr/lib/python3.4/site-packages/firewall/config/dbus.py
/usr/lib/python3.4/site-packages/firewall/core/
/usr/lib/python3.4/site-packages/firewall/core/__init__.py
/usr/lib/python3.4/site-packages/firewall/core/base.py
/usr/lib/python3.4/site-packages/firewall/core/ebtables.py
/usr/lib/python3.4/site-packages/firewall/core/fw.py
/usr/lib/python3.4/site-packages/firewall/core/fw_config.py
/usr/lib/python3.4/site-packages/firewall/core/fw_direct.py
/usr/lib/python3.4/site-packages/firewall/core/fw_icmptype.py
/usr/lib/python3.4/site-packages/firewall/core/fw_policies.py
/usr/lib/python3.4/site-packages/firewall/core/fw_service.py
/usr/lib/python3.4/site-packages/firewall/core/fw_test.py
/usr/lib/python3.4/site-packages/firewall/core/fw_zone.py
/usr/lib/python3.4/site-packages/firewall/core/io/
/usr/lib/python3.4/site-packages/firewall/core/io/__init__.py
/usr/lib/python3.4/site-packages/firewall/core/io/direct.py
/usr/lib/python3.4/site-packages/firewall/core/io/firewalld_conf.py
/usr/lib/python3.4/site-packages/firewall/core/io/icmptype.py
/usr/lib/python3.4/site-packages/firewall/core/io/io_object.py
/usr/lib/python3.4/site-packages/firewall/core/io/lockdown_whitelist.py
/usr/lib/python3.4/site-packages/firewall/core/io/service.py
/usr/lib/python3.4/site-packages/firewall/core/io/zone.py
/usr/lib/python3.4/site-packages/firewall/core/ipXtables.py
/usr/lib/python3.4/site-packages/firewall/core/logger.py
/usr/lib/python3.4/site-packages/firewall/core/modules.py
/usr/lib/python3.4/site-packages/firewall/core/prog.py
/usr/lib/python3.4/site-packages/firewall/core/rich.py
/usr/lib/python3.4/site-packages/firewall/core/watcher.py
/usr/lib/python3.4/site-packages/firewall/dbus_utils.py
/usr/lib/python3.4/site-packages/firewall/errors.py
/usr/lib/python3.4/site-packages/firewall/functions.py
/usr/lib/python3.4/site-packages/firewall/fw_types.py
/usr/lib/python3.4/site-packages/firewall/server/
/usr/lib/python3.4/site-packages/firewall/server/__init__.py
/usr/lib/python3.4/site-packages/firewall/server/config.py
/usr/lib/python3.4/site-packages/firewall/server/config_icmptype.py
/usr/lib/python3.4/site-packages/firewall/server/config_service.py
/usr/lib/python3.4/site-packages/firewall/server/config_zone.py
/usr/lib/python3.4/site-packages/firewall/server/decorators.py
/usr/lib/python3.4/site-packages/firewall/server/firewalld.py
/usr/lib/python3.4/site-packages/firewall/server/server.py
/usr/lib/systemd/
/usr/lib/systemd/system/
/usr/lib/systemd/system/firewalld.service     ★systemdサービス定義ファイル
/usr/share/
/usr/share/appdata/
/usr/share/appdata/firewall-config.appdata.xml
/usr/share/applications/
/usr/share/applications/firewall-config.desktop
/usr/share/bash-completion/
/usr/share/bash-completion/completions/
/usr/share/bash-completion/completions/firewall-cmd
/usr/share/firewalld/
/usr/share/firewalld/firewall-config.glade
/usr/share/firewalld/gtk3_chooserbutton.py
/usr/share/glib-2.0/
/usr/share/glib-2.0/schemas/
/usr/share/glib-2.0/schemas/org.fedoraproject.FirewallApplet.gschema.xml
/usr/share/glib-2.0/schemas/org.fedoraproject.FirewallConfig.gschema.xml
/usr/share/icons/(★iconディレクトリ配下は省略)
/usr/share/locale/(★localeディレクトリ配下は省略)
/usr/share/man/
/usr/share/man/man1/
/usr/share/man/man1/firewall-applet.1.gz
/usr/share/man/man1/firewall-cmd.1.gz
/usr/share/man/man1/firewall-config.1.gz
/usr/share/man/man1/firewall-offline-cmd.1.gz
/usr/share/man/man1/firewalld.1.gz
/usr/share/man/man5/
/usr/share/man/man5/firewalld.conf.5.gz
/usr/share/man/man5/firewalld.dbus.5.gz
/usr/share/man/man5/firewalld.direct.5.gz
/usr/share/man/man5/firewalld.icmptype.5.gz
/usr/share/man/man5/firewalld.lockdown-whitelist.5.gz
/usr/share/man/man5/firewalld.richlanguage.5.gz
/usr/share/man/man5/firewalld.service.5.gz
/usr/share/man/man5/firewalld.zone.5.gz
/usr/share/man/man5/firewalld.zones.5.gz
/usr/share/polkit-1/
/usr/share/polkit-1/actions/
/usr/share/polkit-1/actions/org.fedoraproject.FirewallD1.desktop.policy
/usr/share/polkit-1/actions/org.fedoraproject.FirewallD1.policy
/usr/share/polkit-1/actions/org.fedoraproject.FirewallD1.server.policy
</pre>
</div>
</div>


<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">定義ファイルの見本</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">publicゾーン定義ファイル</h3>
<div class="outline-text-3" id="text-4-1">
<pre class="example">
[akira@pipi ~]$ cat /usr/lib/firewalld/zones/public.xml 
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;zone&gt;
  &lt;short&gt;Public&lt;/short&gt;
  &lt;description&gt;For use in public areas. You do not trust the other computers on networks to not harm your computer. Only selected incoming connections are accepted.&lt;/description&gt;
  &lt;service name="ssh"/&gt;
  &lt;service name="dhcpv6-client"/&gt;
&lt;/zone&gt;
[akira@pipi ~]$
</pre>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">SSHサービス定義ファイル</h3>
<div class="outline-text-3" id="text-4-2">
<p>
プロトコール名とポート番号で識別する。
</p>
<pre class="example">
[akira@pipi ~]$ cat /usr/lib/firewalld/services/ssh.xml 
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;service&gt;
  &lt;short&gt;SSH&lt;/short&gt;
  &lt;description&gt;Secure Shell (SSH) is a protocol for logging into and executing commands on remote machines. It provides secure encrypted communications. If you plan on accessing your machine remotely via SSH over a firewalled interface, enable this option. You need the openssh-server package installed for this option to be useful.&lt;/description&gt;
  &lt;port protocol="tcp" port="22"/&gt;
&lt;/service&gt;
[akira@pipi ~]$
</pre>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">ICMPタイプ定義ファイル</h3>
<div class="outline-text-3" id="text-4-3">
<p>
shortタグのICMPタイプ名で識別する。使用可能なタイプ名は <code>iptables -p icmp -h</code> で確認
できる。
</p>
<pre class="example">
[akira@pipi ~]$ cat /usr/lib/firewalld/icmptypes/destination-unreachable.xml 
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;icmptype&gt;
  &lt;short&gt;Destination Unreachable&lt;/short&gt;
  &lt;description&gt;This error message is generated by a host or gateway if the destination is not reachable.&lt;/description&gt;
&lt;/icmptype&gt;

★使用可能なICMPタイプ名の確認
[akira@pipi ~]$ iptables -p icmp -h
--省略--
Valid ICMP Types:
any
echo-reply (pong)
destination-unreachable
   network-unreachable
   host-unreachable
   protocol-unreachable
   port-unreachable
   fragmentation-needed
   source-route-failed
   network-unknown
   host-unknown
   network-prohibited
   host-prohibited
   TOS-network-unreachable
   TOS-host-unreachable
   communication-prohibited
   host-precedence-violation
   precedence-cutoff
source-quench
redirect
   network-redirect
   host-redirect
   TOS-network-redirect
   TOS-host-redirect
echo-request (ping)
router-advertisement
router-solicitation
time-exceeded (ttl-exceeded)
   ttl-zero-during-transit
   ttl-zero-during-reassembly
parameter-problem
   ip-header-bad
   required-option-missing
timestamp-request
timestamp-reply
address-mask-request
address-mask-reply
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">firewalldコマンドインタフェース</h2>
<div class="outline-text-2" id="text-5">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">firewall-cmd</td>
<td class="left">&#x2013;reload</td>
<td class="left">定義の変更を反映する</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;complete-reload</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;state</td>
<td class="left">ステータスの確認</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;list-all-zones</td>
<td class="left">ゾーン設定の確認</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;get-services</td>
<td class="left">定義済みサービス一覧の取得</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;get-icmptypes</td>
<td class="left">定義済みICMP応答一覧の取得</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;get-default-zone</td>
<td class="left">デフォルトゾーンの確認</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;set-default-zone=&lt;ゾーン名&gt;</td>
<td class="left">デフォルトゾーンの変更</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;remove-interface=&lt;nic名&gt;</td>
<td class="left">対象nicの適用ゾーンを除去</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">★サービスの許可設定</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;list-services &#x2013;zone=&lt;ゾーン名&gt;</td>
<td class="left">対象ゾーンに許可されたサービス</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;query-service=&lt;サービス名&gt; &#x2013;zone=&lt;ゾーン名&gt;</td>
<td class="left">指定のサービスが許可されているか確認</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;add-service=&lt;サービス名&gt; &#x2013;zone=&lt;ゾーン名&gt;</td>
<td class="left">許可するサービスを追加</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;remove-service=&lt;サービス名&gt; &#x2013;zone=&lt;ゾーン名&gt;</td>
<td class="left">許可するサービスを削除</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">★ICMPタイプの拒否設定</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;list-icmp-blocks &#x2013;zone=&lt;ゾーン名&gt;</td>
<td class="left">禁止されているICMPタイプを表示</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;query-icmp-block=&lt;ICMPタイプ名&gt; &#x2013;zone=&lt;ゾーン名&gt;</td>
<td class="left">ICMPタイプが禁止されているか確認</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;add-icmp-block=&lt;ICMPタイプ名&gt; &#x2013;zone=&lt;ゾーン名&gt;</td>
<td class="left">拒否するICMPタイプの追加</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;remove-icmp-block=&lt;ICMPタイプ名&gt; &#x2013;zone=&lt;ゾーン名&gt;</td>
<td class="left">拒否するICMPタイプの除外</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">★IPマスカレードのOn/Off設定</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;query-masquerade &#x2013;zone=&lt;ゾーン名&gt;</td>
<td class="left">現在の設定を確認</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;add-masquerade &#x2013;zone=&lt;ゾーン名&gt;</td>
<td class="left">IPマスカレードを有効化</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;remove-masquerade &#x2013;zone=&lt;ゾーン名&gt;</td>
<td class="left">IPマスカレードを無効化</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">★nicに適用する</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;add-interface=&lt;nic名&gt; &#x2013;zone=&lt;ゾーン名&gt;</td>
<td class="left">対象nicにゾーンを適用</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;remove-interface=eth1</td>
<td class="left">適用ゾーンを除去</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;list-interfaces &#x2013;zone=&lt;ゾーン名&gt;</td>
<td class="left">ゾーンが適用されるNICポートを表示</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;change-interface=&lt;nic名&gt; &#x2013;zone=&lt;ゾーン名&gt;</td>
<td class="left">nicに適用するゾーンを変更する</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;query-interface=interface=h1</td>
<td class="left">nicに対象ゾーンが適用されたかの確認</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">★通信元のIPサブネットによる通信制限</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;list-sources &#x2013;zone=&lt;ゾーン&gt;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;get-zone-of-source=&lt;サブネット&gt;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;query-source=&lt;サブネット&gt;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;add-source=&lt;サブネット&gt; &#x2013;zone=&lt;ゾーン&gt;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;change-source=&lt;サブネット&gt; &#x2013;zone=&lt;ゾーン&gt;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;remove-source=&lt;サブネット&gt;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">★システム保守時役立つコマンド</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;panic-on</td>
<td class="left">すべてのネットワーク通信が遮断する</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#x2013;panic-off</td>
<td class="left">パニックモードを止める</td>
</tr>
</tbody>
</table>
</div>
</div>




<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">インストールとサービスの有効化</h2>
<div class="outline-text-2" id="text-6">
<p>
<code>pacman</code> コマンドでインストール
</p>
<pre class="example">
[akira@pipi ~]$ sudo pacman -S firewalld 
依存関係を解決しています...
相互衝突をチェックしています...

パッケージ (1): firewalld-0.3.10-1

Total Installed Size:   2.64 MiB

:: インストールを行いますか？ [Y/n] 
(1/1) キーリングのキーを確認                                                                                                 [############################################################################] 100%
(1/1) パッケージの整合性をチェック                                                                                           [############################################################################] 100%
(1/1) パッケージファイルのロード                                                                                             [############################################################################] 100%
(1/1) ファイルの衝突をチェック                                                                                               [############################################################################] 100%
(1/1) 空き容量を確認                                                                                                         [############################################################################] 100%
(1/1) インストール firewalld                                                                                                 [############################################################################] 100%
[akira@pipi ~]$
</pre>

<p>
<code>systemctl</code> コマンドでサービスの有効化、起動
</p>
<pre class="example">
★サービスの有効化
[akira@pipi ~]$ sudo systemctl enable firewalld.service
[sudo] password for akira: 
ln -s '/usr/lib/systemd/system/firewalld.service' '/etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service'
ln -s '/usr/lib/systemd/system/firewalld.service' '/etc/systemd/system/basic.target.wants/firewalld.service'

★サービスの起動
[akira@pipi ~]$ sudo systemctl start firewalld.service

★サービス起動時のログ
[akira@pipi ~]$ sudo tail -f /var/log/everything.log
Jun 16 10:15:29 pipi systemd[1]: Starting firewalld - dynamic firewall daemon...
Jun 16 10:15:29 pipi systemd[1]: Failed to reset devices.list on /system.slice: Invalid argument
                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Jun 16 10:15:31 pipi kernel: [ 6372.219681] nf_conntrack version 0.5.0 (16384 buckets, 65536 max)
Jun 16 10:15:31 pipi kernel: [ 6372.360695] ip6_tables: (C) 2000-2006 Netfilter Core Team
Jun 16 10:15:31 pipi kernel: [ 6372.486263] Ebtables v2.0 registered
Jun 16 10:15:31 pipi kernel: [ 6372.504222] Bridge firewalling registered
Jun 16 10:15:32 pipi systemd[1]: Started firewalld - dynamic firewall daemon.

★サービスステータスの確認
[akira@pipi ~]$ sudo systemctl status firewalld.service
● firewalld.service - firewalld - dynamic firewall daemon
   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; enabled)
   Active: active (running) since 月 2014-06-16 10:15:32 JST; 3min 22s ago
 Main PID: 8679 (firewalld)
   CGroup: /system.slice/firewalld.service
           └─8679 /usr/bin/python -Es /usr/bin/firewalld --nofork --nopid

 6月 16 10:15:32 pipi systemd[1]: Started firewalld - dynamic firewall daemon.
[akira@pipi ~]$ firewall-cmd --state
</pre>

<p>
<code>/usr/lib/systemd/system/firewalld.service</code> サービス起動ファイルの中身
</p>
<pre class="example">
[Unit]
Description=firewalld - dynamic firewall daemon
Before=network.target
Before=libvirtd.service
Before=NetworkManager.service
Conflicts=iptables.service ip6tables.service ebtables.service  ★iptables, ebtablesサービスとのコンフリクト定義

[Service]
EnvironmentFile=-/etc/conf.d/firewalld                         ★起動パラメータファイル
ExecStart=/usr/bin/firewalld --nofork --nopid $FIREWALLD_ARGS  ★起動コマンド
ExecReload=/bin/kill -HUP $MAINPID                             ★停止コマンド
# supress to log debug and error output also to /var/log/messages
StandardOutput=null
StandardError=null
Type=dbus
BusName=org.fedoraproject.FirewallD1

[Install]
WantedBy=basic.target
Alias=dbus-org.fedoraproject.FirewallD1.service
</pre>
</div>
</div>




<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">pingをブロックしてみた</h2>
<div class="outline-text-2" id="text-7">
<p>
<code>public</code> ゾーンデフォルト状態ではすべてのICMPタイプを許可する。ここではpingをブロック
するようにしてみた。
</p>
<pre class="example">
★echo-requestをブロックする
[akira@pipi ~]$ sudo firewall-cmd --add-icmp-block=echo-request --zone=public
success
★設定の確認
[akira@pipi ~]$ sudo firewall-cmd --list-icmp-blocks --zone=public
echo-request

★iptablesにて設定を確認する
[akira@pipi ~]$ sudo iptables-save
~~省略~~
-A IN_public_deny -p icmp -m icmp --icmp-type 8 -j REJECT --reject-with icmp-host-prohibited ★タイプコードが8のicmpパケットを拒否するようにする
COMMIT
# Completed on Mon Jun 16 11:13:17 2014
</pre>

<p>
windows端末から確認して見る、見事にブロックができた。
</p>
<pre class="example">
C:\Users\akira&gt;ping 192.168.100.4

192.168.100.4 に ping を送信しています 32 バイトのデータ:
192.168.100.4 からの応答: 宛先ホストに到達できません。
192.168.100.4 からの応答: 宛先ホストに到達できません。
192.168.100.4 からの応答: 宛先ホストに到達できません。
192.168.100.4 からの応答: 宛先ホストに到達できません。

192.168.100.4 の ping 統計:
    パケット数: 送信 = 4、受信 = 4、損失 = 0 (0% の損失)、

C:\Users\akira&gt;
</pre>
</div>
</div>




<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">sambaサービスを許可してみた</h2>
<div class="outline-text-2" id="text-8">
<pre class="example">
[akira@pipi ~]$ sudo firewall-cmd --add-service=samba --zone=public
success
[akira@pipi ~]$ sudo iptables-save
~~省略~~~
-A IN_public_allow -p udp -m udp --dport 137 -m conntrack --ctstate NEW -j ACCEPT
-A IN_public_allow -p udp -m udp --dport 138 -m conntrack --ctstate NEW -j ACCEPT
-A IN_public_allow -p tcp -m tcp --dport 139 -m conntrack --ctstate NEW -j ACCEPT
-A IN_public_allow -p tcp -m tcp --dport 445 -m conntrack --ctstate NEW -j ACCEPT
~~省略~~~
</pre>
</div>
</div>




<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">独自ルールで通信履歴をロギングしてみた</h2>
<div class="outline-text-2" id="text-9">
<p>
<code>Rich Language</code> を用いて、特定のクライアントからhttpサービスを利用時にロギングする。
</p>
<pre class="example">
★ルール追加
[akira@pipi ~]$ sudo firewall-cmd --add-rich-rule='rule family="ipv4" source address="192.168.100.3" port port="80" protocol="tcp" log prefix="http connection" level="info" accept' --zone=pipi
success

★iptablesの確認
[akira@pipi ~]$ sudo iptables-save
# Generated by iptables-save v1.4.21 on Mon Jun 16 13:54:04 2014
~~省略~~
-A IN_pipi_log -s 192.168.100.3/32 -p tcp -m tcp --dport 80 -m conntrack --ctstate NEW -j LOG --log-prefix "http connection" --log-level 6
COMMIT

★Apacheサーバの起動
[akira@pipi ~]$ sudo systemctl start httpd

★ログ確認
[akira@pipi ~]$ sudo tail -f /var/log/everything.log
Jun 16 14:12:25 pipi systemd[1]: Starting Apache Web Server...
Jun 16 14:12:26 pipi systemd[1]: PID file /run/httpd/httpd.pid not readable (yet?) after start.
Jun 16 14:12:26 pipi systemd[1]: Started Apache Web Server.
Jun 16 14:13:00 pipi kernel: [ 2076.795011] http connectionIN=eth0 OUT= MAC=8c:89:a5:45:1d:ef:00:21:85:a9:65:7b:08:00 SRC=192.168.100.3 DST=192.168.100.4 LEN=52 TOS=0x00 PREC=0x00 TTL=128 ID=28405 DF PROTO=TCP SPT=53049 DPT=80 WINDOW=8192 RES=0x00 SYN URGP=0 
Jun 16 14:13:44 pipi kernel: [ 2120.509739] http connectionIN=eth0 OUT= MAC=8c:89:a5:45:1d:ef:00:21:85:a9:65:7b:08:00 SRC=192.168.100.3 DST=192.168.100.4 LEN=52 TOS=0x00 PREC=0x00 TTL=128 ID=28755 DF PROTO=TCP SPT=53059 DPT=80 WINDOW=8192 RES=0x00 SYN URGP=
</pre>
</div>
</div>




<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10">独自のゾーンファイルにしてみた</h2>
<div class="outline-text-2" id="text-10">
<p>
<code>/etc/firewalld/zones/</code> 配下に独自のゾーンファイルを作成する。
</p>
<pre class="example">
[akira@pipi ~]$ sudo touch /etc/firewalld/zones/pipi.xml
[akira@pipi ~]$ cat /etc/firewalld/zones/pipi.xml
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;zone&gt;
  &lt;short&gt;Pipi&lt;/short&gt;
  &lt;description&gt;For use in pipi areas.&lt;/description&gt;
  &lt;service name="ssh"/&gt;
  &lt;service name="samba"/&gt;
  &lt;!-- &lt;service name="samba-client"/&gt; --&gt;
  &lt;service name="dhcpv6-client"/&gt;
&lt;/zone&gt;
[akira@pipi ~]$
</pre>

<p>
<code>/etc/firewalld/firewalld.conf</code> ファイルにDefaultZoneを独自ゾーン名(ファイル名)に変更える。
</p>
<pre class="example">
# firewalld config file

# default zone
# The default zone used if an empty zone string is used.
# Default: public
DefaultZone=pipi  ★ここです
~~省略~~
</pre>

<p>
サービスを再起動する
</p>
<pre class="example">
[akira@pipi ~]$ sudo systemctl stop firewalld   ★サービス停止
[akira@pipi ~]$ sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         
[akira@pipi ~]$ sudo systemctl start firewalld  ★サービス起動
[akira@pipi ~]$ sudo iptables-save 
~~省略~~
-A IN_pipi -j IN_pipi_allow
-A IN_pipi_allow -p tcp -m tcp --dport 22 -m conntrack --ctstate NEW -j ACCEPT
-A IN_pipi_allow -p udp -m udp --dport 137 -m conntrack --ctstate NEW -j ACCEPT
-A IN_pipi_allow -p udp -m udp --dport 138 -m conntrack --ctstate NEW -j ACCEPT
-A IN_pipi_allow -p tcp -m tcp --dport 139 -m conntrack --ctstate NEW -j ACCEPT
-A IN_pipi_allow -p tcp -m tcp --dport 445 -m conntrack --ctstate NEW -j ACCEPT
COMMIT
# Completed on Mon Jun 16 13:31:04 2014
[akira@pipi ~]$
</pre>

<p>
<code>firewall-cmd --permanent</code> を用いて、pingのブロック設定を永続化させる。
</p>
<pre class="example">
[akira@pipi ~]$ sudo firewall-cmd --permanent --zone=pipi --add-icmp-block=echo-request
success
[akira@pipi ~]$ sudo systemctl restart firewalld
★ icmp-blockタグが自動的にゾーン定義ファイルに反映される。
[akira@pipi ~]$ sudo cat /etc/firewalld/zones/pipi.xml
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;zone&gt;
  &lt;short&gt;Pipi&lt;/short&gt;
  &lt;description&gt;For use in pipi areas.&lt;/description&gt;
  &lt;service name="ssh"/&gt;
  &lt;service name="dhcpv6-client"/&gt;
  &lt;service name="samba"/&gt;
  &lt;icmp-block name="echo-request"/&gt;
&lt;/zone&gt;
[akira@pipi ~]$
</pre>
</div>
</div>




<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11">NICポートにゾーンの適用</h2>
<div class="outline-text-2" id="text-11">
<p>
起動した状態で <code>--remove-interface</code> で適用ゾーンをクリアしようとすると
<code>UNKNOWN_INTERFACE</code> で怒られた。一度 <code>--add-interface</code> してから使えるようになる。
</p>
<pre class="example">
[akira@hakusai ~]$ sudo firewall-cmd --remove-interface=eth0
Error: UNKNOWN_INTERFACE: eth0
[akira@hakusai ~]$ sudo firewall-cmd --add-interface=eth0 --zone=home
success
[akira@hakusai ~]$ sudo firewall-cmd --remove-interface=eth0
</pre>
</div>
</div>




<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12">GUIツールを使って見た</h2>
<div class="outline-text-2" id="text-12">
<p>
firewalldのGUIインタフェースツール <code>/usr/bin/firewall-applet</code> として提供されている。
<code>/etc/xdg/autostart/firewall-applet.desktop</code> がインストルされた場合、OSがGUIモードで
起動するとfirewall-appletが自動起動される。システムトレイにアイコンが表示される。
<img src="img/firewalld-applet-01.png" alt="firewalld-applet-01.png" />
</p>

<p>
ゾーン設定変種画面
<img src="img/firewalld-applet-02.png" alt="firewalld-applet-02.png" />
</p>
<p>
サービス定義画面
<img src="img/firewalld-applet-03.png" alt="firewalld-applet-03.png" />
</p>
</div>
</div>




<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13">参考した資料</h2>
<div class="outline-text-2" id="text-13">
<p>
Linux女子部　firewalld徹底入門！
<a href="http://www.slideshare.net/enakai/firewalld-study-v10">http://www.slideshare.net/enakai/firewalld-study-v10</a>
</p>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[検証]SMTPプロトコール監視してみた]]></title>
    <link href="http://luozengbin.github.io/blog/2014-06-13-%5B%E6%A4%9C%E8%A8%BC%5Dsmtp%E3%83%97%E3%83%AD%E3%83%88%E3%82%B3%E3%83%BC%E3%83%AB%E7%9B%A3%E8%A6%96%E3%81%97%E3%81%A6%E3%81%BF%E3%81%9F.html"/>
    <updated>2014-06-13T00:00:00+09:00</updated>
    <id>http://luozengbin.github.io/blog/[検証]smtpプロトコール監視してみた</id>
    <content type="html"><![CDATA[<p>
自宅のPC環境にMTA(postfix)サーバを構築しました。
１周間ほど保持したので、telnet、nc、tcpdumpコマンドから
メール送信処理の中身を観測してみたいと思います。
</p>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">概要</h2>
<div class="outline-text-2" id="text-1">
<p>
VM環境を立てるのが面倒のため、loopbackインタフェースを通して
ローカル環境内で検証を行う。
</p>
<pre class="example">
+--------------+         +-------------+
|              |         |             |
| クライアント +-- lo ----+  MTAサーバ |
|              |         |             |
+--------------+         +-------------+
  127.0.0.1                127.0.0.1:25
</pre>

<p>
<!-- more -->
</p>

<p>
ドメイン、メール送受信情報
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">MTAサーバFQDN</td>
<td class="left">mail.home</td>
</tr>

<tr>
<td class="left">クライアントFQDN</td>
<td class="left">jizai.home</td>
</tr>

<tr>
<td class="left">送信者メール</td>
<td class="left">akira@mail.home</td>
</tr>

<tr>
<td class="left">受信者メール</td>
<td class="left">root@mail.home</td>
</tr>
</tbody>
</table>

<p>
tcpdumpコマンドでloopbackインタフェースのパケットを監視する。
</p>

<pre class="example">
[akira@jizai ~]$ sudo tcpdump -n  -i lo port 25
</pre>

<p>
telnetからメール送信レシピ、 <span class="underline">★</span> が付いている部分が手入力
</p>
<pre class="example">
[akira@jizai ~]$ telnet localhost 25     ★接続開始
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
220 mail.home ESMTP unknown
HELO jizai.home                          ★メール送信開始宣言
250 mail.home
MAIL FROM: &lt;akira@mail.home&gt;             ★送信元を指定する
250 2.1.0 Ok
RCPT TO: &lt;root@mail.home&gt;                ★送信先を指定する
250 2.1.5 Ok
DATA                                     ★メール本文を開始する
354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;
This is a Test mail from telnet
Hello root!
.                                        ★メール本文終了
250 2.0.0 Ok: queued as AB9BF8A107E
quit                                     ★接続終了
221 2.0.0 Bye
Connection closed by foreign host.
[akira@jizai ~]$
</pre>
</div>
</div>




<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">telnetからの接続開始</h2>
<div class="outline-text-2" id="text-2">
<p>
localhostの25番ポートへ接続する。
</p>
<pre class="example">
[akira@jizai ~]$ telnet localhost 25
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
220 mail.home ESMTP unknown    ★ 説明：MTAサーバから準備完了応答メッセージ
</pre>

<p>
tcpdumpの出力にtcpの3ウェイ・ハンドシェイク処理(1-3行目)と
MTAサーバから最初の応答メッセージ(4-5行目)が表示される。
</p>
<pre class="example">
11:49:33.684755 IP 192.168.100.3.30760 &gt; 192.168.100.3.25: Flags [S], seq 1483942186, win 43690, options [mss 65495,sackOK,TS val 2064872 ecr 0,nop,wscale 7], length 0
11:49:33.684770 IP 192.168.100.3.25 &gt; 192.168.100.3.30760: Flags [S.], seq 2082428713, ack 1483942187, win 43690, options [mss 65495,sackOK,TS val 2064872 ecr 2064872,nop,wscale 7], length 0
11:49:33.684787 IP 192.168.100.3.30760 &gt; 192.168.100.3.25: Flags [.], ack 1, win 342, options [nop,nop,TS val 2064872 ecr 2064872], length 0
11:49:33.685184 IP 192.168.100.3.25 &gt; 192.168.100.3.30760: Flags [P.], seq 1:30, ack 1, win 342, options [nop,nop,TS val 2064872 ecr 2064872], length 29
11:49:33.685214 IP 192.168.100.3.30760 &gt; 192.168.100.3.25: Flags [.], ack 30, win 342, options [nop,nop,TS val 2064872 ecr 2064872], length 0
</pre>
<p>
気になること、tcpdumpの出力に途中からシーケンス番号が1に変わった。調べてみた結果、
tcpdump がわかりやすく表示するためでした。 <code>-S</code> を付けることでオリジナルのシーケンス
番号をそのまま出力することができる。
</p>

<p>
MTAログにクライアントからの接続跡が記録された。
</p>
<pre class="example">
Jun 13 11:49:33 localhost postfix/smtpd[4873]: warning: hostname jizai does not resolve to address 192.168.100.3
Jun 13 11:49:33 localhost postfix/smtpd[4873]: connect from unknown[192.168.100.3]
</pre>
<p>
MTAサーバでHELOからの名前解決にまだ問題が残っているようです。
DNSサーバに名前登録したはずです。さあ、どうしよう！
</p>
</div>
</div>




<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">メール送信の開始を宣言する</h2>
<div class="outline-text-2" id="text-3">
<p>
<code>HELO &lt;クライアントのホスト名&gt;</code> コマンドでメールサーバに
にてメール送信の開始を宣言する。
</p>
<pre class="example">
[akira@jizai ~]$ telnet localhost 25
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
220 mail.home ESMTP unknown
HELO jizai.home        ★ HELOコマンド実行
250 mail.home          ★ サーバからの250応答
</pre>

<p>
tcpdumpの出力、クライアントのPUSH（１行目）とサーバのACK（２行目）、
そしてサーバから応答時のPUSHとクライアントの受信ACKで合計４通が表示された。
</p>
<pre class="example">
10:51:18.385531 IP 127.0.0.1.55748 &gt; 127.0.0.1.25: Flags [P.], seq 1:18, ack 30, win 342, options [nop,nop,TS val 1016282 ecr 1012424], length 17
10:51:18.385568 IP 127.0.0.1.25 &gt; 127.0.0.1.55748: Flags [.], ack 18, win 342, options [nop,nop,TS val 1016282 ecr 1016282], length 0
10:51:18.385682 IP 127.0.0.1.25 &gt; 127.0.0.1.55748: Flags [P.], seq 30:45, ack 18, win 342, options [nop,nop,TS val 1016282 ecr 1016282], length 15
10:51:18.385711 IP 127.0.0.1.55748 &gt; 127.0.0.1.25: Flags [.], ack 45, win 342, options [nop,nop,TS val 1016282 ecr 1016282], length 0
</pre>
</div>
</div>




<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">送信元を指定する</h2>
<div class="outline-text-2" id="text-4">
<p>
<code>MAIL FROM: &lt;送信元メール&gt;</code> コマンドにて送信元メールアドレスを設定する。
</p>
<pre class="example">
MAIL FROM: &lt;akira@mail.home&gt;
250 2.1.0 Ok       ★応答コード 250
</pre>

<p>
tcpdumpの出力、サーバからのACKと応答メッセージのPUSHが纏めて送信されたため
TCPやり取りが３通で表示された。
</p>
<pre class="example">
11:50:09.768768 IP 192.168.100.3.30760 &gt; 192.168.100.3.25: Flags [P.], seq 18:48, ack 45, win 342, options [nop,nop,TS val 2075697 ecr 2070308], length 30
11:50:09.768944 IP 192.168.100.3.25 &gt; 192.168.100.3.30760: Flags [P.], seq 45:59, ack 48, win 342, options [nop,nop,TS val 2075697 ecr 2075697], length 14
11:50:09.768976 IP 192.168.100.3.30760 &gt; 192.168.100.3.25: Flags [.], ack 59, win 342, options [nop,nop,TS val 2075697 ecr 2075697], length 0
</pre>
</div>
</div>




<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">送信先を指定する</h2>
<div class="outline-text-2" id="text-5">
<p>
<code>RCPT TO: &lt;送信先メール&gt;</code> コマンドにて送信先メールアドレスを設定する。
</p>
<pre class="example">
MAIL FROM: &lt;root@mail.home&gt;
250 2.1.5 Ok     ★応答コード 250
</pre>

<p>
tcpdumpの出力、サーバからのACKと応答メッセージのPUSHが纏めて送信されたため
TCPやり取りが３通で表示された。
</p>
<pre class="example">
11:50:22.696751 IP 192.168.100.3.30760 &gt; 192.168.100.3.25: Flags [P.], seq 48:75, ack 59, win 342, options [nop,nop,TS val 2079575 ecr 2075697], length 27
11:50:22.703097 IP 192.168.100.3.25 &gt; 192.168.100.3.30760: Flags [P.], seq 59:73, ack 75, win 342, options [nop,nop,TS val 2079577 ecr 2079575], length 14
11:50:22.703135 IP 192.168.100.3.30760 &gt; 192.168.100.3.25: Flags [.], ack 73, win 342, options [nop,nop,TS val 2079577 ecr 2079577], length 0
</pre>

<p>
また <code>RCPT TO</code> コマンドがMTAサーバに届くと、サーバ側のsmtpdプロセスでメール
キューイングIDの払出、送信先アドレスのチェック処理が実施される。以下はMTAログです。
</p>
<pre class="example">
Jun 13 11:50:22 localhost postfix/smtpd[4873]: AB9BF8A107E: client=unknown[192.168.100.3]
</pre>
</div>
</div>




<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">メール本文を開始する</h2>
<div class="outline-text-2" id="text-6">
<p>
<code>DATA</code> コマンドにてメール本文開始要求をサーバへ送信する。
</p>
<pre class="example">
DATA
354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;  ★応答コード 354
</pre>

<p>
tcpdumpの出力
</p>
<pre class="example">
11:50:44.461274 IP 192.168.100.3.30760 &gt; 192.168.100.3.25: Flags [P.], seq 75:81, ack 73, win 342, options [nop,nop,TS val 2086105 ecr 2079577], length 6
11:50:44.461442 IP 192.168.100.3.25 &gt; 192.168.100.3.30760: Flags [P.], seq 73:110, ack 81, win 342, options [nop,nop,TS val 2086105 ecr 2086105], length 37
11:50:44.461474 IP 192.168.100.3.30760 &gt; 192.168.100.3.25: Flags [.], ack 110, win 342, options [nop,nop,TS val 2086105 ecr 2086105], length 0
</pre>

<p>
<span class="underline">telnetターミナルからメール本文を入力する、観測結果から見ると改行が入力されるたびに</span>
<span class="underline">入力されたテキストがサーバへ送信される。</span>
</p>
<pre class="example">
This is a Test mail from telnet       ★改行１
Hello root!                           ★改行２
</pre>

<p>
tcpdumpの出力
</p>
<pre class="example">
★改行１
11:50:58.590306 IP 192.168.100.3.30760 &gt; 192.168.100.3.25: Flags [P.], seq 81:114, ack 110, win 342, options [nop,nop,TS val 2090343 ecr 2086105], length 33
11:50:58.628041 IP 192.168.100.3.25 &gt; 192.168.100.3.30760: Flags [.], ack 114, win 342, options [nop,nop,TS val 2090355 ecr 2090343], length 0

★改行２
11:51:09.655315 IP 192.168.100.3.30760 &gt; 192.168.100.3.25: Flags [P.], seq 114:127, ack 110, win 342, options [nop,nop,TS val 2093663 ecr 2090355], length 13
11:51:09.655352 IP 192.168.100.3.25 &gt; 192.168.100.3.30760: Flags [.], ack 127, win 342, options [nop,nop,TS val 2093663 ecr 2093663], length 0
</pre>
</div>
</div>




<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">メール本文終了</h2>
<div class="outline-text-2" id="text-7">
<p>
.（ピリオド）を入力して、メール本文終了要求をサーバへ送信する。
</p>
<pre class="example">
.
250 2.0.0 Ok: queued as AB9BF8A107E
</pre>

<p>
.（ピリオド）の送信とサーバからの250正常応答受信合計４通。
</p>
<pre class="example">
11:51:21.982567 IP 192.168.100.3.30760 &gt; 192.168.100.3.25: Flags [P.], seq 127:130, ack 110, win 342, options [nop,nop,TS val 2097361 ecr 2093663], length 3
11:51:21.982599 IP 192.168.100.3.25 &gt; 192.168.100.3.30760: Flags [.], ack 130, win 342, options [nop,nop,TS val 2097361 ecr 2097361], length 0
11:51:22.014030 IP 192.168.100.3.25 &gt; 192.168.100.3.30760: Flags [P.], seq 110:147, ack 130, win 342, options [nop,nop,TS val 2097370 ecr 2097361], length 37
11:51:22.014070 IP 192.168.100.3.30760 &gt; 192.168.100.3.25: Flags [.], ack 147, win 342, options [nop,nop,TS val 2097370 ecr 2097370], length 0
</pre>

<p>
MTAログにメールのキューイング処理と転送処理の記録が出力された。
メールヘッダのmessage-id項目がこの時点で払いだされたようです。
</p>
<ul class="org-ul">
<li>形式： <code>yyyymmdd999999.キューイングID@ドメイン名</code>
</li>
</ul>
<pre class="example">
Jun 13 11:51:21 localhost postfix/cleanup[5028]: AB9BF8A107E: message-id=&lt;20140613025022.AB9BF8A107E@mail.home&gt;
Jun 13 11:51:22 localhost postfix/qmgr[920]: AB9BF8A107E: from=&lt;akira@mail.home&gt;, size=333, nrcpt=1 (queue active)
Jun 13 11:51:22 localhost postfix/local[5058]: AB9BF8A107E: to=&lt;akira@mail.home&gt;, orig_to=&lt;root@mail.home&gt;, relay=local, delay=72, delays=72/0.01/0/0.02, dsn=2.0.0, status=sent (delivered to maildir)
Jun 13 11:51:22 localhost postfix/qmgr[920]: AB9BF8A107E: removed
</pre>
</div>
</div>




<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">接続終了</h2>
<div class="outline-text-2" id="text-8">
<p>
<code>quit</code> コマンドにて接続切断する。
</p>
<pre class="example">
quit                 ★ 切断送信
221 2.0.0 Bye        ★ 211応答
Connection closed by foreign host.
</pre>

<pre class="example">
★ 切断送信
11:51:42.503665 IP 192.168.100.3.30760 &gt; 192.168.100.3.25: Flags [P.], seq 130:136, ack 147, win 342, options [nop,nop,TS val 2103517 ecr 2097370], length 6

★ 211応答
11:51:42.503825 IP 192.168.100.3.25 &gt; 192.168.100.3.30760: Flags [P.], seq 147:162, ack 136, win 342, options [nop,nop,TS val 2103517 ecr 2103517], length 15
11:51:42.503856 IP 192.168.100.3.30760 &gt; 192.168.100.3.25: Flags [.], ack 162, win 342, options [nop,nop,TS val 2103517 ecr 2103517], length 0

★ tcpセッション終了
11:51:42.503867 IP 192.168.100.3.25 &gt; 192.168.100.3.30760: Flags [F.], seq 162, ack 136, win 342, options [nop,nop,TS val 2103517 ecr 2103517], length 0
11:51:42.503969 IP 192.168.100.3.30760 &gt; 192.168.100.3.25: Flags [F.], seq 136, ack 163, win 342, options [nop,nop,TS val 2103517 ecr 2103517], length 0
11:51:42.503999 IP 192.168.100.3.25 &gt; 192.168.100.3.30760: Flags [.], ack 137, win 342, options [nop,nop,TS val 2103517 ecr 2103517], length 0
</pre>

<p>
MTAログにクライアント切断跡が残ります。
</p>
<pre class="example">
Jun 13 11:51:42 localhost postfix/smtpd[4873]: disconnect from unknown[192.168.100.3]
</pre>
</div>
</div>




<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">ncコマンドでファイルからメール送信テスト</h2>
<div class="outline-text-2" id="text-9">
<p>
telnetで入力した内容を <code>sendmail_test.txt</code> に保存し、ncに渡せばコマン１行
でメール送信することができた。
</p>

<p>
<code>sendmail_test.txt</code> の内容。
</p>
<pre class="example">
HELO jizai.home
MAIL FROM: &lt;akira@mail.home&gt;
RCPT TO: &lt;root@mail.home&gt;
DATA
This is a Test mail from nc
Hello root!
.
</pre>

<p>
メール送信したみた。
</p>
<pre class="example">
[akira@jizai temp]$ cat sendmail_test.txt | nc localhost 25
220 mail.home ESMTP unknown
250 mail.home
250 2.1.0 Ok
250 2.1.5 Ok
354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;
250 2.0.0 Ok: queued as BE5B98A107E
[akira@jizai temp]$
</pre>
</div>
</div>




<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10">習ったこと</h2>
<div class="outline-text-2" id="text-10">
<ul class="org-ul">
<li>tcpdumpのシーケンス番号の出力ルール
</li>
<li>DATAブロック内であっても、telnetターミナルで改行すると内容がサーバに送信される
</li>
<li>キューイングIDとメールメッセージIDの払出タイミング
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11">参考</h2>
<div class="outline-text-2" id="text-11">
<ul class="org-ul">
<li><a href="http://www.atmarkit.co.jp/ait/articles/0304/22/news001.html">http://www.atmarkit.co.jp/ait/articles/0304/22/news001.html</a>
</li>
</ul>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LPIC Lv2-201試験準備メモ１]]></title>
    <link href="http://luozengbin.github.io/blog/2014-06-12-lpic-lv2-201%E8%A9%A6%E9%A8%93%E6%BA%96%E5%82%99%E3%83%A1%E3%83%A2%EF%BC%91.html"/>
    <updated>2014-06-12T00:00:00+09:00</updated>
    <id>http://luozengbin.github.io/blog/lpic-lv2-201試験準備メモ１</id>
    <content type="html"><![CDATA[<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">MBRパーティショニング</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>基本パテーション：MBR仕様の制限で基本パテーションは最大４つ
</li>
<li>拡張パテーション：一つ基本パテーションとして計算する
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">LVMスナップショート</h2>
<div class="outline-text-2" id="text-2">
<p>
スナップショートとはあるLVのカレント状態をバックアップする機能。
バックアップ方式としてファイルの増分内容を記録LV領域を作成しそのLV
領域にスナップショート作成時点からの変化履歴を記録する。
増分バックアップ方式であるため、初期作成時は容量消費しない。
対象LVに上ファイル変化があったたびにスナップショートLVに
変化内容が書き込まれるため、領域が消費される。
</p>

<p>
<!-- more -->
</p>
</div>
</div>




<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">ARP (Address Resolution Protocol) コマンド</h2>
<div class="outline-text-2" id="text-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">arp -i eth0</td>
<td class="left">eth0インタフェースのarpキャッシュを表示する</td>
</tr>

<tr>
<td class="left">arp -a jizai.home</td>
<td class="left">対象ホストのmacアドレスを表示する</td>
</tr>

<tr>
<td class="left">arp -d jizai.home</td>
<td class="left">対象ホストのarpキャッシュを削除する</td>
</tr>

<tr>
<td class="left">arp -n</td>
<td class="left">逆引きを行わず、arpキャッシュを表示する</td>
</tr>

<tr>
<td class="left">arp -s 192.168.100.4 0a:c3:1c:e4:75:eb</td>
<td class="left">arpエントリレコードを追加する</td>
</tr>

<tr>
<td class="left">arp -f [/etc/ethers]</td>
<td class="left">ファイルからarpエントリレコードを追加する</td>
</tr>
</tbody>
</table>
</div>
</div>




<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">ネットワーク設定ファイルのパス</h2>
<div class="outline-text-2" id="text-4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">/etc/hostname</td>
<td class="left">ホスト名の設定</td>
</tr>

<tr>
<td class="left">/etc/hosts</td>
<td class="left">ホスト別名とIPのマッピング定義</td>
</tr>

<tr>
<td class="left">/etc/resolv.conf</td>
<td class="left">DNSサーバの指定</td>
</tr>

<tr>
<td class="left">/etc/nsswitch.conf</td>
<td class="left">名前解決方式のの優先順位指定</td>
</tr>

<tr>
<td class="left">/etc/networks</td>
<td class="left">ネットワーク名とネットワークアドレス</td>
</tr>
</tbody>
</table>
</div>
</div>




<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">忘れがち知識</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>/etc/sysconfig/network ファイルにおいて IPv6 アドレス有効化こと項目：NETWORKING_IPV6
</li>
<li>無線 LAN のリンク品質や信号強度を確認できるコマンド
<ul class="org-ul">
<li>iwconfig
</li>
<li>iwlist
</li>
<li>iwspy
</li>
</ul>
</li>
</ul>
</div>
</div>

]]></content>
  </entry>
  
</feed>
