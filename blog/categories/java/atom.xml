<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | Akira's Tech Notes]]></title>
  <link href="http://luozengbin.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://luozengbin.github.io/"/>
  <updated>2015-05-10T13:28:59+09:00</updated>
  <id>http://luozengbin.github.io/</id>
  <author>
    <name><![CDATA[luozengbin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[メモ]デバッグ版OpenJDKのビルド]]></title>
    <link href="http://luozengbin.github.io/blog/2015-05-10-%5B%E3%83%A1%E3%83%A2%5D%E3%83%87%E3%83%90%E3%83%83%E3%82%B0%E7%89%88openjdk%E3%81%AE%E3%83%93%E3%83%AB%E3%83%89.html"/>
    <updated>2015-05-10T00:00:00+09:00</updated>
    <id>http://luozengbin.github.io/blog/[メモ]デバッグ版openjdkのビルド</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 環境</a></li>
<li><a href="#sec-2">2. ビルド手順</a></li>
<li><a href="#sec-3">3. gdbでデバッグしてみる</a></li>
<li><a href="#sec-4">4. valgrindでコールグラフ出してみる</a></li>
<li><a href="#sec-5">5. 参考</a></li>
</ul>
</div>
</div>


<p>
今まで、JVM中身の調査は <code>SystemTap + java-1.x.x-openjdk-debuginfo.x86_64</code> 利用してい
たが。もう少しJVMの中身を踏み込みたいのでデバッグ版JVMをビルドしてみました。
</p>




<p>
<a href="http://hg.openjdk.java.net/jdk7/jdk7/raw-file/tip/README-builds.html">http://hg.openjdk.java.net/jdk7/jdk7/raw-file/tip/README-builds.html</a> の手順でビルドし
てもいいのですが、トライ・アンド・エラーで時間が取られそうなので、自分が使っている
<code>Arch Linx</code> 環境で一番手取りの早い手順で行いました。
</p>




<p>
<!-- more -->
</p>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 環境</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>Arch Linux
</li>
<li>OpenJDK 7系
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> ビルド手順</h2>
<div class="outline-text-2" id="text-2">
<p>
まずはパッケージリポジトリから <a href="https://www.archlinux.org/packages/extra/x86_64/jdk7-openjdk/">jdk7-openjdk</a> のビルドファイルやパッチファイルを入手する。
</p>
<ul class="org-ul">
<li><a href="https://projects.archlinux.org/svntogit/packages.git/tree/trunk?h=packages/java7-openjdk">入手先</a>
</li>
</ul>
<pre class="example">
★ダウンロード
$ wget https://projects.archlinux.org/svntogit/packages.git/plain/trunk/PKGBUILD?h=packages/java7-openjdk -O PKGBUILD
$ wget https://projects.archlinux.org/svntogit/packages.git/plain/trunk/fontconfig-paths.diff?h=packages/java7-openjdk -O fontconfig-paths.diff
$ wget https://projects.archlinux.org/svntogit/packages.git/plain/trunk/jdk7-openjdk.install?h=packages/java7-openjdk -O jdk7-openjdk.install
$ wget https://projects.archlinux.org/svntogit/packages.git/plain/trunk/jre7-openjdk-headless.install?h=packages/java7-openjdk -O jre7-openjdk-headless.install
$ wget https://projects.archlinux.org/svntogit/packages.git/plain/trunk/jre7-openjdk.install?h=packages/java7-openjdk -O jre7-openjdk.install
$ wget https://projects.archlinux.org/svntogit/packages.git/plain/trunk/openjdk7_nonreparenting-wm.diff?h=packages/java7-openjdk -O openjdk7_nonreparenting-wm.diff
★ファイル一覧確認
$ ls -al
合計 52
drwxr-xr-x  2 akira users  4096  5月 10 11:24 .
drwxr-xr-x 21 akira users  4096  5月 10 11:23 ..
-rw-r--r--  1 akira users 12429  5月 10 11:24 PKGBUILD
-rw-r--r--  1 akira users  8302  5月 10 11:24 fontconfig-paths.diff
-rw-r--r--  1 akira users  1053  5月 10 11:24 jdk7-openjdk.install
-rw-r--r--  1 akira users   974  5月 10 11:24 jre7-openjdk-headless.install
-rw-r--r--  1 akira users  1201  5月 10 11:24 jre7-openjdk.install
-rw-r--r--  1 akira users  2324  5月 10 11:24 openjdk7_nonreparenting-wm.diff
</pre>

<p>
<code>PKGBUILD</code> ファイルにデバッグビルドオプションを有効化する。
</p>
<ol class="org-ol">
<li><code>--enable-native-debuginfo=yes</code> build with native code debuginfo [default=yes]
</li>
<li><code>--enable-java-debuginfo=yes</code> build with Java bytecode debuginfo [default=yes]
</li>
<li><code>make icedtea-debug</code> デバッグビルドターゲットに変える
</li>
</ol>

<p>
<code>1</code> と <code>2</code> の規定値は <code>yes</code> なので、指定しなくても問題ありません。 <code>3</code> が肝ですね。
</p>

<div class="org-src-container">

<pre class="src src-sh">  ..........&#30465;&#30053;.........
  |build() {
  |  <span style="color: #b0c4de;">cd</span> <span style="color: #bdb76b;">"${srcdir}/icedtea-${_icedtea_ver}"</span>
  | 
  |  <span style="color: #b0c4de;">export</span> <span style="color: #9acd32;">ALT_PARALLEL_COMPILE_JOBS</span>=<span style="color: #bdb76b;">"${MAKEFLAGS/-j}"</span>
  |  <span style="color: #b0c4de;">export</span> <span style="color: #9acd32;">HOTSPOT_BUILD_JOBS</span>=<span style="color: #bdb76b;">"${ALT_PARALLEL_COMPILE_JOBS}"</span>
  | 
  |  <span style="color: #b0c4de;">.</span> /etc/profile.d/apache-ant.sh
  | 
  |  cp <span style="color: #bdb76b;">"${srcdir}"</span>/*.diff <span style="color: #bdb76b;">"${srcdir}"</span>/icedtea-${<span style="color: #9acd32;">_icedtea_ver</span>}/patches
  |  <span style="color: #b0c4de;">export</span> <span style="color: #9acd32;">DISTRIBUTION_PATCHES</span>=<span style="color: #bdb76b;">"patches/fontconfig-paths.diff \</span>
<span style="color: #bdb76b;">  |                               patches/openjdk7_nonreparenting-wm.diff"</span>
  | 
  |  <span style="color: #ffffff;">if</span> [ <span style="color: #bdb76b;">"$_bootstrap"</span> = <span style="color: #bdb76b;">"1"</span> ]; <span style="color: #ffffff;">then</span>
  |     <span style="color: #9acd32;">BOOTSTRAPOPT</span>=<span style="color: #bdb76b;">"--enable-bootstrap --with-ecj-jar=/usr/share/java/ecj.jar"</span>
  |   <span style="color: #ffffff;">else</span>
  |     <span style="color: #9acd32;">BOOTSTRAPOPT</span>=<span style="color: #bdb76b;">"--disable-bootstrap"</span>
  |  <span style="color: #ffffff;">fi</span>
  | 
  |  ./configure <span style="color: #bdb76b;">\</span>
  |        ${<span style="color: #9acd32;">BOOTSTRAPOPT</span>} <span style="color: #bdb76b;">\</span>
  |        --with-parallel-jobs=<span style="color: #bdb76b;">"${MAKEFLAGS/-j}"</span> <span style="color: #bdb76b;">\</span>
  |        --disable-tests <span style="color: #bdb76b;">\</span>
  |        --disable-downloading --disable-Werror <span style="color: #bdb76b;">\</span>
  |        --with-pkgversion=<span style="color: #bdb76b;">"Arch Linux build ${pkgver}-${pkgrel}-${CARCH}"</span> <span style="color: #bdb76b;">\</span>
  |        --with-jdk-home=${<span style="color: #9acd32;">JAVA_HOME</span>} <span style="color: #bdb76b;">\</span>
  |        --with-openjdk-src-zip=<span style="color: #bdb76b;">"${srcdir}/icedtea_${_icedtea_ver}_openjdk.tar.bz2"</span> <span style="color: #bdb76b;">\</span>
  |        --with-hotspot-src-zip=<span style="color: #bdb76b;">"${srcdir}/icedtea_${_icedtea_ver}_hotspot.tar.bz2"</span> <span style="color: #bdb76b;">\</span>
  |        --with-corba-src-zip=<span style="color: #bdb76b;">"${srcdir}/icedtea_${_icedtea_ver}_corba.tar.bz2"</span> <span style="color: #bdb76b;">\</span>
  |        --with-jaxp-src-zip=<span style="color: #bdb76b;">"${srcdir}/icedtea_${_icedtea_ver}_jaxp.tar.bz2"</span> <span style="color: #bdb76b;">\</span>
  |        --with-jaxws-src-zip=<span style="color: #bdb76b;">"${srcdir}/icedtea_${_icedtea_ver}_jaxws.tar.bz2"</span> <span style="color: #bdb76b;">\</span>
  |        --with-jdk-src-zip=<span style="color: #bdb76b;">"${srcdir}/icedtea_${_icedtea_ver}_jdk.tar.bz2"</span> <span style="color: #bdb76b;">\</span>
  |        --with-langtools-src-zip=<span style="color: #bdb76b;">"${srcdir}/icedtea_${_icedtea_ver}_langtools.tar.bz2"</span> <span style="color: #bdb76b;">\</span>
  |        --enable-nss <span style="color: #bdb76b;">\</span>
  |        --with-rhino <span style="color: #bdb76b;">\</span>
  |        --with-abs-install-dir=${<span style="color: #9acd32;">_jvmdir</span>} <span style="color: #bdb76b;">\</span>
1.|        --enable-native-debuginfo=yes <span style="color: #bdb76b;">\</span>
2.|        --enable-java-debuginfo=yes <span style="color: #bdb76b;">\</span>
  |        --enable-infinality=no
  |        <span style="color: #00cd66;"># </span><span style="color: #00cd66;">TODO latest version of openjdk will disable infinality by default</span>
  |
3.|    make icedtea-debug
  |}
  ..........&#30465;&#30053;.........
</pre>
</div>

<p>
あとは <a href="https://archlinuxjp.kusakata.com/wiki/Makepkg">makepkg</a> でビルドするだけです。コーヒーいっぱい分の時間かかります。
</p>
<pre class="example">
$ makepkg
==&gt; パッケージを作成: java7-openjdk 7.u79_2.5.5-1 (2015年  5月 10日 日曜日 11:43:40 JST)
==&gt; ランタイムの依存関係を確認...
==&gt; ビルドタイムの依存関係を確認...
==&gt; ソースを取得...
..........省略.........

★肝心のhotspotビルド
########################################################################
##### Entering hotspot for target(s) all_debug                     #####
########################################################################
..........省略.........

★ビルド時のオプション
g++ 
-DLINUX
-D_GNU_SOURCE 
-DAMD64 
-DASSERT 
-DDEBUG -I. -I/home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/share/vm/prims -I/home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/share/vm -I/home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/share/vm/precompiled -I/home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/cpu/x86/vm -I/home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/os_cpu/linux_x86/vm -I/home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/os/linux/vm -I/home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/os/posix/vm -I../generated 
-DHOTSPOT_RELEASE_VERSION="\"24.79-b02\"" 
-DHOTSPOT_BUILD_TARGET="\"jvmg\"" 
-DHOTSPOT_BUILD_USER="\"akira\"" 
-DHOTSPOT_LIB_ARCH=\"amd64\" 
-DHOTSPOT_VM_DISTRO="\"OpenJDK\"" 
-DDERIVATIVE_ID="\"IcedTea 2.5.5\"" 
-DDISTRIBUTION_ID="\"Arch Linux, package Arch Linux build 7.u79_2.5.5-1-x86_64\""
-march=x86-64 -mtune=generic -O2 -pipe -fstack-protector-strong --param=ssp-buffer-size=4
-DTARGET_OS_FAMILY_linux 
-DTARGET_ARCH_x86 
-DTARGET_ARCH_MODEL_x86_64 
-DTARGET_OS_ARCH_linux_x86 
-DTARGET_OS_ARCH_MODEL_linux_x86_64 
-DTARGET_COMPILER_gcc 
-DCOMPILER2 
-DCOMPILER1  -fno-rtti -fno-exceptions 
-D_REENTRANT -fcheck-new -fvisibility=hidden -m64 -pipe -g 
-DTARGET_OS_FAMILY_linux 
-DTARGET_ARCH_x86 
-DTARGET_ARCH_MODEL_x86_64 
-DTARGET_OS_ARCH_linux_x86 
-DTARGET_OS_ARCH_MODEL_linux_x86_64 
-DTARGET_COMPILER_gcc 
-DCOMPILER2 
-DCOMPILER1 -fpic -fno-rtti -fno-exceptions 
-D_REENTRANT -fcheck-new -fvisibility=hidden -m64 -pipe 
★カスタマイズdebugビルドフラグ
-g -finstrument-functions -fvar-tracking-assignments -rdynamic
-D_NMT_NOINLINE_ 
-DVM_LITTLE_ENDIAN 
-D_LP64=1 -fno-omit-frame-pointer 
-DINCLUDE_TRACE=1  -Wpointer-arith -Wsign-compare    -c -fpch
-Deps -MMD -MP -MF ../generated/dependencies/osThread_linux.o.d -o osThread_linux.o /home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/os/linux/vm/osThread_linux.cpp

Compiling /home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/os/linux/vm/os_linux.cpp

..........省略.........

-- Build times ----------
Target all_product_build
Start 2015-05-10 11:43:19
End   2015-05-10 12:41:39
00:09:54 corba
00:11:03 hotspot
00:01:15 jaxp
00:01:25 jaxws
00:31:45 jdk
00:02:58 langtools
00:58:20 TOTAL
-------------------------
..........省略.........
</pre>

<p>
僕の環境では約1時間ぐらいかかりました。
</p>
<ul class="org-ul">
<li>CPU: Intel(R) Core(TM) i5-2557M CPU @ 1.70GHz
</li>
<li>Memory: 4G
</li>
<li>SSD
</li>
</ul>


<p>
ビルド成果物はワークディレクトリの下記場所に出力される。
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">デバッグ版OpenJDK</td>
<td class="left">src/icedtea-2.5.5/openjdk.build-debug</td>
</tr>

<tr>
<td class="left">hotspot単体</td>
<td class="left">src/icedtea-2.5.5/openjdk.build-debug/hotspot/outputdir/linux_amd64_compiler2/jvmg</td>
</tr>
</tbody>
</table>
</div>
</div>




<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> gdbでデバッグしてみる</h2>
<div class="outline-text-2" id="text-3">
<ol class="org-ol">
<li>hotspot単体の出力先へ移動する
</li>
<li><code>-gdb</code> オプションを付けて <code>./hotspot</code> を起動する
</li>
<li>デバッグ版のJVMランチャーに既にBreakpointが設定されている
</li>
<li><code>p</code> で変数の値を確認する
</li>
<li><code>next</code> でステップオーバーでデバッグする
</li>
<li><code>step</code> でステップインでデバッグする
</li>
<li><code>backtrace</code> でスタックトレースを確認する
</li>
<li><code>continue</code> で最後まで実行される
</li>
</ol>

<pre class="example">
1.|$ cd src/icedtea-2.5.5/openjdk.build-debug/hotspot/outputdir/linux_amd64_compiler2/jvmg
2.|$ ./hotspot -gdb -version
  |GNU gdb (GDB) 7.9
  |Copyright (C) 2015 Free Software Foundation, Inc.
  |License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
  |This is free software: you are free to change and redistribute it.
  |There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
  |and "show warranty" for details.
  |This GDB was configured as "x86_64-unknown-linux-gnu".
  |Type "show configuration" for configuration details.
  |For bug reporting instructions, please see:
  |&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
  |Find the GDB manual and other documentation resources online at:
  |&lt;http://www.gnu.org/software/gdb/documentation/&gt;.
  |For help, type "help".
  |Type "apropos word" to search for commands related to "word".
  |Breakpoint 1 at 0x4042f7: file /home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/share/tools/launcher/java.c, line 1270.
  |[Thread debugging using libthread_db enabled]
  |Using host libthread_db library "/usr/lib/libthread_db.so.1".
  |Using java runtime at: /home/akira/temp/java7-openjdk/src/icedtea-2.5.5/bootstrap/jdk1.6.0/jre
  |[New Thread 0x7ffff7fa6700 (LWP 15629)]
  |[Switching to Thread 0x7ffff7fa6700 (LWP 15629)]
  | 
3.|Breakpoint 1, InitializeJVM (pvm=0x7ffff7fa5e38, penv=0x7ffff7fa5e30, ifn=0x7ffff7fa5e40)
  |    at /home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/share/tools/launcher/java.c:1270
  |1270     memset(&amp;args, 0, sizeof(args));
4.|(gdb) p args
  |$1 = {version = 0, nOptions = 0, options = 0x0, ignoreUnrecognized = 0 '\000'}
5.|(gdb) next
  |1271     args.version  = JNI_VERSION_1_2;
  |(gdb) next
  |1272     args.nOptions = numOptions;
  |(gdb) next
  |1273     args.options  = options;
  |(gdb) next
  |1274     args.ignoreUnrecognized = JNI_FALSE;
  |(gdb) next
  |1276     if (_launcher_debug) {
  |(gdb) next
  |1288     r = ifn-&gt;CreateJavaVM(pvm, (void **)penv, &amp;args);
6.|(gdb) step
  |JNI_CreateJavaVM (vm=0x7ffff7fa5e38, penv=0x7ffff7fa5e30, args=0x7ffff7fa5df0)
  |    at /home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/share/vm/prims/jni.cpp:5121
  |5121   if (Atomic::xchg(1, &amp;vm_created) == 1) {
7.|(gdb) backtrace 
  |#0  JNI_CreateJavaVM (vm=0x7ffff7fa5e38, penv=0x7ffff7fa5e30, args=0x7ffff7fa5df0)
  |    at /home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/share/vm/prims/jni.cpp:5121
  |#1  0x00000000004043fd in InitializeJVM (pvm=0x7ffff7fa5e38, penv=0x7ffff7fa5e30, ifn=0x7ffff7fa5e40)
  |    at /home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/share/tools/launcher/java.c:1288
  |#2  0x00000000004031ea in JavaMain (_args=0x7fffffffc080)
  |    at /home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/share/tools/launcher/java.c:423
  |#3  0x00007ffff5c17374 in start_thread () from /usr/lib/libpthread.so.0
  |#4  0x00007ffff595527d in clone () from /usr/lib/libc.so.6
8.|(gdb) continue
  |Continuing.
  |java version "1.7.0_79"
  |OpenJDK Runtime Environment (IcedTea 2.5.5) (Arch Linux build 7.u79_2.5.5-1-x86_64)
  |OpenJDK 64-Bit Server VM (build 24.79-b02-jvmg, mixed mode)
  |[Thread 0x7ffff7fa6700 (LWP 16481) exited]
  [Thread 0x7ffff7fa8740 (LWP 16477) exited]
  [Inferior 1 (process 16477) exited normally]
  (gdb) q
  $
</pre>
</div>
</div>




<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> valgrindでコールグラフ出してみる</h2>
<div class="outline-text-2" id="text-4">
<p>
valgrindでコールグラフを出してみました。
</p>

<p>
必要なパッケージを入れておく。
</p>
<pre class="example">
$ sudo pacman -S valgrind
$ sudo pacman -S kdesdk-kcachegrind
</pre>

<ol class="org-ol">
<li>デバッグ版OpenJDKの出力先へ移動する
</li>
<li><code>valgrind</code> カーバーして <code>java -version</code> を実行する
</li>
<li><code>kcachegrind</code> で出力結果を解析する
</li>
</ol>

<pre class="example">
1.|$ cd src/icedtea-2.5.5/openjdk.build-debug
2.|$ valgrind --tool=callgrind bin/java -version
  |==18306== Callgrind, a call-graph generating cache profiler
  |==18306== Copyright (C) 2002-2013, and GNU GPL'd, by Josef Weidendorfer et al.
  |==18306== Using Valgrind-3.10.1 and LibVEX; rerun with -h for copyright info
  |==18306== Command: bin/java -version
  |==18306== 
  |==18306== For interactive control, run 'callgrind_control -h'.
  |java version "1.7.0_79-debug"
  |OpenJDK Runtime Environment (IcedTea 2.5.5) (Arch Linux build 7.u79_2.5.5-1-x86_64)
  |OpenJDK 64-Bit Server VM (build 24.79-b02-jvmg, mixed mode)
  |==18306== 
  |==18306== Events    : Ir
  |==18306== Collected : 1610140735
  |==18306== 
  |==18306== I   refs:      1,610,140,735
  |$ ls -al callgrind.out.*
  |-rw------- 1 akira users 5003407  5月 10 12:50 callgrind.out.18306
3.|$ kcachegrind callgrind.out.18306
</pre>

<p>
コールグラフ
</p>


<div class="figure">
<p><img src="img/20150510125343_callgrind.png" alt="20150510125343_callgrind.png" />
</p>
</div>

<p>
バッチリですね！
</p>
</div>
</div>




<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 参考</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li><a href="https://sourceware.org/gdb/onlinedocs/gdb/Variables.html">Variables - Debugging with GDB</a>
</li>
</ul>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[調査]JVMのスタックサイズについて]]></title>
    <link href="http://luozengbin.github.io/blog/2015-04-22-%5B%E8%AA%BF%E6%9F%BB%5Djvm%E3%81%AE%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E3%82%B5%E3%82%A4%E3%82%BA%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6.html"/>
    <updated>2015-04-22T00:00:00+09:00</updated>
    <id>http://luozengbin.github.io/blog/[調査]jvmのスタックサイズについて</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 環境</a></li>
<li><a href="#sec-2">2. JVMのスタック領域について</a></li>
<li><a href="#sec-3">3. Javaスレッドのスタックページ構成</a></li>
<li><a href="#sec-4">4. HotSpotの実装</a>
<ul>
<li><a href="#sec-4-1">4.1. glibc guard page</a></li>
<li><a href="#sec-4-2">4.2. HotSpot Guard Pages</a></li>
<li><a href="#sec-4-3">4.3. Normal Stack</a></li>
</ul>
</li>
<li><a href="#sec-5">5. スタックサイズの制御</a></li>
<li><a href="#sec-6">6. ulimit -sの影響範囲</a></li>
<li><a href="#sec-7">7. -Xssと-XX:ThreadStackSizeの違い</a></li>
<li><a href="#sec-8">8. 参考</a></li>
</ul>
</div>
</div>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 環境</h2>
<div class="outline-text-2" id="text-1">
<p>
本記事の内容は以下環境を前提としています。
</p>
<ul class="org-ul">
<li>GNU/Linux x86_64
</li>
<li>OpenJDK 64-Bit 1.7.0_xx
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> JVMのスタック領域について</h2>
<div class="outline-text-2" id="text-2">
<p>
<code>-Xss</code> 、 <code>-XX:ThreadStackSize</code> パラメータ値と <code>ulimit -s</code> リソースリミット制限値を混
乱している記事を見受けたため、HotSpotの中身を調べることにしました。
</p>

<p>
結論を先に、
</p>
<ul class="org-ul">
<li><code>ulimit -s</code> のスタック最大サイズ制限値は親プロセスであるJVMランチャーのみ適用される。
</li>
<li>JVMランチャーやJavaAPIから起動されたJavaスレッドのスタックサイズは  <code>-Xss</code> もしくは
<code>-XX:ThreadStackSize</code> パラメータ値が適用される。
</li>
<li>JVMランチャーから起動されたイニシャルスレッドのスタックサイズは <code>-Xss</code> パラメータの
み制御できる。
</li>
<li>JNI経由で外部からJVMにアタッチしたスレッドのスタックサイズはJVMの管理対象外である。
</li>
</ul>

<p>
<!-- more -->
</p>

<p>
JVMスタックに関して、公式のJVMスペックドキュメント (<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/">Java SE 7 Virtual Machine
Specification</a>) は次のように記載されています。
</p>

<ul class="org-ul">
<li><a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5.2">2.5.2. Java Virtual Machine Stacks</a>
<pre class="example">
Each Java Virtual Machine thread has a private Java Virtual Machine stack, created at
the same time as the thread. A Java Virtual Machine stack stores frames (§2.6). A
Java Virtual Machine stack is analogous to the stack of a conventional language such
as C: it holds local variables and partial results, and plays a part in method
invocation and return. Because the Java Virtual Machine stack is never manipulated
directly except to push and pop frames, frames may be heap allocated. The memory for
a Java Virtual Machine stack does not need to be contiguous.
</pre>
<p>
※メモ： VMスタック内のFrameはヒープ上に配置されるかも知れない。
</p>
</li>
<li><a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5.6">2.5.6. Native Method Stacks</a>
<pre class="example">
An implementation of the Java Virtual Machine may use conventional stacks,
colloquially called "C stacks," to support native methods (methods written in a
language other than the Java programming language). Native method stacks may also be
used by the implementation of an interpreter for the Java Virtual Machine's
instruction set in a language such as C. Java Virtual Machine implementations that
cannot load native methods and that do not themselves rely on conventional stacks
need not supply native method stacks. If supplied, native method stacks are typically
allocated per thread when each thread is created.
</pre>
</li>
</ul>

<p>
仕様上ではJVMに <code>Java Stack</code> と <code>Native Stack</code> ２種類のスタックメモリが定義されています。
</p>

<ul class="org-ul">
<li><code>Java Stack</code> ：Javaコード部分実行時に使われる領域
</li>
<li><code>Native Stack</code> ：はJNIライブラリを利用時に使われる領域
</li>
</ul>

<p>
以下は、JVMのメモリ論理構成イメージです。
</p>
<pre class="example">
+----------------+--------------+-------------+------------------------------------------------------+
|                |              |             |  +-----------------+  +----------+  +-------------+  |
|     Heap       |   PermGen    | Code Cache  |  | Program Counter |  |JavaStack |  |Native Stack |  |
|                |              |             |  +-----------------+  |          |  |             |  |
+----------------+--------------+-------------+                       +----------+  +-------------+  |
                                              |                       | Frame #2 |  |             |  |
                                              |                       +----------+  +-------------+  |
                                              |  &lt;&lt; Thread &gt;&gt;         | Frame #1 |  |             |  |
                                              |                       +----------+  +-------------+  |
                                              +------------------------------------------------------+
</pre>
<p>
<code>図1</code>
</p>

<p>
理論上は <code>Java Stack</code> と <code>Native Stack</code> がスレッド毎に領域が確保されいます。ただし、
実際のメモリページ構成はJDKの実装に依存するものです。
</p>

<p>
次の情報によると、HotSpotの実装は <code>Java Stack</code> と <code>Native Stack</code> が同じメモリ領域を共
有してる。
</p>

<ul class="org-ul">
<li><a href="http://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/toc.html">Troubleshooting Guide for HotSpot VM</a> の <a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/crashes.html#gbyzz">4.1.3 Crash due to Stack Overflow</a>
<pre class="example">
In the HotSpot implementation, Java methods share stack frames with C/C++ native
★~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
code, namely user native code and the virtual machine itself. Java methods generate
code that checks that stack space is available a fixed distance towards the end of
the stack so that the native code can be called without exceeding the stack
space. This distance towards the end of the stack is called “Shadow Pages.” The
size of the shadow pages is between 3 and 20 pages, depending on the platform. This
distance is tunable, so that applications with native code needing more than the
default distance can increase the shadow page size. The option to increase shadow
pages is -XX:StackShadowPages=n, where n is greater than the default stack shadow
pages for the platform.
</pre>
</li>

<li>OpenJDKの開発メーリングリストから拾った内容
<pre class="example">
The stock HotSpot VM (the one in Oracle's Java SE JDK and OpenJDK) uses the
same stack for Java and native methods for a Java thread; Java frames and
native frames can be mixed together in such a stack.
-Xss/-XX:ThreadStackSize controls the whole stack's size for Java threads.
</pre>
<p>
情報源： <a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2011-June/004272.html">What the difference between -Xss and -XX:ThreadStackSize is?</a>
</p>
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Javaスレッドのスタックページ構成</h2>
<div class="outline-text-2" id="text-3">
<p>
HotSpotの実装から見るとJVMから起動されたJavaスレッドのスタックページは次の形で構成さ
れると思います。VM内部スレッドやJITコンパイルスレッドのページ構成はまだ別です。
</p>
<pre class="example">
   --+--                         +------------------------+
     |                          /|                        |\
     |                         / |    StackRedPages       | -XX:StackRedPages=1(4Kb)
     |                        /  |                        |/
     |   HotSpot Guard Pages--   +------------------------+
     |                        \  |                        |\
     |                         \ |    StackYellowPages    | -XX:StackYellowPages=2(8Kb)
     |                          \|                        |/
     |                           +------------------------+
     |                          /|                        |\ ★Native Stackはここです★
     |                         / |    StackShadowPages    | -XX:StackShadowPages=20(80Kb)
-XX:ThreadStackSize           /  |                        |/
     |                       /   +------------------------+
     |                      /    |                        |\
     |                     /     |   +----------------+   | \
     |       Normal Stack--      |   |     Frame      |   |  \
     |                     \     |   +----------------+   |   \
     |                      \    |   |     Frame      |   |    ★Java Stackはここです★
     |                       \   |   +----------------+   |   /
     |                        \  |   |     Frame      |   |  /
     |                         \ |   +----------------+   | /
     |                          \|                        |/
   --+--                         +------------------------+
</pre>
<p>
<code>図2</code>
</p>
</div>
</div>




<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> HotSpotの実装</h2>
<div class="outline-text-2" id="text-4">
<p>
以下はHotSpotのソースコードのコメントに書かれたスタックページ構成図です。
</p>

<p>
<a href="http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/9b0ca45cd756/src/os_cpu/linux_x86/vm/os_linux_x86.cpp#l668">jdk7:hotspot/src/os_cpu/linux_x86/vm/os_linux_x86.cpp</a>
</p>
<pre class="example">
// Java thread:
//
//   Low memory addresses
//    +------------------------+
//    |                        |\  JavaThread created by VM does not have glibc
//    |    glibc guard page    | - guard, attached Java thread usually has
//    |                        |/  1 page glibc guard.
// P1 +------------------------+ Thread::stack_base() - Thread::stack_size()
//    |                        |\
//    |  HotSpot Guard Pages   | - red and yellow pages
//    |                        |/
//    +------------------------+ JavaThread::stack_yellow_zone_base()
//    |                        |\
//    |      Normal Stack      | -
//    |                        |/
// P2 +------------------------+ Thread::stack_base()
//
// Non-Java thread:
//
//   Low memory addresses
//    +------------------------+
//    |                        |\
//    |  glibc guard page      | - usually 1 page
//    |                        |/
// P1 +------------------------+ Thread::stack_base() - Thread::stack_size()
//    |                        |\
//    |      Normal Stack      | -
//    |                        |/
// P2 +------------------------+ Thread::stack_base()
//
// ** P1 (aka bottom) and size ( P2 = P1 - size) are the address and stack size returned from
//    pthread_attr_getstack()
</pre>
<p>
<code>図3</code>
</p>

<p>
図の内容によるとJavaスレッドと非Javaスレッドのスタックページ構成が異なる。
以下はJVMの非Javaスレッドのリストです。
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">スレッド名</th>
<th scope="col" class="left">説明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">VM thread</td>
<td class="left">JVM自身のコアスレッド</td>
</tr>

<tr>
<td class="left">Periodic task thread</td>
<td class="left">WatcherThreadのシングルトンインスタンス、定義的なVMタスクを実行する</td>
</tr>

<tr>
<td class="left">GC threads</td>
<td class="left">その名の通りです、メモリ管理自動化役を務める</td>
</tr>

<tr>
<td class="left">Compiler threads</td>
<td class="left">ByteCodeからアセンブラにコンパイルするスレッド</td>
</tr>

<tr>
<td class="left">Signal dispatcher thread</td>
<td class="left">外部からシグナルをハンドリングする役を務める</td>
</tr>
</tbody>
</table>

<p>
図3の各領域についてソースコードを見ながら解説していきます。
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> glibc guard page</h3>
<div class="outline-text-3" id="text-4-1">
<p>
<code>glibc guard page</code> はスタックポインタのオーバーフローを防ぐための－ガードページ。Java
スレッドには <code>HotSpot Guard Pages</code> が別途用意されているため、この領域のサイズが0であ
る。非Javaスレッドはスタック頂上位置に1ページ分のガードページが割り当てられる。以下は
その実装内容です。
</p>

<ul class="org-ul">
<li>スレッド作成時にglibcの <a href="http://linuxjm.sourceforge.jp/html/LDP_man-pages/man3/pthread_attr_setguardsize.3.html">pthread_attr_setguardsize</a> 関数にてガードページを作成してい
る

<p>
<a href="http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/9b0ca45cd756/src/os/linux/vm/os_linux.cpp#l923">jdk7/hotspot/src/os/linux/vm/os_linux.cpp#l923</a>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00cd66;">// </span><span style="color: #00cd66;">Thread start routine for all newly created threads</span>
<span style="color: #ffffff;">static</span> <span style="color: #7fffd4;">void</span> *<span style="color: #98fb98;">java_start</span>(<span style="color: #7fffd4;">Thread</span> *<span style="color: #9acd32;">thread</span>) {
    ..............
    <span style="color: #00cd66;">// </span><span style="color: #00cd66;">glibc guard page</span>
    pthread_attr_setguardsize(&amp;attr, <span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::default_guard_size(thr_type));
    ..............
}
</pre>
</div>
</li>
<li>スレッド種別によってガードページのサイズを決める

<p>
<a href="http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/9b0ca45cd756/src/os_cpu/linux_x86/vm/os_linux_x86.cpp#l662">jdk7/hotspot/src/os_cpu/linux_x86/vm/os_linux_x86.cpp#l662</a>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #7fffd4;">size_t</span> <span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::<span style="color: #98fb98;">default_guard_size</span>(<span style="color: #40e0d0;">os</span>::<span style="color: #7fffd4;">ThreadType</span> <span style="color: #9acd32;">thr_type</span>) {
  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">Creating guard page is very expensive. Java thread has HotSpot</span>
  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">guard page, only enable glibc guard page for non-Java threads.</span>
  <span style="color: #ffffff;">return</span> (thr_type == java_thread ? 0 : page_size());
}
</pre>
</div>
</li>
</ul>

<p>
<code>glibc guard page</code> の詳細について以下の情報が参考になると思います。
</p>
<ul class="org-ul">
<li><a href="http://docs.oracle.com/cd/E19455-01/806-2732/attrib-22/index.html">スタックガードの大きさの設定</a>
</li>
<li><a href="http://linuxjm.sourceforge.jp/html/LDP_man-pages/man3/pthread_attr_setguardsize.3.html">PTHREAD_ATTR_SETGUARDSIZE</a>
</li>
<li><a href="http://codezine.jp/article/detail/1970">pthreadについて（スタックサイズ）</a>
</li>
<li><a href="http://www.nminoru.jp/~nminoru/programming/stackoverflow_handling.html#get-stack-region">スタックオーバーフローのハンドリング (Stack Overflow Handling)</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> HotSpot Guard Pages</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Javaスレッドスタックオーバーフローを検出するために書き込み不可の <code>HotSpot Guard
Pages</code> 領域がスタック領域のトップ位置に設けている。また <code>HotSpot Guard Pages</code> は
<code>StackYellowPages</code> と <code>StackRedPages</code> から構成されている。
</p>

<p>
<code>StackYellowPages</code> はスタックオーバーフローの緩衝域として、余分のメモリーを割り当てま
す。 スタックポインターが <code>StackRedPages</code> まで行くとStackOverflowErrorが起きる。
</p>

<p>
以下はページの構成イメージです。
</p>
<pre class="example">
          +------------------------+
         /|                        |\
HotSpot / |    StackRedPages       | - 1ページ (4Kb)
Guard  /  |                        |/
Pages     +------------------------+
       \  |                        |\
        \ |    StackYellowPages    | - 2ページ (8Kb)
         \|                        |/
          +------------------------+
          |                        |
          |      Normal Stack      |
          |                        |
          +------------------------+
</pre>
<p>
<code>図4</code>
</p>

<p>
Linux/x86_64環境に置いて、 <code>StackYellowPages</code> と <code>StackRedPages</code> の初期値が2と1である。
それぞれの値は <code>-XX:StackYellowPages</code> と <code>-XX:StackRedPages</code> パラメータにて変更するこ
とが可能です。
</p>

<p>
下記は <code>HotSpot Guard Pages</code> の割当処理ロジックです。
</p>

<ul class="org-ul">
<li>Javaスレッド起動時のガードページ割当位置やサイズの計算処理

<p>
<a href="http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/9b0ca45cd756/src/share/vm/runtime/thread.cpp#l2257">jdk7:openjdk/hotspot/src/share/vm/runtime/thread.cpp</a>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #7fffd4;">void</span> <span style="color: #40e0d0;">JavaThread</span>::<span style="color: #98fb98;">create_stack_guard_pages</span>() {
  <span style="color: #ffffff;">if</span> (! <span style="color: #40e0d0;">os</span>::uses_stack_guard_pages() || _stack_guard_state != stack_guard_unused) <span style="color: #ffffff;">return</span>;

  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733; &#12460;&#12540;&#12489;&#12506;&#12540;&#12472;&#12398;&#20301;&#32622;&#12392;&#12469;&#12452;&#12474;&#12398;&#35336;&#31639;</span>
  <span style="color: #7fffd4;">address</span> <span style="color: #9acd32;">low_addr</span> = stack_base() - stack_size();
  <span style="color: #7fffd4;">size_t</span> <span style="color: #9acd32;">len</span> = (StackYellowPages + StackRedPages) * <span style="color: #40e0d0;">os</span>::vm_page_size();

  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733; &#12460;&#12540;&#12489;&#12506;&#12540;&#12472;&#21106;&#24403;&#20966;&#29702;&#12399;&#12503;&#12521;&#12483;&#12488;&#12501;&#12457;&#12540;&#12512;&#20381;&#23384;&#12398;&#12383;&#12417;&#12289;&#21029;&#38306;&#25968;&#12434;&#12467;&#12540;&#12523;</span>
  <span style="color: #7fffd4;">int</span> <span style="color: #9acd32;">allocate</span> = <span style="color: #40e0d0;">os</span>::allocate_stack_guard_pages();
  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">warning("Guarding at " PTR_FORMAT " for len " SIZE_FORMAT "\n", low_addr, len);</span>

  <span style="color: #ffffff;">if</span> (allocate &amp;&amp; !<span style="color: #40e0d0;">os</span>::create_stack_guard_pages((<span style="color: #7fffd4;">char</span> *) low_addr, len)) {
    warning(<span style="color: #bdb76b;">"Attempt to allocate stack guard pages failed."</span>);
    <span style="color: #ffffff;">return</span>;
  }

  <span style="color: #ffffff;">if</span> (<span style="color: #40e0d0;">os</span>::guard_memory((<span style="color: #7fffd4;">char</span> *) low_addr, len)) {
    _stack_guard_state = stack_guard_enabled;
  } <span style="color: #ffffff;">else</span> {
    warning(<span style="color: #bdb76b;">"Attempt to protect stack guard pages failed."</span>);
    <span style="color: #ffffff;">if</span> (<span style="color: #40e0d0;">os</span>::uncommit_memory((<span style="color: #7fffd4;">char</span> *) low_addr, len)) {
      warning(<span style="color: #bdb76b;">"Attempt to deallocate stack guard pages failed."</span>);
    }
  }
}
</pre>
</div>
</li>

<li>ガードページ割当処理

<p>
<a href="http://hg.openjdk.java.net/jdk7u/jdk7u60/hotspot/file/ba66650acf63/src/os/linux/vm/os_linux.cpp#l3062">jdk7u60:openjdk/hotspot/src/os/linux/vm/os_linux.cpp</a>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #7fffd4;">bool</span> <span style="color: #40e0d0;">os</span>::<span style="color: #98fb98;">pd_create_stack_guard_pages</span>(<span style="color: #7fffd4;">char</span>* <span style="color: #9acd32;">addr</span>, <span style="color: #7fffd4;">size_t</span> <span style="color: #9acd32;">size</span>) {

  <span style="color: #ffffff;">if</span> (<span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::is_initial_thread()) {
    <span style="color: #00cd66;">// </span><span style="color: #00cd66;">As we manually grow stack up to bottom inside create_attached_thread(),</span>
    <span style="color: #00cd66;">// </span><span style="color: #00cd66;">it's likely that os::Linux::initial_thread_stack_bottom is mapped and</span>
    <span style="color: #00cd66;">// </span><span style="color: #00cd66;">we don't need to do anything special.</span>
    <span style="color: #00cd66;">// </span><span style="color: #00cd66;">Check it first, before calling heavy function.</span>
    <span style="color: #7fffd4;">uintptr_t</span> <span style="color: #9acd32;">stack_extent</span> = (<span style="color: #7fffd4;">uintptr_t</span>) <span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::initial_thread_stack_bottom();
    <span style="color: #7fffd4;">unsigned</span> <span style="color: #7fffd4;">char</span> <span style="color: #9acd32;">vec</span>[1];

    <span style="color: #ffffff;">if</span> (mincore((<span style="color: #7fffd4;">address</span>)stack_extent, <span style="color: #40e0d0;">os</span>::vm_page_size(), vec) == -1) {
      <span style="color: #00cd66;">// </span><span style="color: #00cd66;">Fallback to slow path on all errors, including EAGAIN</span>
      stack_extent = (<span style="color: #7fffd4;">uintptr_t</span>) get_stack_commited_bottom(
                                    <span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::initial_thread_stack_bottom(),
                                    (<span style="color: #7fffd4;">size_t</span>)addr - stack_extent);
    }

    <span style="color: #ffffff;">if</span> (stack_extent &lt; (<span style="color: #7fffd4;">uintptr_t</span>)addr) {
      ::munmap((<span style="color: #7fffd4;">void</span>*)stack_extent, (<span style="color: #7fffd4;">uintptr_t</span>)(addr - stack_extent));
    }
  }

  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733;&#12371;&#12371;&#12363;&#12425; mmap&#12471;&#12473;&#12486;&#12512;&#12467;&#12540;&#12523;&#12364;&#30330;&#34892;&#12373;&#12428;&#12427;&#12290;</span>
  <span style="color: #00cd66;">//  </span><span style="color: #00cd66;">&#26368;&#24460;&#12398;&#24341;&#25968;&#12395;&#26360;&#12365;&#36796;&#12415;&#19981;&#21487;&#12398;&#12501;&#12521;&#12464;&#12364;&#20184;&#19982;&#12373;&#12428;&#12383;</span>
  <span style="color: #ffffff;">return</span> <span style="color: #40e0d0;">os</span>::commit_memory(addr, size, !ExecMem);
}
</pre>
</div>
</li>
</ul>

<p>
以下は <code>JBoss AS7</code> アプリケーションサーバ実行時にワーカスレッドのスタック仮想メモリ割
当状況です。
</p>

<pre class="example">
$ cat /proc/`ps -ef | grep [j]boss.modules.system | awk '{print $2}'`/smaps
...省略...
7ff751076000-7ff751079000 ---p 00000000 00:00 0
Size:                 12 kB    ★説明: StackRedPages(4Kb) + StackYellowPages(8Kb) = 12Kb
Rss:                   0 kB
Pss:                   0 kB
Shared_Clean:          0 kB
Shared_Dirty:          0 kB
Private_Clean:         0 kB
Private_Dirty:         0 kB
Referenced:            0 kB
Anonymous:             0 kB
AnonHugePages:         0 kB
Swap:                  0 kB
KernelPageSize:        4 kB
MMUPageSize:           4 kB
Locked:                0 kB
VmFlags: mr mw me ac          ★説明:書き込み不可
7ff751079000-7ff751177000 rw-p 00000000 00:00 0                          [stack:21275]
Size:               1016 kB   ★説明: ここからNormal Stackページ
Rss:                 108 kB
Pss:                 108 kB
Shared_Clean:          0 kB
Shared_Dirty:          0 kB
Private_Clean:         0 kB
Private_Dirty:       108 kB
Referenced:          108 kB
Anonymous:           108 kB
AnonHugePages:         0 kB
Swap:                  0 kB
KernelPageSize:        4 kB
MMUPageSize:           4 kB
Locked:                0 kB
VmFlags: rd wr mr mw me ac
...省略...
</pre>

<p>
次のSystemTapスクリプトで <code>HotSpot Guard Pages</code> の割当処理をトレースしてみた。
</p>

<p>
<code>jvm_memory_trace.stp</code>
</p>
<pre class="example">
#!/usr/bin/stap -p4
probe process("/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/server/libjvm.so").function("commit_memory_impl")
{
   printf("---------------------------------------------------------\n")
   printf("%d\t%s\n", tid(), $$parms)
   print_ustack(ubacktrace())
}
</pre>

<p>
出力結果
</p>
<pre class="example">
  |$ stap jvm_memory_trace.stp -c "java  -version"
  |Using a compile server.
  |WARNING: Missing unwind data for module, rerun with 'stap -d ...dk-1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/jli/libjli.so'
  |WARNING: Missing unwind data for module, rerun with 'stap -d /usr/lib64/libpthread-2.17.so'
  |java version "1.7.0_75"
  |OpenJDK Runtime Environment (rhel-2.5.4.7.el7_1-x86_64 u75-b13)
  |OpenJDK 64-Bit Server VM (build 24.75-b04, mixed mode)
  |
  |★省略★
  |--------------------------------------------------------------------------------------------------------------
①|12179   exec=0x0 size=0x3000 addr=0x7f1d05b57000  ★commit_memory_impl関数実行時の引数情報
  | 0x7f1d04808371 : _ZN2os16pd_commit_memoryEPcmb+0x1/0xf0 [...1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/server/libjvm.so]
  | 0x7f1d04802dee : _ZN2os13commit_memoryEPcmb+0x2e/0xd0 [...1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/server/libjvm.so]
②| 0x7f1d048092df : _ZN2os27pd_create_stack_guard_pagesEPcm+0x7f/0x180 [...1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/server/libjvm.so]
  | 0x7f1d04945519 : _ZN7Threads9create_vmEP14JavaVMInitArgsPb+0x339/0x1550 [...1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/server/libjvm.so]
  | 0x7f1d0463fca7 : JNI_CreateJavaVM+0x67/0x2a0 [...1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/server/libjvm.so]
  | 0x7f1d0562aa68 : 0x7f1d0562aa68 [...dk-1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/jli/libjli.so+0x2a68/0x20e000]
  |--------------------------------------------------------------------------------------------------------------
  |★以降省略★
</pre>

<p>
出力結果に①の <a href="http://hg.openjdk.java.net/jdk7u/jdk7u60/hotspot/file/ba66650acf63/src/os/linux/vm/os_linux.cpp#l2728">commit_memory_impl</a> 仮想メモリ割当処理の第２引数にメモリサイズを指定し
ています。 <code>size=0x3000</code> の値が16進数ですので、10進数に変換すると12Kbです。予測通りで
すね。
</p>

<p>
gdbを用いて上記出力結果から②のソースコード位置を特定する方法を以下に示す。
</p>
<pre class="example">
$ gdb /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/server/libjvm.so
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-64.el7
★一部内容省略★
Reading symbols from /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/server/libjvm.so...Reading symbols from /usr/lib/debug/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/server/libjvm.so.debug...done.
done.
★出力結果から関数名ぽいの文字列で関数を探す
(gdb) info functions pd_create_stack_guard_pages
All functions matching regular expression "pd_create_stack_guard_pages":

★検索結果
File /usr/src/debug/java-1.7.0-openjdk-1.7.0.75-2.5.4.7.el7_1.x86_64/openjdk/hotspot/src/os/linux/vm/os_linux.cpp:
bool os::pd_create_stack_guard_pages(char*, unsigned long);
(gdb)
</pre>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> Normal Stack</h3>
<div class="outline-text-3" id="text-4-3">
<p>
Javaスレッドを前提に置いて、 <code>Normal Stack</code> には通常Javaメソッド実行時のフレーム情報
が格納される。ただし、スレッドからC/C++メソッドを実行する時も <code>Normal Stack</code> が利用さ
れる。スタックのトップ位置にC/C++メソッド実行用の <code>StackShadowPages</code> が設けられている。
Linux/x86_64環境に置いて <code>StackShadowPages</code> の初期値が20である。
</p>

<pre class="example">
              +------------------------+
             /|                        |\
            / |    StackShadowPages    | -XX:StackShadowPages=20(80Kb)
           /  |                        |/ ★Native Stackはここです!
          /   +------------------------+
         /    |                        |\
        /     |   +----------------+   | \ 
Normal Stack  |   |     Frame      |   |  \
        \     |   +----------------+   |   \
         \    |   |     Frame      |   |    - ★Java Stackはここです！
          \   |   +----------------+   |   /
           \  |   |     Frame      |   |  /
            \ |   +----------------+   | /
             \|                        |/
              +------------------------+
</pre>
<p>
<code>図5</code>
</p>

<p>
以下は <code>StackShadowPages</code> 初期値の代入処理ロジックです。
</p>

<p>
<a href="http://hg.openjdk.java.net/jdk7u/jdk7u60/hotspot/file/ba66650acf63/src/cpu/x86/vm/globals_x86.hpp#l60">jdk7:hotspot/src/cpu/x86/vm/globals_x86.hpp#l60</a>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#ifdef</span> AMD64
<span style="color: #00cd66;">// </span><span style="color: #00cd66;">Very large C++ stack frames using solaris-amd64 optimized builds</span>
<span style="color: #00cd66;">// </span><span style="color: #00cd66;">due to lack of optimization caused by C++ compiler bugs</span>
define_pd_global(intx, StackShadowPages, NOT_WIN64(20) WIN64_ONLY(6) DEBUG_ONLY(+2));
<span style="color: #b0c4de;">#else</span>
define_pd_global(intx, StackShadowPages, 6 DEBUG_ONLY(+5));
<span style="color: #b0c4de;">#endif</span> <span style="color: #00cd66;">// </span><span style="color: #00cd66;">AMD64</span>
</pre>
</div>

<p>
<code>StackShadowPages</code> に関して以下の情報が参考になると思います。
</p>
<ul class="org-ul">
<li><a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/crashes.html#gbyzz">Troubleshooting Guide for HotSpot VM 4.1.3 Crash due to Stack Overflow</a>
</li>
<li><a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=7059899a">JDK-7059899 : Stack overflows in Java code cause 64-bit JVMs to exit due to SIGSEGV</a>
</li>
<li><a href="https://access.redhat.com/solutions/698483">What does the StackShadowPages JVM setting do?</a>
<pre class="example">
StackShadowPages reserves a portion of the thread stack for native layer
allocations. The page size usually is 4096b, which mean that 20 pages would occupy
80Kb. The thread stack is sized through -Xss.

Consider some config examples:

   -Xss1024k -XX:StackShadowPages=10

   [       984kb java stack    | 40kb native stack]

   -Xss1024k -XX:StackShadowPages=20

   [       944kb java stack    |   80kb native stack]

   -Xss512k -XX:StackShadowPages=10

   [ 472kb java stack | 40kb native stack]

If you decrease just -Xss, the overall stack is decreased, but the StackShadowPages
native reservation is not; only the java portion would lose space. Likewise if you
only increase -Xss, only the java portion gains space with the increased stack.

If you increase StackShadowPages, the java portion becomes smaller so that the native
portion can be larger. If the native portion of a stack is exhausted, the JVM can
fatally crash so sometimes StackShadowPages needs to be increased.
</pre>
</li>
</ul>
</div>
</div>
</div>




<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> スタックサイズの制御</h2>
<div class="outline-text-2" id="text-5">
<p>
従いましてJava Methodに使えるスタック領域(Java Stack)のサイズは次の式で計算出来る。
</p>
<font color="red"><strong>
<p>
Java Satck Size = Thread::stack_size() - ((StackRedPages + StackYellowPages + StackShadowPages) * PageSize)
</p>
</strong></font>

<p>
<code>Thread::stack_size()</code> の値はスレッド起動時にglibcの <a href="http://linuxjm.sourceforge.jp/html/LDP_man-pages/man3/pthread_attr_setstacksize.3.html">pthread_attr_setstacksize</a> 関数を
用いて設定される。以下はHotSpotの実装です。
</p>

<ul class="org-ul">
<li>JVM起動時に実行される処理
<a href="http://hg.openjdk.java.net/jdk7u/jdk7u60/hotspot/file/ba66650acf63/src/os/linux/vm/os_linux.cpp#l4820">jdk7/hotspot/src/os/linux/vm/os_linux.cpp#4820</a>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00cd66;">// </span><span style="color: #00cd66;">this is called _after_ the global arguments have been parsed</span>
<span style="color: #7fffd4;">jint</span> <span style="color: #40e0d0;">os</span>::<span style="color: #98fb98;">init_2</span>(<span style="color: #7fffd4;">void</span>)
{
  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733;&#19968;&#37096;&#30465;&#30053;&#9733;</span>


  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733;&#12473;&#12524;&#12483;&#12489;&#12395;&#21106;&#24403;&#12427;&#12473;&#12479;&#12483;&#12463;&#12469;&#12452;&#12474;&#12398;&#26368;&#23567;&#35377;&#23481;&#20516;&#12398;&#35336;&#31639;</span>

  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">Check minimum allowable stack size for thread creation and to initialize</span>
  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">the java system classes, including StackOverflowError - depends on page</span>
  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">size.  Add a page for compiler2 recursion in main thread.</span>
  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">Add in 2*BytesPerWord times page size to account for VM stack during</span>
  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">class initialization depending on 32 or 64 bit VM.</span>
  <span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::min_stack_allowed = MAX2(<span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::min_stack_allowed,
            (<span style="color: #7fffd4;">size_t</span>)(StackYellowPages+StackRedPages+StackShadowPages) * <span style="color: #40e0d0;">Linux</span>::page_size() +
                    (2*BytesPerWord COMPILER2_PRESENT(+1)) * <span style="color: #40e0d0;">Linux</span>::vm_default_page_size());

<span style="color: #b0c4de;">#ifdef</span> ZERO
  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">If this is Zero, allow at the very minimum one page each for the</span>
  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">Zero stack and the native stack.  This won't make any difference</span>
  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">for 4k pages, but is significant for large pages.</span>
  <span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::min_stack_allowed = MAX2(<span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::min_stack_allowed,
             (<span style="color: #7fffd4;">size_t</span>)(StackYellowPages+StackRedPages+StackShadowPages+2) * <span style="color: #40e0d0;">Linux</span>::page_size());
<span style="color: #b0c4de;">#endif</span>

  <span style="color: #7fffd4;">size_t</span> <span style="color: #9acd32;">threadStackSizeInBytes</span> = ThreadStackSize * K;
  <span style="color: #ffffff;">if</span> (threadStackSizeInBytes != 0 &amp;&amp;
      threadStackSizeInBytes &lt; <span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::min_stack_allowed) {
        tty-&gt;print_cr(<span style="color: #bdb76b;">"\nThe stack size specified is too small, "</span>
                      <span style="color: #bdb76b;">"Specify at least %dk"</span>,
                      <span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::min_stack_allowed/ K);
        <span style="color: #ffffff;">return</span> JNI_ERR;
  }

  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733;-XX:ThreadStackSize&#12398;&#20516;&#12434;&#38745;&#30340;_stack_size_at_create&#22793;&#25968;&#12395;&#20195;&#20837;&#12377;&#12427;</span>
  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">Make the stack size a multiple of the page size so that</span>
  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">the yellow/red zones can be guarded.</span>
  <span style="color: #40e0d0;">JavaThread</span>::set_stack_size_at_create(round_to(threadStackSizeInBytes,
        vm_page_size()));

  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733;&#12452;&#12491;&#12471;&#12515;&#12523;&#12473;&#12524;&#12483;&#12489;&#12398;&#12473;&#12479;&#12483;&#12463;&#12469;&#12452;&#12474;&#35373;&#23450;&#20966;&#29702;&#65288;&#9733;TODO: &#21029;&#36884;&#35519;&#26619;&#12377;&#12427;&#65289;</span>
  <span style="color: #40e0d0;">Linux</span>::capture_initial_stack(<span style="color: #40e0d0;">JavaThread</span>::stack_size_at_create());

  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733;&#20197;&#38477;&#30465;&#30053;&#9733;</span>
</pre>
</div>
</li>
<li>新規スレッド起動時の処理
<a href="http://hg.openjdk.java.net/jdk7u/jdk7u60/hotspot/file/ba66650acf63/src/os/linux/vm/os_linux.cpp#l901">jdk7:hotspot/src/os/linux/vm/os_linux.cpp#901</a>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #7fffd4;">bool</span> <span style="color: #40e0d0;">os</span>::<span style="color: #98fb98;">create_thread</span>(<span style="color: #7fffd4;">Thread</span>* <span style="color: #9acd32;">thread</span>, <span style="color: #7fffd4;">ThreadType</span> <span style="color: #9acd32;">thr_type</span>, <span style="color: #7fffd4;">size_t</span> <span style="color: #9acd32;">stack_size</span>) {

  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733;&#19968;&#37096;&#30465;&#30053;&#9733;</span>

  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733;&#12473;&#12524;&#12483;&#12489;&#31278;&#21029;&#27598;&#12395;&#12473;&#12479;&#12483;&#12463;&#12469;&#12452;&#12474;&#12434;&#27770;&#12417;&#12427;</span>
  <span style="color: #ffffff;">if</span> (<span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::supports_variable_stack_size()) {
    <span style="color: #00cd66;">// </span><span style="color: #00cd66;">calculate stack size if it's not specified by caller</span>
    <span style="color: #ffffff;">if</span> (stack_size == 0) {
      stack_size = <span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::default_stack_size(thr_type);

      <span style="color: #ffffff;">switch</span> (thr_type) {

      <span style="color: #00cd66;">//</span><span style="color: #00cd66;">&#9733;Java&#12527;&#12540;&#12459;&#12473;&#12524;&#12483;&#12489;&#12398;&#22580;&#21512;</span>
      <span style="color: #ffffff;">case</span> <span style="color: #40e0d0;">os</span>::java_thread:
        <span style="color: #00cd66;">// </span><span style="color: #00cd66;">Java threads use ThreadStackSize which default value can be</span>
        <span style="color: #00cd66;">// </span><span style="color: #00cd66;">changed with the flag -Xss</span>
        assert (<span style="color: #40e0d0;">JavaThread</span>::stack_size_at_create() &gt; 0, <span style="color: #bdb76b;">"this should be set"</span>);
        stack_size = <span style="color: #40e0d0;">JavaThread</span>::stack_size_at_create();
        <span style="color: #ffffff;">break</span>;

      <span style="color: #00cd66;">//</span><span style="color: #00cd66;">&#9733;JIT&#12467;&#12531;&#12497;&#12452;&#12521;&#12473;&#12524;&#12483;&#12489;&#12398;&#22580;&#21512;</span>
      <span style="color: #ffffff;">case</span> <span style="color: #40e0d0;">os</span>::compiler_thread:
        <span style="color: #ffffff;">if</span> (CompilerThreadStackSize &gt; 0) {
          stack_size = (<span style="color: #7fffd4;">size_t</span>)(CompilerThreadStackSize * K);
          <span style="color: #ffffff;">break</span>;
        } <span style="color: #00cd66;">// </span><span style="color: #00cd66;">else fall through:</span>
          <span style="color: #00cd66;">// </span><span style="color: #00cd66;">use VMThreadStackSize if CompilerThreadStackSize is not defined</span>

      <span style="color: #00cd66;">//</span><span style="color: #00cd66;">&#9733;VM&#12473;&#12524;&#12483;&#12489;&#12289;GC&#12473;&#12524;&#12483;&#12489;&#12289;&#12454;&#12457;&#12483;&#12481;&#12515;&#12540;&#12473;&#12524;&#12483;&#12489;&#12398;&#22580;&#21512;</span>
      <span style="color: #ffffff;">case</span> <span style="color: #40e0d0;">os</span>::vm_thread:
      <span style="color: #ffffff;">case</span> <span style="color: #40e0d0;">os</span>::pgc_thread:
      <span style="color: #ffffff;">case</span> <span style="color: #40e0d0;">os</span>::cgc_thread:
      <span style="color: #ffffff;">case</span> <span style="color: #40e0d0;">os</span>::watcher_thread:
        <span style="color: #ffffff;">if</span> (VMThreadStackSize &gt; 0) stack_size = (<span style="color: #7fffd4;">size_t</span>)(VMThreadStackSize * K);
        <span style="color: #ffffff;">break</span>;
      }
    }

    stack_size = MAX2(stack_size, <span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::min_stack_allowed);
    <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733;glic&#38306;&#25968;&#29992;&#12356;&#12390;stack&#38936;&#22495;&#12434;&#30906;&#20445;&#12377;&#12427;</span>
    pthread_attr_setstacksize(&amp;attr, stack_size);

    <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733;&#20197;&#38477;&#30465;&#30053;&#9733;</span>
</pre>
</div>
</li>
</ul>

<p>
以上コードの通り、JVMから起動されたスレッドの種別毎のスタックサイズが下記XXパラメータ値が適用されてい
る。
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">引数</th>
<th scope="col" class="left">Linux/x86_64環境初期値</th>
<th scope="col" class="left">適用範囲</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">-XX:ThreadStackSize</td>
<td class="left">1M</td>
<td class="left">Javaスレッド</td>
</tr>

<tr>
<td class="left">-XX:VMThreadStackSize</td>
<td class="left">1M</td>
<td class="left">VM thread、GC threads、VM Periodic Task Threadなど</td>
</tr>

<tr>
<td class="left">-XX:CompilerThreadStackSize</td>
<td class="left">4M</td>
<td class="left">C1 C2 CompilerThread</td>
</tr>
</tbody>
</table>

<p>
以下は実機にて確認された各パラメータの初期値です。
</p>
<pre class="example">
$ java -XX:+PrintFlagsFinal -version | grep -e "CompilerThreadStackSize\|ThreadStackSize\|VMThreadStackSize"
     intx CompilerThreadStackSize                   = 0               {pd product}
     intx ThreadStackSize                           = 1024            {pd product}
     intx VMThreadStackSize                         = 1024            {pd product}
java version "1.7.0_75"
OpenJDK Runtime Environment (rhel-2.5.4.7.el7_1-x86_64 u75-b13)
OpenJDK 64-Bit Server VM (build 24.75-b04, mixed mode)
</pre>

<p>
<code>CompilerThreadStackSize</code> が指定しない場合下記コードにて初期値が代入される。
</p>

<p>
<a href="http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/9b0ca45cd756/src/os_cpu/linux_x86/vm/os_linux_x86.cpp#l652">jdk7:hotspot/src/os_cpu/linux_x86/vm/os_linux_x86.cpp#652</a>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00cd66;">// </span><span style="color: #00cd66;">return default stack size for thr_type</span>
<span style="color: #7fffd4;">size_t</span> <span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::<span style="color: #98fb98;">default_stack_size</span>(<span style="color: #40e0d0;">os</span>::<span style="color: #7fffd4;">ThreadType</span> <span style="color: #9acd32;">thr_type</span>) {
  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">default stack size (compiler thread needs larger stack)</span>
<span style="color: #b0c4de;">#ifdef</span> AMD64
  <span style="color: #7fffd4;">size_t</span> <span style="color: #9acd32;">s</span> = (thr_type == <span style="color: #40e0d0;">os</span>::compiler_thread ? 4 * M : 1 * M);
<span style="color: #b0c4de;">#else</span>
  <span style="color: #7fffd4;">size_t</span> <span style="color: #9acd32;">s</span> = (thr_type == <span style="color: #40e0d0;">os</span>::compiler_thread ? 2 * M : 512 * K);
<span style="color: #b0c4de;">#endif</span> <span style="color: #00cd66;">// </span><span style="color: #00cd66;">AMD64</span>
  <span style="color: #ffffff;">return</span> s;
}
</pre>
</div>

<p>
次のサンプルプログラムを実行して、各スレッドのスタックサイズ値を実測してみる。
</p>

<p>
<code>HelloWorld.java</code>
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ffffff;">public</span> <span style="color: #ffffff;">class</span> <span style="color: #7fffd4;">HelloWorld</span> <span style="color: #ffffff;">implements</span> <span style="color: #7fffd4;">Runnable</span> {

    <span style="color: #ffffff;">public</span> <span style="color: #7fffd4;">void</span> <span style="color: #98fb98;">run</span>(){
        <span style="color: #ffffff;">while</span>(<span style="color: #40e0d0;">true</span>) {
            <span style="color: #ffffff;">try</span> {
                Thread.sleep(1 * 1000L);
                System.out.println(Thread.currentThread().toString() + <span style="color: #bdb76b;">": Hello World"</span>);
            } <span style="color: #ffffff;">catch</span> (<span style="color: #7fffd4;">Exception</span> <span style="color: #9acd32;">e</span>) {
            }
        }
    }

    <span style="color: #ffffff;">public</span> <span style="color: #ffffff;">static</span> <span style="color: #7fffd4;">void</span> <span style="color: #98fb98;">main</span>(<span style="color: #7fffd4;">String</span>[] <span style="color: #9acd32;">args</span>) <span style="color: #ffffff;">throws</span> <span style="color: #7fffd4;">Exception</span> {
        <span style="color: #7fffd4;">Thread</span>[] <span style="color: #9acd32;">t_arry</span> =  <span style="color: #ffffff;">new</span> <span style="color: #7fffd4;">Thread</span>[5];
        <span style="color: #ffffff;">for</span> (<span style="color: #7fffd4;">int</span> <span style="color: #9acd32;">i</span> = 0; i &lt; t_arry.<span style="color: #7fffd4;">length</span>; i++) {
            t_arry[i]  =  <span style="color: #ffffff;">new</span> <span style="color: #7fffd4;">Thread</span>(<span style="color: #ffffff;">new</span> <span style="color: #7fffd4;">HelloWorld</span>());
            t_arry[i].start();
        }
        <span style="color: #ffffff;">for</span> (<span style="color: #7fffd4;">int</span> <span style="color: #9acd32;">i</span> = 0; i &lt; t_arry.<span style="color: #7fffd4;">length</span>; i++) {
            t_arry[i].join();
        }

    }
}
</pre>
</div>

<p>
スタックサイズの実測値は次のスクリプトで取得しています。
</p>

<p>
<code>jvm_stacksize.sh</code>
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #00cd66;">#</span><span style="color: #00cd66;">!/bin/</span><span style="color: #ffffff;">sh</span>

<span style="color: #ffffff;">if</span> [ ! $<span style="color: #9acd32;">#</span> -eq 1 ]; <span style="color: #ffffff;">then</span>
    <span style="color: #b0c4de;">echo</span> <span style="color: #bdb76b;">"Usage ${0} &lt;JVM PID&gt;"</span>
    <span style="color: #ffffff;">exit</span> 1
<span style="color: #ffffff;">fi</span>

<span style="color: #b0c4de;">printf</span> <span style="color: #bdb76b;">"[ PID ]\t[StackSize]\t[GuardPages]\t[Thread Name]\n"</span>

<span style="color: #00cd66;"># </span><span style="color: #00cd66;">jstack&#12398;&#20986;&#21147;&#32080;&#26524;&#12363;&#12425;&#12473;&#12524;&#12483;&#12489;ID&#12392;&#21517;&#21069;&#12434;&#25277;&#20986;&#12377;&#12427;</span>
jstack $<span style="color: #9acd32;">1</span> | grep nid | sed -e <span style="color: #bdb76b;">"s/^\"\(.*\)\".*nid=\(0x[0-9|a-z]*\).*$/\2,\1/"</span> | sort | <span style="color: #ffffff;">while </span><span style="color: #b0c4de;">read</span> line
<span style="color: #ffffff;">do</span>
    <span style="color: #00cd66;"># </span><span style="color: #00cd66;">&#12473;&#12524;&#12483;&#12489;ID&#12434;&#20999;&#12426;&#20986;&#12377;</span>
    <span style="color: #9acd32;">pid_hex</span>=<span style="color: #fa8072;">`echo "${line}" | awk -F"," '{print $1}'`</span>

    <span style="color: #00cd66;"># </span><span style="color: #00cd66;">&#12473;&#12524;&#12483;&#12489;&#21517;&#12434;&#20999;&#12426;&#20986;&#12377;</span>
    <span style="color: #9acd32;">thread_name</span>=<span style="color: #fa8072;">`echo "${line}" | awk -F"," '{print $2}'`</span>

    <span style="color: #00cd66;"># </span><span style="color: #00cd66;">&#12473;&#12524;&#12483;&#12489;ID&#12434;10&#36914;&#25968;&#12395;&#22793;&#25563;</span>
    <span style="color: #9acd32;">pid</span>=<span style="color: #fa8072;">`printf '%d\n' ${pid_hex}`</span>

    <span style="color: #00cd66;"># </span><span style="color: #00cd66;">/proc/&lt;pid&gt;/smaps &#12501;&#12449;&#12452;&#12523;&#12363;&#12425;&#12473;&#12479;&#12483;&#12463;&#12469;&#12452;&#12474;&#12289;&#12460;&#12540;&#12489;&#12506;&#12540;&#12472;&#12469;&#12452;&#12474;&#12434;&#21462;&#24471;&#12377;&#12427;</span>
    <span style="color: #9acd32;">guard_page</span>=<span style="color: #fa8072;">`cat /proc/$1/smaps | grep -B15 "stack:${pid}"| head -1 | awk '{print $2}'`</span>
    <span style="color: #9acd32;">stack_page</span>=<span style="color: #fa8072;">`cat /proc/$1/smaps | grep -A1 "stack:${pid}" | tail -1 | awk '{print $2}'`</span>
    <span style="color: #9acd32;">stack_size</span>=<span style="color: #fa8072;">`expr ${guard_page} + ${stack_page}`</span>
    <span style="color: #b0c4de;">printf</span> <span style="color: #bdb76b;">"%7d\t%11s\t%12s\t%s\n"</span> <span style="color: #bdb76b;">"${pid}"</span> <span style="color: #bdb76b;">"${stack_size}Kb"</span> <span style="color: #bdb76b;">"${guard_page}Kb"</span> <span style="color: #bdb76b;">"${thread_name}"</span>
<span style="color: #ffffff;">done</span>
</pre>
</div>

<p>
スタックサイズを明示的に指定して、サンプルを実行する。
</p>
<ul class="org-ul">
<li>-XX:ThreadStackSize=512
</li>
<li>-XX:VMThreadStackSize: 2048
</li>
<li>-XX:CompilerThreadStackSize=3072
</li>
</ul>
<pre class="example">
java -XX:VMThreadStackSize=2048 -XX:CompilerThreadStackSize=3072 -XX:ThreadStackSize=512 HelloWorld
Thread[Thread-0,5,main]: Hello World
Thread[Thread-4,5,main]: Hello World
Thread[Thread-1,5,main]: Hello World
Thread[Thread-3,5,main]: Hello World
Thread[Thread-2,5,main]: Hello World
★以降は省略
</pre>

<p>
測定結果
</p>
<pre class="example">
$ ./jvm_stacksize.sh `ps -ef | grep "[j]ava.*HelloWorld" | awk '{print $2}'`
[ PID ] [StackSize] [GuardPages]    [Thread Name]
  17285      1048Kb         12Kb    main
  17286      2096Kb          4Kb    GC task thread#0 (ParallelGC)
  17287      2052Kb          4Kb    GC task thread#1 (ParallelGC)
  17288      2052Kb          4Kb    GC task thread#2 (ParallelGC)
  17289      2052Kb          4Kb    GC task thread#3 (ParallelGC)
  17290      2052Kb          4Kb    VM Thread
  17291     64584Kb         12Kb    Reference Handler
  17292       516Kb         12Kb    Finalizer
  17293       516Kb         12Kb    Signal Dispatcher
  17294      3076Kb         12Kb    C2 CompilerThread0
  17295      3076Kb         12Kb    C2 CompilerThread1
  17296       516Kb         12Kb    Service Thread
  17297      2052Kb          4Kb    VM Periodic Task Thread
  17298       516Kb         12Kb    Thread-0
  17299       516Kb         12Kb    Thread-1
  17300       516Kb         12Kb    Thread-2
  17301       516Kb         12Kb    Thread-3
  17302       516Kb         12Kb    Thread-4
  17342       516Kb         12Kb    Attach Listener
</pre>

<p>
実測値はXXパラメータで指定した値より１ページ分多い。これは <code>glibc</code> 内部の
<a href="https://www.sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=nptl/allocatestack.c;h=8e620c46e9523092a5cf141e77f35c94dcfd9810;hb=HEAD#l349">allocate_stack</a> 処理で追加されているものです。
</p>
</div>
</div>




<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> ulimit -sの影響範囲</h2>
<div class="outline-text-2" id="text-6">
<p>
Linux環境に置いて、JVM内のスレッドは全てglibcの <code>pthread_create</code> 関数経由で起動される。
スレッド起動時にスタックサイズ明示的に指定していない場合、 <code>ulimit -s</code> で設定された値
がスタックのデフォルトサイズとして適用される。前文に書いた通りJVMはスレッド起動時に明
示的 <code>pthread_attr_setstacksize</code> 関数でXXパラメータ値の元にスタックサイズを指定してい
るため、これらのスレッドのスタックサイズは <code>ulimit -s</code> の値に影響されないだ。
</p>

<p>
ただし、JVMランチャー自身は <code>ulimit -s</code> の制限値が適用される。
</p>

<p>
<code>ulimit</code> コマンドでスタックの上限値 <code>RLIMIT_STACK</code> を64Kbを設定し、サンプルプログラム
グライムを実行すると、ランチャーのスタックサイズが60Kbで収まった。
</p>
<pre class="example">
$ ulimit -s 64
$ java -Xss1024K -XX:VMThreadStackSize=2048 -XX:CompilerThreadStackSize=3072 -XX:ThreadStackSize=512 HelloWorld
Thread[Thread-1,5,main]: Hello World
Thread[Thread-3,5,main]: Hello World
Thread[Thread-0,5,main]: Hello World
Thread[Thread-2,5,main]: Hello World
Thread[Thread-4,5,main]: Hello World
★省略
</pre>

<p>
<code>pmap</code> コマンドで仮想メモリマップの最上位アドレス近くにランチャーのスタックサイズを確
認することができる。
</p>
<pre class="example">
$ pmap `ps -ef | grep "[j]ava.*HelloWorld" | awk '{print $2}'`
★省略
00007f39d068d000      4K r---- ld-2.17.so
00007f39d068e000      4K rw--- ld-2.17.so
00007f39d068f000      4K rw---   [ anon ]
00007fff7cf79000     60K rw---   [ stack ] ★ランチャーのスタックサイズ
00007fff7cffe000      8K r-x--   [ anon ]
ffffffffff600000      4K r-x--   [ anon ]
 total          3513684K
</pre>

<p>
JVM内の各スレッドのスタックサイズは下記の通りです、 <code>RLIMIT_STACK</code> に影響されていない
ことが分かります。
</p>
<pre class="example">
]$ ./jvm_stacksize.sh `ps -ef | grep "[j]ava.*HelloWorld" | awk '{print $2}'`
[ PID ] [StackSize] [GuardPages]    [Thread Name]
  10770      1048Kb         12Kb    main
  10771      2096Kb          4Kb    GC task thread#0 (ParallelGC)
  10772      2052Kb          4Kb    GC task thread#1 (ParallelGC)
  10773      2052Kb          4Kb    GC task thread#2 (ParallelGC)
  10774      2052Kb          4Kb    GC task thread#3 (ParallelGC)
  10775     15812Kb          4Kb    VM Thread
  10776       516Kb         12Kb    Reference Handler
  10777     63556Kb         12Kb    Finalizer
  10778       516Kb         12Kb    Signal Dispatcher
  10779      3076Kb         12Kb    C2 CompilerThread0
  10780      3076Kb         12Kb    C2 CompilerThread1
  10781       516Kb         12Kb    Service Thread
  10782      2052Kb          4Kb    VM Periodic Task Thread
  10783       516Kb         12Kb    Thread-0
  10784       516Kb         12Kb    Thread-1
  10785       516Kb         12Kb    Thread-2
  10786       516Kb         12Kb    Thread-3
  10787       516Kb         12Kb    Thread-4
  11203       516Kb         12Kb    Attach Listener
</pre>
</div>
</div>




<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> -Xssと-XX:ThreadStackSizeの違い</h2>
<div class="outline-text-2" id="text-7">
<p>
<code>-Xss</code> と <code>-XX:ThreadStackSize</code> 両方ともJavaスレッドのスタックを指定するパラメータで
ある。 ただし、JVMランチャーから起動されたイニシャルスレッドのスタックサイズの制御は
<code>-Xss</code> パラメータのみできる。
</p>

<p>
以下はJVMランチャーからイニシャルスレッド起動するまでの流れ
</p>
<pre class="example">
行
 | ★ランチャーの実行
1| openjdk/jdk/src/share/bin/main.c:93           ==&gt; int main(int, char **);
2| openjdk/jdk/src/share/bin/java.c:170            ==&gt; int JLI_Launch(int, char **, int, const char **, int, const char **, const char *, const char *, const char *, const char *, jboolean, jboolean, jboolean, jint);
3| openjdk/jdk/src/share/bin/java.c:1835             ==&gt; int ContinueInNewThread(InvocationFunctions *, jlong, int, char **, int, char *, int);
 | ★イニシャルスレッド起動
4| openjdk/jdk/src/solaris/bin/java_md_solinux.c:1021  ==&gt; int ContinueInNewThread0(int (JNICALL *continuation)(void *), jlong stack_size, void * args)
5| openjdk/jdk/src/share/bin/java.c:337                  ==&gt; int JavaMain(void *);
 | openjdk/jdk/src/share/bin/java.c:1097                 ==&gt; jboolean InitializeJVM(JavaVM **pvm, JNIEnv **penv, InvocationFunctions *ifn)
6| openjdk/hotspot/src/share/vm/prims/jni.cpp            ==&gt; jint JNI_CreateJavaVM(JavaVM**, void**, void*);
7| openjdk/hotspot/src/share/vm/runtime/thread.cpp:3271    ==&gt; jint Threads::create_vm(JavaVMInitArgs*, bool*);
8| openjdk/hotspot/src/os/linux/vm/os_linux.cpp:4898         ==&gt; jint os::init_2(void)
9| openjdk/hotspot/src/os/linux/vm/os_linux.cpp:1205           ==&gt; void os::Linux::capture_initial_stack(size_t max_size)
</pre>

<ul class="org-ul">
<li>行1: JVMランチャーのmain関数
</li>
<li>行2: <code>JLI_Launch</code> 関数にてコマンドラインパラメータのパーシング処理が実行される。
</li>
<li>行3: <code>-Xss</code> パラメータが指定されていない場合、デフォルト値(1024Kb)を取得し(4)に渡す。
</li>
<li>行4: glibcの <code>pthread_create</code> 関数を用いてイニシャルスレッドを起動する。 <code>-Xss</code> の
値がスタックサイズに適用される。
</li>
</ul>

<p>
<code>-Xss</code> と <code>-XX:ThreadStackSize</code> 片方指定する場合、と両方指定する場合効果が違うので要注意です。
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">&#xa0;</th>
<th scope="col" class="left">イニシャルスレッド</th>
<th scope="col" class="left">ワーカスレッド</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">-Xss2048K</td>
<td class="left">2048K</td>
<td class="left">2048K</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">-XX:ThreadStackSize=2048</td>
<td class="left">1024K</td>
<td class="left">2048K</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">-Xss2048K</td>
<td class="left">2048K</td>
<td class="left">512K</td>
</tr>

<tr>
<td class="left">-XX:ThreadStackSize=512</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 参考</h2>
<div class="outline-text-2" id="text-8">
<p>
本記事書く際に下記コンテンツを参考した。
</p>
<ul class="org-ul">
<li><a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2011-June/004272.html">What the difference between -Xss and -XX:ThreadStackSize is?</a>
</li>
<li><a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/toc.html">Troubleshooting Guide for HotSpot VM</a>
</li>
<li><a href="http://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html">HotSpot Runtime Overview</a>
</li>
<li><a href="http://xmlandmore.blogspot.jp/2014/09/jdk-8-thread-stack-size-tuning.html?m=1">JDK 8: Thread Stack Size Tuning </a>
</li>
<li><a href="http://www.slideshare.net/m0nstermind/java-runtime-jvm">Java Runtime: повседневные обязанности</a>
</li>
<li><a href="http://brakkee.org/site/2012/10/13/java-from-the-trenches-crash-free-and-responsive-servers/">Java from the trenches: improving reliability</a>
</li>
<li><a href="https://help.blackboard.com/en-us/Learn/9.1_SP_12_and_SP_13/Administrator/010_Release_Notes/020_SP_12_Release_Notes/Performance_and_Scalability/Recommended_JVM_Tuning_Set">Recommended JVM Tuning Set</a>
</li>
<li><a href="http://stackoverflow.com/questions/11025459/where-is-the-java-stack-allocated">where is the Java stack allocated?</a>
</li>
<li><a href="http://unix.stackexchange.com/questions/145557/how-does-stack-allocation-work-in-linux">How does stack allocation work in Linux?</a>
</li>
<li><a href="http://www.oracle.com/technetwork/articles/servers-storage-dev/mem-alloc-1557798.html">How Memory Allocation Affects Performance in Multithreaded Programs</a>
</li>
<li><a href="http://stackoverflow.com/questions/15251250/what-do-the-different-hotspot-jvm-thread-types-do">What do the different (HotSpot) JVM thread types do?</a>
</li>
<li><a href="http://stackoverflow.com/questions/25309748/what-is-thread-stack-size-option-xss-given-to-jvm-why-does-it-have-a-limit-of">What is thread stack size option(-Xss) given to jvm? Why does it have a limit of atleast 68k in a windows pc?</a>
</li>
<li><a href="http://j2eedebug.blogspot.jp/2008/12/mapping-java-thread-to-pstack-and-pmap.html?m=1">Mapping java thread to pstack and pmap</a>
</li>
<li><a href="http://msugai.fc2web.com/java/perform/storage.html">JVM のメモリ構造</a>
</li>
<li><a href="http://codezine.jp/article/detail/1970?p=2">pthreadについて（スタックサイズ）</a>
</li>
<li><a href="http://www.megadriver.info/~fumi/2010/11/linux-%25E3%2581%25AE-pthread-%25E3%2581%25AE%25E3%2583%2587%25E3%2583%2595%25E3%2582%25A9%25E3%2583%25AB%25E3%2583%2588%25E3%2582%25B9%25E3%2582%25BF%25E3%2583%2583%25E3%2582%25AF%25E3%2582%25B5%25E3%2582%25A4%25E3%2582%25BA%25E3%2581%25AB%25E3%2581%25A4%25E3%2581%2584%25E3%2581%25A6/">Linux の pthread のデフォルトスタックサイズについて</a>
</li>
<li><a href="http://linuxjm.sourceforge.jp/html/LDP_man-pages/man3/pthread_attr_setstacksize.3.html">PTHREAD_ATTR_SETSTACKSIZE</a>
</li>
<li><a href="http://docs.oracle.com/cd/E19455-01/806-2732/6jbu8v6ol/index.html#attrib-33670">マルチスレッドのプログラミング - スタックについて</a>
</li>
<li><a href="http://th0x4c.github.io/blog/2012/10/10/os-virtual-memory-map/">{OS} 仮想メモリ空間のメモリマップを調べる</a>
</li>
<li><a href="http://gntm-mdk.hatenadiary.com/entry/2015/01/21/231258">VSS RSS PSS USS の説明</a>
</li>
<li><a href="http://hllvm.group.iteye.com/group/topic/37717">咨询各位大神，使用jni，当栈内空间使用为1M时，会触发core</a>
</li>
</ul>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[調査]JBossASソケット受信バッファーのサイズ]]></title>
    <link href="http://luozengbin.github.io/blog/2015-04-01-%5B%E8%AA%BF%E6%9F%BB%5Djbossas%E3%82%BD%E3%82%B1%E3%83%83%E3%83%88%E5%8F%97%E4%BF%A1%E3%83%90%E3%83%83%E3%83%95%E3%82%A1%E3%83%BC%E3%81%AE%E3%82%B5%E3%82%A4%E3%82%BA.html"/>
    <updated>2015-04-01T00:00:00+09:00</updated>
    <id>http://luozengbin.github.io/blog/[調査]jbossasソケット受信バッファーのサイズ</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 実験シナリオ</a></li>
<li><a href="#sec-2">2. テスト信用のサーブレットを準備する</a></li>
<li><a href="#sec-3">3. サーバソケットの受信バッファーサイズを確認する</a></li>
<li><a href="#sec-4">4. Acceptorスレッドを意図的ストールさせる</a></li>
<li><a href="#sec-5">5. TCPソケット受信バッファサイズを監視する</a></li>
<li><a href="#sec-6">6. パケット通信を監視する</a></li>
<li><a href="#sec-7">7. telnetからデータを順次に送りつける</a></li>
<li><a href="#sec-8">8. 監視結果解析</a></li>
<li><a href="#sec-9">9. TCPソケット受信バッファーサイズの設定について</a></li>
<li><a href="#sec-10">10. まとめ</a></li>
<li><a href="#sec-11">11. 参考</a></li>
</ul>
</div>
</div>


<p>
以下LinuxプラットフォームでJBossASアプリケーションサーバの話です。
</p>




<p>
次のケースに置いて、Acceptorスレッドやワーカスレッドの働き状態が悪くなるため、クライ
アントから送信されてデータがサーバ側のTCPソケット受信バッファーに溜まる。バッファーが
一杯になるとパケット受信ができなくなる、TCPレーヤでパケット再送が起きる。
</p>




<ul class="org-ul">
<li>サーバが過負荷状態でCPU時間がAcceptorスレッドやワーカスレッドに回らない場合
</li>
<li>FullGCによるJBossASサーバの一時停止
</li>
</ul>




<p>
この記事はTCP受信バッファーのサイズの実測値を調査致します。
</p>




<p>
<!-- more -->
</p>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 実験シナリオ</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>テスト信用のサーブレットを準備する
</li>
<li>サーバソケットの受信バッファーサイズを確認する
</li>
<li>Acceptorスレッドを意図的ストールさせる
</li>
<li>TCPソケット受信バッファサイズを監視する
</li>
<li>パケット通信を監視する
</li>
<li>telnetからデータを順次に送りつける
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> テスト信用のサーブレットを準備する</h2>
<div class="outline-text-2" id="text-2">
<p>
受信したHTTPリクエストパラメータを出力するシンプルなサーブレットをJBossASにデプロイす
る。
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ffad29; font-weight: bold;">package</span> jp.co.jizai.sample.jbossas7.<span style="color: #008b8b;">tcp</span>;

<span style="color: #ffad29; font-weight: bold;">import</span> <span style="color: #008b8b;">javax</span>.<span style="color: #008b8b;">servlet</span>.<span style="color: #34cae2;">ServletException</span>;
<span style="color: #ffad29; font-weight: bold;">import</span> <span style="color: #008b8b;">javax</span>.<span style="color: #008b8b;">servlet</span>.<span style="color: #008b8b;">http</span>.<span style="color: #34cae2;">HttpServlet</span>;
<span style="color: #ffad29; font-weight: bold;">import</span> <span style="color: #008b8b;">javax</span>.<span style="color: #008b8b;">servlet</span>.<span style="color: #008b8b;">http</span>.<span style="color: #34cae2;">HttpServletRequest</span>;
<span style="color: #ffad29; font-weight: bold;">import</span> <span style="color: #008b8b;">javax</span>.<span style="color: #008b8b;">servlet</span>.<span style="color: #008b8b;">http</span>.<span style="color: #34cae2;">HttpServletResponse</span>;
<span style="color: #ffad29; font-weight: bold;">import</span> <span style="color: #008b8b;">java</span>.<span style="color: #008b8b;">io</span>.<span style="color: #34cae2;">IOException</span>;
<span style="color: #ffad29; font-weight: bold;">import</span> <span style="color: #008b8b;">java</span>.<span style="color: #008b8b;">io</span>.<span style="color: #34cae2;">PrintWriter</span>;
<span style="color: #ffad29; font-weight: bold;">import</span> <span style="color: #008b8b;">java</span>.<span style="color: #008b8b;">util</span>.<span style="color: #34cae2;">Enumeration</span>;
<span style="color: #ffad29; font-weight: bold;">import</span> <span style="color: #008b8b;">java</span>.<span style="color: #008b8b;">util</span>.<span style="color: #34cae2;">Map</span>;

<span style="color: #ffad29; font-weight: bold;">public</span> <span style="color: #ffad29; font-weight: bold;">class</span> <span style="color: #34cae2;">ShowParameterServlet</span> <span style="color: #ffad29; font-weight: bold;">extends</span> <span style="color: #34cae2;">HttpServlet</span> {

    <span style="color: #ffad29; font-weight: bold;">private</span> <span style="color: #ffad29; font-weight: bold;">static</span> <span style="color: #ffad29; font-weight: bold;">final</span> <span style="color: #34cae2;">String</span> <span style="color: #dbdb95;">CONTENT_TYPE</span> = <span style="color: #e67128;">"text/html; charset=UTF-8"</span>;

    <span style="color: #ffad29; font-weight: bold;">public</span> <span style="color: #34cae2;">void</span> <span style="color: #00ede1; font-weight: bold;">doGet</span>(<span style="color: #34cae2;">HttpServletRequest</span> <span style="color: #dbdb95;">req</span>, <span style="color: #34cae2;">HttpServletResponse</span> <span style="color: #dbdb95;">resp</span>) <span style="color: #ffad29; font-weight: bold;">throws</span> <span style="color: #34cae2;">ServletException</span>, <span style="color: #34cae2;">IOException</span> {

        process(req, resp);
    }


    <span style="color: #ffad29; font-weight: bold;">public</span> <span style="color: #34cae2;">void</span> <span style="color: #00ede1; font-weight: bold;">doPost</span>(<span style="color: #34cae2;">HttpServletRequest</span> <span style="color: #dbdb95;">req</span>, <span style="color: #34cae2;">HttpServletResponse</span> <span style="color: #dbdb95;">resp</span>) <span style="color: #ffad29; font-weight: bold;">throws</span> <span style="color: #34cae2;">ServletException</span>, <span style="color: #34cae2;">IOException</span> {
        process(req, resp);
    }

    <span style="color: #ffad29; font-weight: bold;">public</span> <span style="color: #34cae2;">void</span> <span style="color: #00ede1; font-weight: bold;">process</span>(<span style="color: #34cae2;">HttpServletRequest</span> <span style="color: #dbdb95;">req</span>, <span style="color: #34cae2;">HttpServletResponse</span> <span style="color: #dbdb95;">resp</span>) <span style="color: #ffad29; font-weight: bold;">throws</span> <span style="color: #34cae2;">ServletException</span>, <span style="color: #34cae2;">IOException</span> {
        resp.setContentType(CONTENT_TYPE);
        <span style="color: #34cae2;">PrintWriter</span> <span style="color: #dbdb95;">out</span> = resp.getWriter();
        System.out.println(<span style="color: #e67128;">"=== http parameter ==="</span>);
        <span style="color: #34cae2;">Map</span>&lt;<span style="color: #34cae2;">String</span>, <span style="color: #34cae2;">Object</span>&gt; <span style="color: #dbdb95;">paramMap</span> = (Map&lt;<span style="color: #34cae2;">String</span>, Object&gt;) req.getParameterMap();
        <span style="color: #ffad29; font-weight: bold;">for</span> (<span style="color: #008b8b;">Map</span>.<span style="color: #34cae2;">Entry</span>&lt;<span style="color: #34cae2;">String</span>, <span style="color: #34cae2;">Object</span>&gt; entry : paramMap.entrySet()) {
            out.write(String.format(<span style="color: #e67128;">"%s = %s"</span>, entry.getKey(), entry.getValue()) + <span style="color: #e67128;">"&lt;br/&gt;"</span>);
        }

        System.out.println(<span style="color: #e67128;">"=== http attribute ==="</span>);
        <span style="color: #34cae2;">Enumeration</span>&lt;<span style="color: #34cae2;">String</span>&gt; <span style="color: #dbdb95;">attrNames</span> = (<span style="color: #34cae2;">Enumeration</span>&lt;<span style="color: #34cae2;">String</span>&gt;) req.getAttributeNames();
        <span style="color: #ffad29; font-weight: bold;">while</span> (attrNames.hasMoreElements()) {
            <span style="color: #34cae2;">String</span> <span style="color: #dbdb95;">attrName</span> = attrNames.nextElement();
            out.write(String.format(<span style="color: #e67128;">"%s = %s"</span>, attrName, req.getAttribute(attrName)) + <span style="color: #e67128;">"&lt;br/&gt;"</span>);
        }
        out.close();
    }
}
</pre>
</div>
</div>
</div>




<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> サーバソケットの受信バッファーサイズを確認する</h2>
<div class="outline-text-2" id="text-3">
<p>
新規接続のサーバソケットのgetReceiveBufferSize()メソッドをコールする <code>Byteman</code> スクリ
プトを実行中のJBassASにアタッチメントする。
</p>
<div class="org-src-container">

<pre class="src src-sh">RULE trace http ReceiveBufferSize
CLASS org.apache.tomcat.util.net.JIoEndpoint
METHOD processSocket
AT ENTRY
BIND socket = $<span style="color: #dbdb95;">1</span>
IF TRUE
DO
  traceln(<span style="color: #e67128;">"socket.getReceiveBufferSize() = "</span> + socket.getReceiveBufferSize()), traceStack()
ENDRULE
</pre>
</div>

<p>
クライアントブラウザからテスト用サーブレットをアクセスすると、サーバログに以下の内容
が出力される。
</p>

<pre class="example">
15:46:11,002 INFO  [stdout] (http-/0.0.0.0:8080-Acceptor-0) socket.getReceiveBufferSize() = 43690
15:46:11,004 INFO  [stdout] (http-/0.0.0.0:8080-Acceptor-0) Stack trace for thread http-/0.0.0.0:8080-Acceptor-0
15:46:11,004 INFO  [stdout] (http-/0.0.0.0:8080-Acceptor-0) org.apache.tomcat.util.net.JIoEndpoint.processSocket(JIoEndpoint.java:-1)
15:46:11,004 INFO  [stdout] (http-/0.0.0.0:8080-Acceptor-0) org.apache.tomcat.util.net.JIoEndpoint$Acceptor.run(JIoEndpoint.java:315)
15:46:11,005 INFO  [stdout] (http-/0.0.0.0:8080-Acceptor-0) java.lang.Thread.run(Thread.java:745)
</pre>

<p>
<code>[[https://docs.oracle.com/javase/jp/6/api/java/net/Socket.html#setReceiveBufferSize%2528int%2529][java.net.Socket.getReceiveBufferSize]]()</code> で取れた値→ <code>43690</code> 単位がよくわからないの
でJavaDocを引いてみた。
</p>

<pre class="example">
public int getReceiveBufferSize()
                         throws SocketException

    この Socket で使われる SO_RCVBUF オプションの値を取得します。これは、この Socket で入力用としてプラットフォームが使うバッファーのサイズです。

    戻り値:
        この Socket の SO_RCVBUF オプションの値 
    例外:
        SocketException - 使用しているプロトコルでエラー (TCP エラーなど) が発生した場合
    導入されたバージョン:
        1.2
    関連項目:
        setReceiveBufferSize(int)
</pre>

<p>
やはり、分からないので <code>SO_RCVBUF</code> オプションの単位を探って見る。
</p>

<pre class="example">
SO_RCVBUF
    ソケットの受信バッファーの最大サイズを設定・取得する (バイト単位)。 setsockopt(2)
    を使って値が設定されたときに (管理オーバヘッド用の領域を確保するために) カーネルは
    この値を 2倍し、 getsockopt(2) はこの 2倍された値を返す。 デフォルトの値は
    /proc/sys/net/core/rmem_default ファイルで設定され、許容される最大の値は
    /proc/sys/net/core/rmem_max ファイルで設定される。 このオプションの最小値は (2倍し
    た値で) 256 である
</pre>

<p>
僕の日本語理解力が低いので、正確な意味が掴めないままだが。一先ず受信バッファーサイズの
単位がバイトだそうです。 <code>43690</code> バイトは約42KB、またTCP受信バッファーカーネルパラメー
タ <code>net.ipv4.tcp_rmem</code> の値は下記の通りとなります。 <code>43690</code> は丁度 <code>net.ipv4.tcp_rmem</code>
のデフォルト値の 1/2 であることが分かりました。
</p>

<pre class="example">
# sysctl -a | grep net.ipv4.tcp_rmem
net.ipv4.tcp_rmem = 4096    87380   4194304
</pre>
</div>
</div>




<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Acceptorスレッドを意図的ストールさせる</h2>
<div class="outline-text-2" id="text-4">
<p>
新規接続を受け付ける処理 <code>org.apache.tomcat.util.net.JIoEndpoint.processSocket(Socket
socket)</code> でスレッドを30秒間Sleepされる <code>Byteman</code> スクリプトを実行中のJBossASにアタッチ
メントする。
</p>
<div class="org-src-container">

<pre class="src src-sh">RULE pause acceptor thread
CLASS org.apache.tomcat.util.net.JIoEndpoint
METHOD processSocket
AT ENTRY
BIND socket = $<span style="color: #dbdb95;">1</span>
IF TRUE
DO
  Thread.sleep(300000)
ENDRULE
</pre>
</div>
</div>
</div>




<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> TCPソケット受信バッファサイズを監視する</h2>
<div class="outline-text-2" id="text-5">
<p>
以下のコマンドでTCPソケット受信バッファサイズを監視する
</p>
<pre class="example">
$ watch -n 2 'netstat -an | grep ESTABLISHED | grep 8080'
</pre>
</div>
</div>




<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> パケット通信を監視する</h2>
<div class="outline-text-2" id="text-6">
<p>
クライアント側にて以下のコマンドでパケット通信の監視を行う
</p>
<pre class="example">
$sudo tcpdump -n -i virbr0 port 8080
</pre>
</div>
</div>




<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> telnetからデータを順次に送りつける</h2>
<div class="outline-text-2" id="text-7">
<p>
<code>net.ipv4.tcp_rmem</code> パラメータデフォルト値 <code>87380</code> より大きい電文を送るようにHTTPヘッ
ダーに <code>Content-Length: 120100</code> を指定する。
</p>

<pre class="example">
$ telnet jbossas-lab02 8080
POST /jbossas7-tcp-basic/ShowParameterServlet HTTP/1.1
Host: jbossas-lab02:8080
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:36.0) Gecko/20100101 Firefox/36.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: ja,en-US;q=0.7,en;q=0.3
Accept-Encoding: gzip, deflate
Referer: http://jbossas-lab002:8080/jbossas7-tcp-basic/
Connection: Close
Content-Type: application/x-www-form-urlencoded
Content-Length: 120100

★まず100バイト分を送る(エンターは2バイト分になります)
param1=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ★エンターを押す

★以下4000バイト文字を30回繰り返しサーバに送る
bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
</pre>
</div>
</div>




<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 監視結果解析</h2>
<div class="outline-text-2" id="text-8">
<p>
以下TCPソケット受信バッファサイズの監視結果、文中の★マークは結果の解析コメントとなり
ます。
</p>
<pre class="example">
# while [ true ]; do netstat -an | grep ESTABLISHED | grep 8080; sleep  2; done
★1 TCP3WHS 接続確立
tcp        0      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 

★2 HTTPヘッダー受信
tcp      447      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 

★3 リクエストデータの受信
tcp      547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp     4547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp     8547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    12547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    16547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    20547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    24547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    28547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    32547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    36547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    40547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 

★4 アプリ予約バッファサイズに達した、以降は管理領域を食い始めた
★  このタイミングからサーバ受信ウィンドウサイズが徐々に縮める
tcp    44547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    48547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    52547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    56547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    60547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    64547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    68547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    72211      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 

★5 以降TCPバッファが満タン
tcp    72211      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    72211      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    72211      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    72211      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    72211      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    72211      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    72211      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    72211      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED
</pre>


<p>
パケット監視結果は以下の通りです。
</p>
<pre class="example">
★1 TCP3WHS 接続確立
16:45:01.262499 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [S], seq 3028524293, win 29200, options [mss 1460,sackOK,TS val 50120659 ecr 0,nop,wscale 7], length 0
16:45:01.262697 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [S.], seq 1682372075, ack 3028524294, win 14480, options [mss 1460,sackOK,TS val 3798305 ecr 50120659,nop,wscale 7], length 0
16:45:01.262773 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], ack 1, win 229, options [nop,nop,TS val 50120659 ecr 3798305], length 0


★2 HTTPヘッダー送信
16:45:09.935452 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 1:57, ack 1, win 229, options [nop,nop,TS val 50123261 ecr 3798305], length 56: HTTP: POST /jbossas7-tcp-basic/ShowParameterServlet HTTP/1.1
16:45:09.935789 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 57, win 114, options [nop,nop,TS val 3806979 ecr 50123261], length 0
16:45:09.935850 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 57:422, ack 1, win 229, options [nop,nop,TS val 50123261 ecr 3806979], length 365: HTTP
16:45:09.935905 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 422, win 122, options [nop,nop,TS val 3806979 ecr 50123261], length 0
16:45:10.330264 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 422:446, ack 1, win 229, options [nop,nop,TS val 50123379 ecr 3806979], length 24: HTTP
16:45:10.330448 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 446, win 122, options [nop,nop,TS val 3807373 ecr 50123379], length 0
16:45:10.897750 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 446:448, ack 1, win 229, options [nop,nop,TS val 50123550 ecr 3807373], length 2: HTTP
16:45:10.897911 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 448, win 122, options [nop,nop,TS val 3807941 ecr 50123550], length 0

★3 リクエストデータの送信
16:45:19.464509 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 448:548, ack 1, win 229, options [nop,nop,TS val 50126120 ecr 3807941], length 100: HTTP
16:45:19.464668 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 548, win 122, options [nop,nop,TS val 3816507 ecr 50126120], length 0
16:45:26.602423 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 548:4548, ack 1, win 229, options [nop,nop,TS val 50128261 ecr 3816507], length 4000: HTTP
16:45:26.602602 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 4548, win 145, options [nop,nop,TS val 3823645 ecr 50128261], length 0
16:45:32.436162 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 4548:8548, ack 1, win 229, options [nop,nop,TS val 50130011 ecr 3823645], length 4000: HTTP
16:45:32.436338 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 8548, win 167, options [nop,nop,TS val 3829479 ecr 50130011], length 0
16:45:35.452590 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 8548:12548, ack 1, win 229, options [nop,nop,TS val 50130916 ecr 3829479], length 4000: HTTP
16:45:35.452721 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 12548, win 190, options [nop,nop,TS val 3832495 ecr 50130916], length 0
16:45:38.082228 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 12548:16548, ack 1, win 229, options [nop,nop,TS val 50131705 ecr 3832495], length 4000: HTTP
16:45:38.082396 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 16548, win 212, options [nop,nop,TS val 3835125 ecr 50131705], length 0
16:45:40.743705 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 16548:20548, ack 1, win 229, options [nop,nop,TS val 50132504 ecr 3835125], length 4000: HTTP
16:45:40.743848 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 20548, win 235, options [nop,nop,TS val 3837787 ecr 50132504], length 0
16:45:43.016683 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 20548:24548, ack 1, win 229, options [nop,nop,TS val 50133185 ecr 3837787], length 4000: HTTP
16:45:43.016863 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 24548, win 258, options [nop,nop,TS val 3840060 ecr 50133185], length 0
16:45:45.721066 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 24548:28548, ack 1, win 229, options [nop,nop,TS val 50133997 ecr 3840060], length 4000: HTTP
16:45:45.721253 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 28548, win 280, options [nop,nop,TS val 3842764 ecr 50133997], length 0
16:45:49.227814 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 28548:32548, ack 1, win 229, options [nop,nop,TS val 50135049 ecr 3842764], length 4000: HTTP
16:45:49.227964 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 32548, win 253, options [nop,nop,TS val 3846271 ecr 50135049], length 0
16:45:51.671841 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 32548:36548, ack 1, win 229, options [nop,nop,TS val 50135782 ecr 3846271], length 4000: HTTP

★4 ここから再送が発生する
16:45:51.680266 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 35444:36548, ack 1, win 229, options [nop,nop,TS val 50135785 ecr 3846271], length 1104: HTTP
16:45:51.711839 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 36548, win 225, options [nop,nop,TS val 3848755 ecr 50135782,nop,nop,sack 1 {35444:36548}], length 0
16:45:55.390996 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 36548:40548, ack 1, win 229, options [nop,nop,TS val 50136898 ecr 3848755], length 4000: HTTP
16:45:55.430802 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 40548, win 197, options [nop,nop,TS val 3852474 ecr 50136898], length 0
16:45:59.291140 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], seq 40548:43444, ack 1, win 229, options [nop,nop,TS val 50138068 ecr 3852474], length 2896: HTTP
16:45:59.291169 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 43444:44548, ack 1, win 229, options [nop,nop,TS val 50138068 ecr 3852474], length 1104: HTTP
16:45:59.310296 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 43444:44548, ack 1, win 229, options [nop,nop,TS val 50138074 ecr 3852474], length 1104: HTTP
16:45:59.330773 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 44548, win 166, options [nop,nop,TS val 3856374 ecr 50138068,nop,nop,sack 1 {43444:44548}], length 0
16:46:01.367501 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], seq 44548:47444, ack 1, win 229, options [nop,nop,TS val 50138691 ecr 3856374], length 2896: HTTP
16:46:01.367533 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 47444:48548, ack 1, win 229, options [nop,nop,TS val 50138691 ecr 3856374], length 1104: HTTP
16:46:01.406803 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 48548, win 135, options [nop,nop,TS val 3858450 ecr 50138691], length 0
16:46:03.523326 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], seq 48548:51444, ack 1, win 229, options [nop,nop,TS val 50139337 ecr 3858450], length 2896: HTTP
16:46:03.523356 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 51444:52548, ack 1, win 229, options [nop,nop,TS val 50139337 ecr 3858450], length 1104: HTTP
16:46:03.553582 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 51444:52548, ack 1, win 229, options [nop,nop,TS val 50139347 ecr 3858450], length 1104: HTTP
16:46:03.553716 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 52548, win 104, options [nop,nop,TS val 3860596 ecr 50139337,nop,nop,sack 1 {51444:52548}], length 0
16:46:06.322183 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], seq 52548:55444, ack 1, win 229, options [nop,nop,TS val 50140177 ecr 3860596], length 2896: HTTP
16:46:06.322212 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 55444:56548, ack 1, win 229, options [nop,nop,TS val 50140177 ecr 3860596], length 1104: HTTP
16:46:06.361777 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 56548, win 73, options [nop,nop,TS val 3863405 ecr 50140177], length 0
16:46:08.944983 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], seq 56548:57996, ack 1, win 229, options [nop,nop,TS val 50140964 ecr 3863405], length 1448: HTTP
16:46:08.945017 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], seq 57996:59444, ack 1, win 229, options [nop,nop,TS val 50140964 ecr 3863405], length 1448: HTTP
16:46:08.945027 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 59444:60548, ack 1, win 229, options [nop,nop,TS val 50140964 ecr 3863405], length 1104: HTTP
16:46:08.945188 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 57996, win 62, options [nop,nop,TS val 3865988 ecr 50140964], length 0
16:46:08.983605 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 59444:60548, ack 1, win 229, options [nop,nop,TS val 50140976 ecr 3865988], length 1104: HTTP
16:46:08.983765 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 60548, win 43, options [nop,nop,TS val 3866027 ecr 50140964,nop,nop,sack 1 {59444:60548}], length 0
16:46:10.874178 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], seq 60548:63444, ack 1, win 229, options [nop,nop,TS val 50141543 ecr 3866027], length 2896: HTTP
16:46:10.874209 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 63444:64548, ack 1, win 229, options [nop,nop,TS val 50141543 ecr 3866027], length 1104: HTTP
16:46:10.913789 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 64548, win 12, options [nop,nop,TS val 3867957 ecr 50141543], length 0
16:46:13.263314 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], seq 64548:65996, ack 1, win 229, options [nop,nop,TS val 50142259 ecr 3867957], length 1448: HTTP
16:46:13.263477 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 65996, win 1, options [nop,nop,TS val 3870306 ecr 50142259], length 0
16:46:13.483589 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 65996:66124, ack 1, win 229, options [nop,nop,TS val 50142326 ecr 3870306], length 128: HTTP
16:46:13.483812 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 66124, win 46, options [nop,nop,TS val 3870527 ecr 50142326], length 0
16:46:13.483865 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], seq 66124:67572, ack 1, win 229, options [nop,nop,TS val 50142326 ecr 3870527], length 1448: HTTP
16:46:13.483885 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 67572:68548, ack 1, win 229, options [nop,nop,TS val 50142326 ecr 3870527], length 976: HTTP
16:46:13.523583 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 67572:68548, ack 1, win 229, options [nop,nop,TS val 50142338 ecr 3870527], length 976: HTTP
16:46:13.523752 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 68548, win 28, options [nop,nop,TS val 3870567 ecr 50142326,nop,nop,sack 1 {67572:68548}], length 0
16:46:15.144825 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], seq 68548:69996, ack 1, win 229, options [nop,nop,TS val 50142824 ecr 3870567], length 1448: HTTP
16:46:15.144860 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], seq 69996:71444, ack 1, win 229, options [nop,nop,TS val 50142824 ecr 3870567], length 1448: HTTP
16:46:15.145025 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 69996, win 17, options [nop,nop,TS val 3872188 ecr 50142824], length 0
16:46:15.184796 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 71444, win 6, options [nop,nop,TS val 3872228 ecr 50142824], length 0
16:46:15.406939 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 71444:72212, ack 1, win 229, options [nop,nop,TS val 50142903 ecr 3872228], length 768: HTTP


★5 ここからサーバから受信可能なTCPウィンドウサイズが0の応答パケットが出始めた
16:46:15.407110 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 72212, win 0, options [nop,nop,TS val 3872450 ecr 50142903], length 0
16:46:15.626933 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], ack 1, win 229, options [nop,nop,TS val 50142969 ecr 3872450], length 0
16:46:15.627096 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 72212, win 0, options [nop,nop,TS val 3872670 ecr 50142903], length 0
16:46:16.066943 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], ack 1, win 229, options [nop,nop,TS val 50143101 ecr 3872670], length 0
16:46:16.067143 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 72212, win 0, options [nop,nop,TS val 3873110 ecr 50142903], length 0
16:46:16.950253 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], ack 1, win 229, options [nop,nop,TS val 50143366 ecr 3873110], length 0
16:46:16.950401 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 72212, win 0, options [nop,nop,TS val 3873993 ecr 50142903], length 0
16:46:18.716950 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], ack 1, win 229, options [nop,nop,TS val 50143896 ecr 3873993], length 0
16:46:18.717129 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 72212, win 0, options [nop,nop,TS val 3875760 ecr 50142903], length 0
16:46:22.250259 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], ack 1, win 229, options [nop,nop,TS val 50144956 ecr 3875760], length 0
16:46:22.250438 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 72212, win 0, options [nop,nop,TS val 3879293 ecr 50142903], length 0
16:46:29.303610 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], ack 1, win 229, options [nop,nop,TS val 50147072 ecr 3879293], length 0
16:46:29.303785 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 72212, win 0, options [nop,nop,TS val 3886347 ecr 50142903], length 0
</pre>
</div>
</div>




<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> TCPソケット受信バッファーサイズの設定について</h2>
<div class="outline-text-2" id="text-9">
<p>
JavaDocから引用
</p>

<ul class="org-ul">
<li><a href="https://docs.oracle.com/javase/jp/6/api/java/net/Socket.html#setReceiveBufferSize%2528int%2529">java.net.Socket.setReceiveBufferSize</a>
この Socket の SO_RCVBUF オプションを指定された値に設定します。SO_RCVBUF オプション
は、使用するネットワーク入出力バッファーに設定するサイズのヒントとして、プラットフォー
ムのネットワークコードが使います。

<p>
受信バッファーのサイズを増やすと、大規模な接続でのネットワーク入出力のパフォーマンス
を上げることができます。一方、サイズを減らすと、受信データのバックログを減らすことが
できます。
</p>

<p>
SO_RCVBUF は <code>ヒント</code> なので、アプリケーションでバッファーのサイズ設定を調べる必要が
ある場合は、getReceiveBufferSize() を呼び出してください。
</p>

<p>
SO_RCVBUF の値は、リモートピアに通知される TCP 受信ウィンドウの設定にも使用されます。
一般に、ソケットが接続されているかぎり、このウィンドウサイズはいつでも変更できます。
ただし、64K を超える受信ウィンドウを要求する場合は、ソケットをリモートピアに接続する
前に変更を要求する必要があります。次の 2 つの場合に注意してください。
</p>

<p>
ServerSocket から受け入れたソケットの場合、ServerSocket をローカルアドレスにバインド
する前に、ServerSocket.setReceiveBufferSize(int) を呼び出してこれを実行する必要があ
ります。
</p>

<p>
クライアントソケットの場合、ソケットをそのリモートピアに接続する前に、
setReceiveBufferSize() を呼び出す必要があります。
</p>
</li>
<li><a href="https://docs.oracle.com/javase/jp/6/api/java/net/ServerSocket.html#setReceiveBufferSize%2528int%2529">java.net.ServerSocket.setReceiveBufferSize</a>
  この ServerSocket から受け入れられたソケットの SO_RCVBUF オプションのデフォルト推
奨値を設定します。受け入れられたソケット内に実際に設定されている値を確認してください。
それには、accept() からソケットが返されたあとで Socket.getReceiveBufferSize() を呼び
出します。

<p>
  SO_RCVBUF の値は、内部ソケット受信バッファーのサイズの設定と、リモートピアに通知さ
れる TCP 受信ウィンドウのサイズの設定の両方に使用されます。
</p>

<p>
  その後、Socket.setReceiveBufferSize(int) を呼び出すことで値を変更できます。ただし、
アプリケーションが RFC1323 で定義されている 64K バイトを超える受信ウィンドウを使用可
能にする必要がある場合には、ローカルアドレスにバインドする前に 推奨値を
ServerSocket で設定する必要があります。つまり、引数なしコンストラクタを使って
ServerSocket を作成し、次に setReceiveBufferSize() を呼び出し、最後に bind() を呼び
出して ServerSocket をアドレスにバインドする必要があることを意味します。
</p>

<p>
  これに失敗してもエラーは発生せず、バッファーサイズは要求された値に設定されます。た
だし、この ServerSocket から受け取るソケットの TCP 受信ウィンドウは 64K バイト以下に
なります。
</p>
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> まとめ</h2>
<div class="outline-text-2" id="text-10">
<ul class="org-ul">
<li>JBossASソケット受信バッファーのデフォルトサイズは <code>net.ipv4.tcp_rmem</code> の1/2が適用さ
れる(約42KB)。
</li>
<li>リクエストデータサイズが42KBバイト以下の場合、パケット再送発生しない
</li>
<li>実際に受信できる最大サイズは <code>net.ipv4.tcp_rmem</code> 値の8割ぐらい
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> 参考</h2>
<div class="outline-text-2" id="text-11">
<ul class="org-ul">
<li><a href="http://linuxjm.sourceforge.jp/html/LDP_man-pages/man7/socket.7.html">Section: Linux Programmer&#8217;s Manual (7)</a>
</li>
<li><a href="https://docs.oracle.com/javase/jp/6/api/java/net/Socket.html">Socket (Java Platform SE 6)</a>
</li>
</ul>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[メモ]JBoss ASでBytemanを使う]]></title>
    <link href="http://luozengbin.github.io/blog/2015-04-01-%5B%E3%83%A1%E3%83%A2%5Djbossas%E3%81%A7byteman%E3%82%92%E4%BD%BF%E3%81%86.html"/>
    <updated>2015-04-01T00:00:00+09:00</updated>
    <id>http://luozengbin.github.io/blog/[メモ]jbossasでbytemanを使う</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 前提</a></li>
<li><a href="#sec-2">2. インストール</a></li>
<li><a href="#sec-3">3. JBossASプロセスへのアタッチ</a></li>
<li><a href="#sec-4">4. トレース用スクリプトの作成</a></li>
<li><a href="#sec-5">5. スクリプトの実行</a></li>
<li><a href="#sec-6">6. 参考</a></li>
</ul>
</div>
</div>


<p>
ミドルウェアの内部動作をトレースするためによく使うので手順を残しておきます。
</p>




<p>
<!-- more -->
</p>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 前提</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>JBossAS 7系
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> インストール</h2>
<div class="outline-text-2" id="text-2">
<pre class="example">
$ wget http://downloads.jboss.org/byteman/2.2.1/byteman-download-2.2.1-bin.zip
$ unzip byteman-download-2.2.1-bin.zip
</pre>
</div>
</div>




<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> JBossASプロセスへのアタッチ</h2>
<div class="outline-text-2" id="text-3">
<pre class="example">
$ export BYTEMAN_HOME=`pwd`/byteman-download-2.2.1
$ export JAVA_HOME=/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.65.x86_64
$ JBOSS_PID=`ps -ef | grep [j]boss-modules.jar | awk '{print $2}'`
$ ${BYTEMAN_HOME}/bin/bminstall.sh -b ${JBOSS_PID}
</pre>
</div>
</div>




<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> トレース用スクリプトの作成</h2>
<div class="outline-text-2" id="text-4">
<p>
JBossASサーバソケット受信バッファーサイズを調べるスクリプト
<code>trace_socket_receive_buffer_size.btm</code> を作成する
</p>

<pre class="example">
RULE trace http ReceiveBufferSize
CLASS org.apache.tomcat.util.net.JIoEndpoint
METHOD processSocket
AT ENTRY
BIND socket = $1
IF TRUE
DO
  traceln("socket.getReceiveBufferSize() = " + socket.getReceiveBufferSize()), traceStack()
ENDRULE
</pre>
</div>
</div>




<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> スクリプトの実行</h2>
<div class="outline-text-2" id="text-5">
<pre class="example">
$ ${BYTEMAN_HOME}/bin/bmsubmit.sh trace_socket_receive_buffer_size.btm
</pre>
</div>
</div>




<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 参考</h2>
<div class="outline-text-2" id="text-6">
<ul class="org-ul">
<li><a href="https://developer.jboss.org/wiki/ABytemanTutorial#how_do_i_run_jboss_as_with_byteman">A Byteman Tutorial</a>
</li>
<li><a href="http://nekop.hatenablog.com/entry/20101220/1292825812">BytemanによるJava黒魔術</a>
</li>
<li><a href="http://d.hatena.ne.jp/Kazuhira/20131022/1382455739">バイトコード操作ツール、Bytemanを試す</a>
</li>
</ul>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[まとめ]JBoss as 7過負荷時TCPコネクションの振る舞い]]></title>
    <link href="http://luozengbin.github.io/blog/2015-04-01-%5B%E3%81%BE%E3%81%A8%E3%82%81%5Djbossas%E9%81%8E%E8%B2%A0%E8%8D%B7%E6%99%82tcp%E3%82%B3%E3%83%8D%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E6%8C%AF%E3%82%8B%E8%88%9E%E3%81%84.html"/>
    <updated>2015-04-01T00:00:00+09:00</updated>
    <id>http://luozengbin.github.io/blog/[まとめ]jbossas過負荷時tcpコネクションの振る舞い</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 前提事項</a></li>
<li><a href="#sec-2">2. 最大ワーカスレッド数の設定方法</a></li>
<li><a href="#sec-3">3. スレッド起動のタイミング</a></li>
<li><a href="#sec-4">4. 過負荷時の挙動</a>
<ul>
<li><a href="#sec-4-1">4.1. A.クライアントからPSHパケット再送が発生するパターン</a></li>
<li><a href="#sec-4-2">4.2. B.TCP3WHSパケット再送が発生するパターン</a></li>
<li><a href="#sec-4-3">4.3. C.新規接続が拒否されるパターン</a></li>
</ul>
</li>
<li><a href="#sec-5">5. 過負荷の対策</a></li>
</ul>
</div>
</div>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 前提事項</h2>
<div class="outline-text-2" id="text-1">
<p>
本記事は以下の環境を前提とする。
</p>

<ul class="org-ul">
<li>Linux/x86_64
</li>
<li>JBoss AS 7
</li>
</ul>

<p>
<!-- more -->
</p>
</div>
</div>




<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 最大ワーカスレッド数の設定方法</h2>
<div class="outline-text-2" id="text-2">
<ul class="org-ul">
<li>方式1: -Dorg.apache.tomcat.util.net.MAX_THREADS=999
</li>
<li>方式2: コネクタ定義のmax-connectionsで指定する
</li>
</ul>

<p>
両方指定した場合、方式2が優先される。指定しない場合 512 x JVMに割り当てたコア数
</p>
</div>
</div>




<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> スレッド起動のタイミング</h2>
<div class="outline-text-2" id="text-3">
<p>
サーバ起動時にワーカースレッドの初期値が0、リクエストが来るたびに新規スレッドを作る。
スレッドの数がmax-connectionsの数に達した時にログに以下のメッセージがを出力される。
</p>

<pre class="example">
INFO [JIoEndpoint] Maximum number of threads (xxx) created for connector with address /127.0.0.1 and port 8080
</pre>
</div>
</div>




<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 過負荷時の挙動</h2>
<div class="outline-text-2" id="text-4">
<p>
下記AとBの何れが起きた場合、クライアントからすると無応答や応答が激遅いことが感じるので
防止の対策を講じることをおすすめします。
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> A.クライアントからPSHパケット再送が発生するパターン</h3>
<div class="outline-text-3" id="text-4-1">
<p>
以下の状況に置いて、クライアントからのリクエスデータがサーバ側のTCPバッファーに詰ま
る。TCPバッファーが一杯になると、パケットがdropされるのでクライアントからのデータ再
送が発生する。
</p>

<ul class="org-ul">
<li>CPU高負荷時、Acceptorスレッドが回らない状況
</li>
<li>GCによって、Acceptorスレッドの働きが良くない状況
</li>
<li>CPU高負荷時、ワーカスレッドがリクエストデータ受信処理で止まっている
</li>
<li>GCによって、ワーカスレッドがリクエストデータ受信処理で止まっている
</li>
</ul>

<p>
また、Acceptorスレッドが止まる場合新規接続(3WHS完了)がbacklogキューに溜まるので
backlogキューが溢れる可能性もあります。
</p>

<p>
上記に関して、Threadサブシステム利用時も同様です。
</p>

<p>
TCPバッファーがについて、TCP接続単位にTCPバッファーが持っている、デフォルト値は
<a href="https://github.com/torvalds/linux/blob/master/net/ipv4/tcp.c#L3076">net.ipv4.tcp_rmem</a> カーネルパラメータ値の1/2になります、約42KB。
</p>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> B.TCP3WHSパケット再送が発生するパターン</h3>
<div class="outline-text-3" id="text-4-2">
<p>
CPU高負荷でAcceptorスレッドが止まってかつbacklogキューが溢れた場合、コネクションの確立
ができない、クライアントからのsyn(1)やack(3)の再送が起きる。
TCP SYNの再送間隔は以下の通り、約64秒でタイムアウトになる。
</p>
<pre class="example">
1回目 +1秒
2回目 +2秒
3回目 +4秒
4回目 +8秒
5回目 +16秒
6回目 +32秒  タイムアウト
</pre>
<p>
クライアントからすると応答が激遅いと感じることがある。
</p>

<p>
※上記に関して、Threadサブシステム利用時も同様です。
</p>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> C.新規接続が拒否されるパターン</h3>
<div class="outline-text-3" id="text-4-3">
<p>
同時接続数がmax-connections値を超えた場合、Acceptorスレッドが新規コネクションを受付し、
その後のワーカースレッド割り当て処理でワーカースレッドがないことを気付き、ソケットをク
ローズする(FINパケットを送出)。
</p>

<p>
注意：
このケースに置いて必ずじもCPU高負荷とは限らない、ワーカスレッドがアプリに掴み放しの場
合も起こりえる。
</p>
</div>
</div>
</div>




<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 過負荷の対策</h2>
<div class="outline-text-2" id="text-5">
<p>
実際の運用上はどちらも発生しりえる。それぞれのパターンに置いてLBがどう振る舞うかを明確
した上でワーカースレッドのbusy数とCPUの使用率を監視し、閉塞運用、スペアインスタンスの
運用などを設計することが大事だと思います。
</p>
</div>
</div>

]]></content>
  </entry>
  
</feed>
