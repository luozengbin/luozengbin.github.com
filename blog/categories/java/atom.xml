<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | Akira's Tech Notes]]></title>
  <link href="http://luozengbin.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://luozengbin.github.io/"/>
  <updated>2015-05-06T19:25:11+09:00</updated>
  <id>http://luozengbin.github.io/</id>
  <author>
    <name><![CDATA[luozengbin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[調査]JVMのスタックサイズについて]]></title>
    <link href="http://luozengbin.github.io/blog/2015-04-22-%5B%E8%AA%BF%E6%9F%BB%5Djvm%E3%81%AE%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E3%82%B5%E3%82%A4%E3%82%BA%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6.html"/>
    <updated>2015-04-22T00:00:00+09:00</updated>
    <id>http://luozengbin.github.io/blog/[調査]jvmのスタックサイズについて</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 環境</a></li>
<li><a href="#sec-2">2. JVMのスタック領域について</a></li>
<li><a href="#sec-3">3. Javaスレッドのスタックページ構成</a></li>
<li><a href="#sec-4">4. HotSpotの実装</a>
<ul>
<li><a href="#sec-4-1">4.1. glibc guard page</a></li>
<li><a href="#sec-4-2">4.2. HotSpot Guard Pages</a></li>
<li><a href="#sec-4-3">4.3. Normal Stack</a></li>
</ul>
</li>
<li><a href="#sec-5">5. スタックサイズの制御</a></li>
<li><a href="#sec-6">6. ulimit -sの影響範囲</a></li>
<li><a href="#sec-7">7. -Xssと-XX:ThreadStackSizeの違い</a></li>
<li><a href="#sec-8">8. 参考</a></li>
</ul>
</div>
</div>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 環境</h2>
<div class="outline-text-2" id="text-1">
<p>
本記事の内容は以下環境を前提としています。
</p>
<ul class="org-ul">
<li>GNU/Linux x86_64
</li>
<li>OpenJDK 64-Bit 1.7.0_xx
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> JVMのスタック領域について</h2>
<div class="outline-text-2" id="text-2">
<p>
<code>-Xss</code> パラメータ、 <code>-XX:ThreadStackSize</code> パラメータと <code>ulimit -s</code> 混乱している記事を
見受けたため、HotSpotの中身を調べることにしました。
</p>

<p>
結論を先に、
</p>
<ul class="org-ul">
<li><code>ulimit -s</code> の値は親プロセスのJVMランチャー自分のみスタックサイズの制限を受ける。
</li>
<li>JVMランチャー、JavaAPIから起動されたJavaスレッドのスタックサイズは
<code>-XX:ThreadStackSize</code> パラメータ値が適用される。
</li>
<li>JVMランチャーから起動されたイニシャルスレッドのスタックサイズは <code>-Xss</code> パラメータの
で制御できる。
</li>
<li>JNI経由で外部からJVMにアタッチしたスレッドのスタックサイズはJVMの管理対象外です。
</li>
</ul>

<p>
<!-- more -->
</p>

<p>
JVMスタックに関して、公式のJVMスペックドキュメントは以下のように記載しています。
</p>

<p>
<code>Java SE 7 Virtual Machine Specification</code> の <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5.2">2.5.2. Java Virtual Machine Stacks</a> より
</p>
<pre class="example">
Each Java Virtual Machine thread has a private Java Virtual Machine stack, created at
the same time as the thread. A Java Virtual Machine stack stores frames (§2.6). A
Java Virtual Machine stack is analogous to the stack of a conventional language such
as C: it holds local variables and partial results, and plays a part in method
invocation and return. Because the Java Virtual Machine stack is never manipulated
directly except to push and pop frames, frames may be heap allocated. The memory for
a Java Virtual Machine stack does not need to be contiguous.
</pre>
<p>
※メモ： VMスタック内のFrameはヒープ上に配置されるかも知れない。
</p>

<p>
<code>Java SE 7 Virtual Machine Specification</code> の <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5.6">2.5.6. Native Method Stacks</a> より
</p>
<pre class="example">
An implementation of the Java Virtual Machine may use conventional stacks,
colloquially called "C stacks," to support native methods (methods written in a
language other than the Java programming language). Native method stacks may also be
used by the implementation of an interpreter for the Java Virtual Machine's
instruction set in a language such as C. Java Virtual Machine implementations that
cannot load native methods and that do not themselves rely on conventional stacks
need not supply native method stacks. If supplied, native method stacks are typically
allocated per thread when each thread is created.
</pre>

<p>
仕様上ではJVMに <code>Java Stack</code> と <code>Native Stack</code> ２種類のスタックメモリが定義されています。
</p>

<ul class="org-ul">
<li><code>Java Stack</code> Javaコード部分実行時に使われる領域
</li>
<li><code>Native Stack</code> はJNIライブラリを利用時に使われる領域
</li>
</ul>

<p>
以下は、JVMのメモリ論理構成イメージです。
</p>
<pre class="example">
+----------------+--------------+-------------+------------------------------------------------------+
|                |              |             |  +-----------------+  +----------+  +-------------+  |
|     Heap       |  NonHeap     | Code Cache  |  | Program Counter |  |JavaStack |  |Native Stack |  |
|                |              |             |  +-----------------+  |          |  |             |  |
+----------------+--------------+-------------+                       +----------+  +-------------+  |
                                              |                       | Frame #2 |  |             |  |
                                              |                       +----------+  +-------------+  |
                                              |  &lt;&lt; Thread &gt;&gt;         | Frame #1 |  |             |  |
                                              |                       +----------+  +-------------+  |
                                              +------------------------------------------------------+
</pre>
<p>
<code>図1</code>
</p>

<p>
<code>Java Stack</code> と <code>Native Stack</code> がスレッド毎に領域が確保されいます。
</p>

<p>
<code>Troubleshooting Guide for HotSpot VM</code> の <a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/crashes.html#gbyzz">4.1.3 Crash due to Stack Overflow</a> 記述によ
るとHotSpotの実装上 <code>Java Stack</code> と <code>Native Stack</code> が同じスタック領域を共有するのようだ。
</p>

<pre class="example">
In the HotSpot implementation, Java methods share stack frames with C/C++ native
code, namely user native code and the virtual machine itself. Java methods generate
code that checks that stack space is available a fixed distance towards the end of
the stack so that the native code can be called without exceeding the stack
space. This distance towards the end of the stack is called “Shadow Pages.” The
size of the shadow pages is between 3 and 20 pages, depending on the platform. This
distance is tunable, so that applications with native code needing more than the
default distance can increase the shadow page size. The option to increase shadow
pages is -XX:StackShadowPages=n, where n is greater than the default stack shadow
pages for the platform.
</pre>
</div>
</div>




<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Javaスレッドのスタックページ構成</h2>
<div class="outline-text-2" id="text-3">
<p>
HotSpotの実装から見るとJVMから起動されたJavaスレッドのスタックページは次の形で構成さ
れると思います。VM内部スレッドやJITコンパイルスレッドのページ構成はまだ別です。
</p>
<pre class="example">
   --+--                         +------------------------+
     |                          /|                        |\
     |                         / |    StackRedPages       | -XX:StackRedPages=1(4Kb)
     |                        /  |                        |/
     |   HotSpot Guard Pages--   +------------------------+
     |                        \  |                        |\
     |                         \ |    StackYellowPages    | -XX:StackYellowPages=2(8Kb)
     |                          \|                        |/
     |                           +------------------------+
     |                          /|                        |\ ★Native Stackはここです★
-XX:ThreadStackSize            / |    StackShadowPages    | -XX:StackShadowPages=20(80Kb)
-XX:CompilerThreadStackSize   /  |                        |/
-XX:VMThreadStackSize        /   +------------------------+
     |                      /    |                        |
     |                     /     |   +----------------+   |
     |       Normal Stack--      |   |     Frame      |   | ★Java Stackはここです★
     |                     \     |   +----------------+   |
     |                      \    |   |     Frame      |   |
     |                       \   |   +----------------+   |
     |                        \  |   |     Frame      |   |
     |                         \ |   +----------------+   |
     |                          \|                        |
   --+--                         +------------------------+
</pre>
<p>
<code>図2</code>
</p>
</div>
</div>




<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> HotSpotの実装</h2>
<div class="outline-text-2" id="text-4">
<p>
以下はHotSpotのソースコードのコメントに書かれたスタックページ構成図です。
</p>

<p>
<a href="http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/9b0ca45cd756/src/os_cpu/linux_x86/vm/os_linux_x86.cpp#l668">jdk7:hotspot/src/os_cpu/linux_x86/vm/os_linux_x86.cpp</a>
</p>
<pre class="example">
// Java thread:
//
//   Low memory addresses
//    +------------------------+
//    |                        |\  JavaThread created by VM does not have glibc
//    |    glibc guard page    | - guard, attached Java thread usually has
//    |                        |/  1 page glibc guard.
// P1 +------------------------+ Thread::stack_base() - Thread::stack_size()
//    |                        |\
//    |  HotSpot Guard Pages   | - red and yellow pages
//    |                        |/
//    +------------------------+ JavaThread::stack_yellow_zone_base()
//    |                        |\
//    |      Normal Stack      | -
//    |                        |/
// P2 +------------------------+ Thread::stack_base()
//
// Non-Java thread:
//
//   Low memory addresses
//    +------------------------+
//    |                        |\
//    |  glibc guard page      | - usually 1 page
//    |                        |/
// P1 +------------------------+ Thread::stack_base() - Thread::stack_size()
//    |                        |\
//    |      Normal Stack      | -
//    |                        |/
// P2 +------------------------+ Thread::stack_base()
//
// ** P1 (aka bottom) and size ( P2 = P1 - size) are the address and stack size returned from
//    pthread_attr_getstack()
</pre>
<p>
<code>図3</code>
</p>

<p>
図の内容によるとJavaスレッドと非Javaスレッドのスタックページ構成が若干異なる。
以下はJVMの非Javaスレッドのリストです。
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">VM thread</td>
<td class="left">JVM自身のコアスレッド</td>
</tr>

<tr>
<td class="left">Periodic task thread</td>
<td class="left">WatcherThreadのシングルトンインスタンス、定義的なVMタスクを実行する</td>
</tr>

<tr>
<td class="left">GC threads</td>
<td class="left">その名の通りです、メモリ管理自動化役を務める</td>
</tr>

<tr>
<td class="left">Compiler threads</td>
<td class="left">ByteCodeからアセンブラにコンパイルするスレッド</td>
</tr>

<tr>
<td class="left">Signal dispatcher thread</td>
<td class="left">外部からシグナルをハンドリングする役を務める</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> glibc guard page</h3>
<div class="outline-text-3" id="text-4-1">
<p>
<code>glibc guard page</code> はスタックポインタのオーバーフローを防ぐためのものです。Javaスレッ
ドには <code>HotSpot Guard Pages</code> が別途用意されているため、この領域のサイズが0である。非
Javaスレッドのスタック頂上位置には1ページ分が割り当てられる。以下はその実装内容です。
</p>

<ul class="org-ul">
<li><a href="http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/9b0ca45cd756/src/os/linux/vm/os_linux.cpp#l923">pthread_attr_setguardsize(&amp;attr, os::Linux::default_guard_size(thr_type));</a>
</li>
<li><a href="http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/9b0ca45cd756/src/os_cpu/linux_x86/vm/os_linux_x86.cpp#l662">os::Linux::default_guard_size(thr_type)</a>
</li>
</ul>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #8cc4ff;">size_t</span> <span style="color: #e6a8df;">os</span>::<span style="color: #e6a8df;">Linux</span>::<span style="color: #fce94f;">default_guard_size</span>(<span style="color: #e6a8df;">os</span>::<span style="color: #8cc4ff;">ThreadType</span> <span style="color: #fcaf3e;">thr_type</span>) {
  <span style="color: #73d216;">// </span><span style="color: #73d216;">Creating guard page is very expensive. Java thread has HotSpot</span>
  <span style="color: #73d216;">// </span><span style="color: #73d216;">guard page, only enable glibc guard page for non-Java threads.</span>
  <span style="color: #b4fa70;">return</span> (thr_type == java_thread ? 0 : page_size());
}
</pre>
</div>

<p>
<code>glibc guard page</code> に関して以下の情報が参考になると思います。
</p>
<ul class="org-ul">
<li>スタックガードの大きさの設定
</li>
<li><a href="http://linuxjm.sourceforge.jp/html/LDP_man-pages/man3/pthread_attr_setguardsize.3.html">PTHREAD_ATTR_SETGUARDSIZE</a>
</li>
<li><a href="http://codezine.jp/article/detail/1970">pthreadについて（スタックサイズ）</a>
</li>
<li><a href="http://www.nminoru.jp/~nminoru/programming/stackoverflow_handling.html#get-stack-region">スタックオーバーフローのハンドリング (Stack Overflow Handling)</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> HotSpot Guard Pages</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Javaスレッドスタックオーバーフローを検出するために書き込み不可の <code>HotSpot Guard
Pages</code> ページがスタック領域のトップ位置に設けている。また <code>HotSpot Guard Pages</code> は
<code>StackYellowPages</code> と <code>StackRedPages</code> から構成されている。
</p>

<p>
<code>StackYellowPages</code> はスタックポインタのスタックオーバーフローの緩衝域として、余分のメ
モリーを割り当てます。 <code>StackRedPages</code> まで行くとStackOverflowErrorが起きる。
</p>

<p>
以下は構成イメージです。
</p>
<pre class="example">
          +------------------------+
         /|                        |\
HotSpot / |    StackRedPages       | - 1ページ (4Kb)
Guard  /  |                        |/
Pages     +------------------------+
       \  |                        |\
        \ |    StackYellowPages    | - 2ページ (8Kb)
         \|                        |/
          +------------------------+
          |                        |
          |      Normal Stack      |
          |                        |
          +------------------------+
</pre>
<p>
<code>図4</code>
</p>

<p>
Linux/x86_64環境に置いて、 <code>StackYellowPages</code> と <code>StackRedPages</code> の初期値が2と1である。
<code>-XX:StackYellowPages</code> と <code>-XX:StackRedPages</code> パラメータで変更することが可能である。
</p>

<p>
下記は <code>HotSpot Guard Pages</code> の割当処理ロジックです。
</p>

<p>
<a href="http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/9b0ca45cd756/src/share/vm/runtime/thread.cpp#l2257">jdk7:openjdk/hotspot/src/share/vm/runtime/thread.cpp</a>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #73d216;">// </span><span style="color: #73d216;">&#9733;Java&#12473;&#12524;&#12483;&#12489;&#36215;&#21205;&#26178;&#12398;&#12460;&#12540;&#12489;&#12506;&#12540;&#12472;&#12469;&#12452;&#12474;&#20301;&#32622;&#12420;&#12469;&#12452;&#12474;&#12398;&#35336;&#31639;&#20966;&#29702;</span>
<span style="color: #8cc4ff;">void</span> <span style="color: #e6a8df;">JavaThread</span>::<span style="color: #fce94f;">create_stack_guard_pages</span>() {
  <span style="color: #b4fa70;">if</span> (! <span style="color: #e6a8df;">os</span>::uses_stack_guard_pages() || _stack_guard_state != stack_guard_unused) <span style="color: #b4fa70;">return</span>;

  <span style="color: #73d216;">// </span><span style="color: #73d216;">&#9733; &#12460;&#12540;&#12489;&#12506;&#12540;&#12472;&#12398;&#20301;&#32622;&#12392;&#12469;&#12452;&#12474;&#12398;&#35336;&#31639;</span>
  <span style="color: #8cc4ff;">address</span> <span style="color: #fcaf3e;">low_addr</span> = stack_base() - stack_size();
  <span style="color: #8cc4ff;">size_t</span> <span style="color: #fcaf3e;">len</span> = (StackYellowPages + StackRedPages) * <span style="color: #e6a8df;">os</span>::vm_page_size();

  <span style="color: #73d216;">// </span><span style="color: #73d216;">&#9733; &#12460;&#12540;&#12489;&#12506;&#12540;&#12472;&#21106;&#24403;&#20966;&#29702;&#12399;&#12503;&#12521;&#12483;&#12488;&#12501;&#12457;&#12540;&#12512;&#20381;&#23384;&#12398;&#12383;&#12417;&#12289;&#21029;&#38306;&#25968;&#12434;&#12467;&#12540;&#12523;</span>
  <span style="color: #8cc4ff;">int</span> <span style="color: #fcaf3e;">allocate</span> = <span style="color: #e6a8df;">os</span>::allocate_stack_guard_pages();
  <span style="color: #73d216;">// </span><span style="color: #73d216;">warning("Guarding at " PTR_FORMAT " for len " SIZE_FORMAT "\n", low_addr, len);</span>

  <span style="color: #b4fa70;">if</span> (allocate &amp;&amp; !<span style="color: #e6a8df;">os</span>::create_stack_guard_pages((<span style="color: #8cc4ff;">char</span> *) low_addr, len)) {
    warning(<span style="color: #e9b96e;">"Attempt to allocate stack guard pages failed."</span>);
    <span style="color: #b4fa70;">return</span>;
  }

  <span style="color: #b4fa70;">if</span> (<span style="color: #e6a8df;">os</span>::guard_memory((<span style="color: #8cc4ff;">char</span> *) low_addr, len)) {
    _stack_guard_state = stack_guard_enabled;
  } <span style="color: #b4fa70;">else</span> {
    warning(<span style="color: #e9b96e;">"Attempt to protect stack guard pages failed."</span>);
    <span style="color: #b4fa70;">if</span> (<span style="color: #e6a8df;">os</span>::uncommit_memory((<span style="color: #8cc4ff;">char</span> *) low_addr, len)) {
      warning(<span style="color: #e9b96e;">"Attempt to deallocate stack guard pages failed."</span>);
    }
  }
}
</pre>
</div>

<p>
<a href="http://hg.openjdk.java.net/jdk7u/jdk7u60/hotspot/file/ba66650acf63/src/os/linux/vm/os_linux.cpp#l3062">jdk7u60:openjdk/hotspot/src/os/linux/vm/os_linux.cpp</a>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #73d216;">// </span><span style="color: #73d216;">&#9733;Linuxu&#23554;&#29992;&#12398;&#12460;&#12540;&#12489;&#12506;&#12540;&#12472;&#21106;&#24403;&#20966;&#29702;</span>
<span style="color: #8cc4ff;">bool</span> <span style="color: #e6a8df;">os</span>::<span style="color: #fce94f;">pd_create_stack_guard_pages</span>(<span style="color: #8cc4ff;">char</span>* <span style="color: #fcaf3e;">addr</span>, <span style="color: #8cc4ff;">size_t</span> <span style="color: #fcaf3e;">size</span>) {

  <span style="color: #b4fa70;">if</span> (<span style="color: #e6a8df;">os</span>::<span style="color: #e6a8df;">Linux</span>::is_initial_thread()) {
    <span style="color: #73d216;">// </span><span style="color: #73d216;">As we manually grow stack up to bottom inside create_attached_thread(),</span>
    <span style="color: #73d216;">// </span><span style="color: #73d216;">it's likely that os::Linux::initial_thread_stack_bottom is mapped and</span>
    <span style="color: #73d216;">// </span><span style="color: #73d216;">we don't need to do anything special.</span>
    <span style="color: #73d216;">// </span><span style="color: #73d216;">Check it first, before calling heavy function.</span>
    <span style="color: #8cc4ff;">uintptr_t</span> <span style="color: #fcaf3e;">stack_extent</span> = (<span style="color: #8cc4ff;">uintptr_t</span>) <span style="color: #e6a8df;">os</span>::<span style="color: #e6a8df;">Linux</span>::initial_thread_stack_bottom();
    <span style="color: #8cc4ff;">unsigned</span> <span style="color: #8cc4ff;">char</span> <span style="color: #fcaf3e;">vec</span>[1];

    <span style="color: #b4fa70;">if</span> (mincore((<span style="color: #8cc4ff;">address</span>)stack_extent, <span style="color: #e6a8df;">os</span>::vm_page_size(), vec) == -1) {
      <span style="color: #73d216;">// </span><span style="color: #73d216;">Fallback to slow path on all errors, including EAGAIN</span>
      stack_extent = (<span style="color: #8cc4ff;">uintptr_t</span>) get_stack_commited_bottom(
                                    <span style="color: #e6a8df;">os</span>::<span style="color: #e6a8df;">Linux</span>::initial_thread_stack_bottom(),
                                    (<span style="color: #8cc4ff;">size_t</span>)addr - stack_extent);
    }

    <span style="color: #b4fa70;">if</span> (stack_extent &lt; (<span style="color: #8cc4ff;">uintptr_t</span>)addr) {
      ::munmap((<span style="color: #8cc4ff;">void</span>*)stack_extent, (<span style="color: #8cc4ff;">uintptr_t</span>)(addr - stack_extent));
    }
  }

  <span style="color: #73d216;">// </span><span style="color: #73d216;">&#9733;&#12371;&#12371;&#12363;&#12425; mmap&#12471;&#12473;&#12486;&#12512;&#12467;&#12540;&#12523;&#12364;&#30330;&#34892;&#12373;&#12428;&#12427;&#12290;</span>
  <span style="color: #73d216;">//  </span><span style="color: #73d216;">&#26368;&#24460;&#12398;&#24341;&#25968;&#12395;&#26360;&#12365;&#36796;&#12415;&#19981;&#21487;&#12398;&#12501;&#12521;&#12464;&#12364;&#20184;&#19982;&#12373;&#12428;&#12383;</span>
  <span style="color: #b4fa70;">return</span> <span style="color: #e6a8df;">os</span>::commit_memory(addr, size, !ExecMem);
}
</pre>
</div>

<p>
以下は <code>JBoss AS7</code> アプリケーションサーバ実行時、ワーカスレッドのスタック仮想メモリ割
当状況です。
</p>

<pre class="example">
$ cat /proc/`ps -ef | grep [j]boss.modules.system | awk '{print $2}'`/smaps
...省略...
7ff751076000-7ff751079000 ---p 00000000 00:00 0
Size:                 12 kB    ★説明: StackRedPages(4Kb) + StackYellowPages(8Kb) = 12Kb
Rss:                   0 kB
Pss:                   0 kB
Shared_Clean:          0 kB
Shared_Dirty:          0 kB
Private_Clean:         0 kB
Private_Dirty:         0 kB
Referenced:            0 kB
Anonymous:             0 kB
AnonHugePages:         0 kB
Swap:                  0 kB
KernelPageSize:        4 kB
MMUPageSize:           4 kB
Locked:                0 kB
VmFlags: mr mw me ac          ★説明:書き込み不可
7ff751079000-7ff751177000 rw-p 00000000 00:00 0                          [stack:21275]
Size:               1016 kB   ★説明: ここからNormal Stackページ
Rss:                 108 kB
Pss:                 108 kB
Shared_Clean:          0 kB
Shared_Dirty:          0 kB
Private_Clean:         0 kB
Private_Dirty:       108 kB
Referenced:          108 kB
Anonymous:           108 kB
AnonHugePages:         0 kB
Swap:                  0 kB
KernelPageSize:        4 kB
MMUPageSize:           4 kB
Locked:                0 kB
VmFlags: rd wr mr mw me ac
...省略...
</pre>

<p>
次のSystemTapスクリプトで <code>HotSpot Guard Pages</code> の割当処理をトレースしてみた。
</p>

<p>
<code>jvm_memory_trace.stp</code>
</p>
<pre class="example">
#!/usr/bin/stap -p4
probe process("/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/server/libjvm.so").function("commit_memory_impl")
{
   printf("---------------------------------------------------------\n")
   printf("%d\t%s\n", tid(), $$parms)
   print_ustack(ubacktrace())
}
</pre>

<p>
出力結果
</p>
<pre class="example">
  |$ stap jvm_memory_trace.stp -c "java  -version"
  |Using a compile server.
  |WARNING: Missing unwind data for module, rerun with 'stap -d ...dk-1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/jli/libjli.so'
  |WARNING: Missing unwind data for module, rerun with 'stap -d /usr/lib64/libpthread-2.17.so'
  |java version "1.7.0_75"
  |OpenJDK Runtime Environment (rhel-2.5.4.7.el7_1-x86_64 u75-b13)
  |OpenJDK 64-Bit Server VM (build 24.75-b04, mixed mode)
  |
  |★省略★
  |--------------------------------------------------------------------------------------------------------------
①|12179   exec=0x0 size=0x3000 addr=0x7f1d05b57000  ★commit_memory_impl関数実行時の引数情報
  | 0x7f1d04808371 : _ZN2os16pd_commit_memoryEPcmb+0x1/0xf0 [...1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/server/libjvm.so]
  | 0x7f1d04802dee : _ZN2os13commit_memoryEPcmb+0x2e/0xd0 [...1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/server/libjvm.so]
②| 0x7f1d048092df : _ZN2os27pd_create_stack_guard_pagesEPcm+0x7f/0x180 [...1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/server/libjvm.so]
  | 0x7f1d04945519 : _ZN7Threads9create_vmEP14JavaVMInitArgsPb+0x339/0x1550 [...1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/server/libjvm.so]
  | 0x7f1d0463fca7 : JNI_CreateJavaVM+0x67/0x2a0 [...1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/server/libjvm.so]
  | 0x7f1d0562aa68 : 0x7f1d0562aa68 [...dk-1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/jli/libjli.so+0x2a68/0x20e000]
  |--------------------------------------------------------------------------------------------------------------
  |★以降は省略★
</pre>

<p>
出力結果に①の <a href="http://hg.openjdk.java.net/jdk7u/jdk7u60/hotspot/file/ba66650acf63/src/os/linux/vm/os_linux.cpp#l2728">commit_memory_impl</a> 仮想メモリ割当処理の第２引数にメモリサイズを指定し
ています。 <code>size=0x3000</code> の値が16進数ですので、10進数に変換すると12Kbです。予測通りで
すね。
</p>

<p>
gdbを用いて上記出力結果から②のソースコード位置を特定する方法を以下に示す。
</p>
<pre class="example">
$ gdb /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/server/libjvm.so
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-64.el7
★一部内容省略★
Reading symbols from /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/server/libjvm.so...Reading symbols from /usr/lib/debug/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/server/libjvm.so.debug...done.
done.
★出力結果から関数名ぽいの文字列で関数を探す
(gdb) info functions pd_create_stack_guard_pages
All functions matching regular expression "pd_create_stack_guard_pages":

★検索結果
File /usr/src/debug/java-1.7.0-openjdk-1.7.0.75-2.5.4.7.el7_1.x86_64/openjdk/hotspot/src/os/linux/vm/os_linux.cpp:
bool os::pd_create_stack_guard_pages(char*, unsigned long);
(gdb)
</pre>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> Normal Stack</h3>
<div class="outline-text-3" id="text-4-3">
<p>
Javaスレッドを前提に置いて、 <code>Normal Stack</code> には通常Javaメソッド実行時のフレーム情報
が格納される。ただし、スレッドからC/C++メソッドを実行する時も <code>Normal Stack</code> が利用さ
れる。スタックのトップ位置にC/C++メソッド実行用の <code>StackShadowPages</code> が設けられている。
Linux/x86_64環境に置いて <code>StackShadowPages</code> の初期値が20である。
</p>

<pre class="example">
              +------------------------+
             /|                        |\
            / |    StackShadowPages    | -XX:StackShadowPages=20(80Kb)
           /  |                        |/ ★Native Stackはここです!
          /   +------------------------+
         /    |                        |
        /     |   +----------------+   |  ★Java Stackはここです！
Normal Stack  |   |     Frame      |   |
        \     |   +----------------+   |
         \    |   |     Frame      |   |
          \   |   +----------------+   |
           \  |   |     Frame      |   |
            \ |   +----------------+   |
             \|                        |
              +------------------------+
</pre>
<p>
<code>図5</code>
</p>

<p>
以下は <code>StackShadowPages</code> 初期値の代入処理ロジックです。
</p>

<p>
<a href="http://hg.openjdk.java.net/jdk7u/jdk7u60/hotspot/file/ba66650acf63/src/cpu/x86/vm/globals_x86.hpp#l60">jdk7:hotspot/src/cpu/x86/vm/globals_x86.hpp#l60</a>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #ad7fa8;">#ifdef</span> AMD64
<span style="color: #73d216;">// </span><span style="color: #73d216;">Very large C++ stack frames using solaris-amd64 optimized builds</span>
<span style="color: #73d216;">// </span><span style="color: #73d216;">due to lack of optimization caused by C++ compiler bugs</span>
define_pd_global(intx, StackShadowPages, NOT_WIN64(20) WIN64_ONLY(6) DEBUG_ONLY(+2));
<span style="color: #ad7fa8;">#else</span>
define_pd_global(intx, StackShadowPages, 6 DEBUG_ONLY(+5));
<span style="color: #ad7fa8;">#endif</span> <span style="color: #73d216;">// </span><span style="color: #73d216;">AMD64</span>
</pre>
</div>

<p>
<code>StackShadowPages</code> に関して以下の情報が参考になると思います。
</p>
<ul class="org-ul">
<li><a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/crashes.html#gbyzz">Troubleshooting Guide for HotSpot VM 4.1.3 Crash due to Stack Overflow</a>
</li>
<li><a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=7059899a">JDK-7059899 : Stack overflows in Java code cause 64-bit JVMs to exit due to SIGSEGV</a>
</li>
<li><a href="https://access.redhat.com/solutions/698483">What does the StackShadowPages JVM setting do?</a>
<pre class="example">
StackShadowPages reserves a portion of the thread stack for native layer
allocations. The page size usually is 4096b, which mean that 20 pages would occupy
80Kb. The thread stack is sized through -Xss.

Consider some config examples:

   -Xss1024k -XX:StackShadowPages=10

   [       984kb java stack    | 40kb native stack]

   -Xss1024k -XX:StackShadowPages=20

   [       944kb java stack    |   80kb native stack]

   -Xss512k -XX:StackShadowPages=10

   [ 472kb java stack | 40kb native stack]

If you decrease just -Xss, the overall stack is decreased, but the StackShadowPages
native reservation is not; only the java portion would lose space. Likewise if you
only increase -Xss, only the java portion gains space with the increased stack.

If you increase StackShadowPages, the java portion becomes smaller so that the native
portion can be larger. If the native portion of a stack is exhausted, the JVM can
fatally crash so sometimes StackShadowPages needs to be increased.
</pre>
</li>
</ul>
</div>
</div>
</div>




<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> スタックサイズの制御</h2>
<div class="outline-text-2" id="text-5">
<p>
従いましてJava Methodに使えるスタック領域(Java Stack)のサイズは次の式で計算出来る。
</p>
<font color="red"><strong>
<p>
Java Satck Size = Thread::stack_size() - ((StackRedPages + StackYellowPages + StackShadowPages) * PageSize)
</p>
</strong></font>

<p>
<code>Thread::stack_size()</code> の値はスレッド起動時にglibcの <a href="http://linuxjm.sourceforge.jp/html/LDP_man-pages/man3/pthread_attr_setstacksize.3.html">pthread_attr_setstacksize</a> 関数を
用いて設定される。以下はHotSpotの実装です。
</p>

<ol class="org-ol">
<li>JVM起動時に実行される処理
<a href="http://hg.openjdk.java.net/jdk7u/jdk7u60/hotspot/file/ba66650acf63/src/os/linux/vm/os_linux.cpp#l4820">jdk7/hotspot/src/os/linux/vm/os_linux.cpp#4820</a>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #73d216;">// </span><span style="color: #73d216;">this is called _after_ the global arguments have been parsed</span>
<span style="color: #8cc4ff;">jint</span> <span style="color: #e6a8df;">os</span>::<span style="color: #fce94f;">init_2</span>(<span style="color: #8cc4ff;">void</span>)
{
  &#9733;&#19968;&#37096;&#30465;&#30053;&#9733;


  &#9733;&#12473;&#12524;&#12483;&#12489;&#12395;&#21106;&#24403;&#12427;&#12473;&#12479;&#12483;&#12463;&#12469;&#12452;&#12474;&#12398;&#26368;&#23567;&#35377;&#23481;&#20516;&#12398;&#35336;&#31639;

  <span style="color: #73d216;">// </span><span style="color: #73d216;">Check minimum allowable stack size for thread creation and to initialize</span>
  <span style="color: #73d216;">// </span><span style="color: #73d216;">the java system classes, including StackOverflowError - depends on page</span>
  <span style="color: #73d216;">// </span><span style="color: #73d216;">size.  Add a page for compiler2 recursion in main thread.</span>
  <span style="color: #73d216;">// </span><span style="color: #73d216;">Add in 2*BytesPerWord times page size to account for VM stack during</span>
  <span style="color: #73d216;">// </span><span style="color: #73d216;">class initialization depending on 32 or 64 bit VM.</span>
  <span style="color: #e6a8df;">os</span>::<span style="color: #e6a8df;">Linux</span>::min_stack_allowed = MAX2(<span style="color: #e6a8df;">os</span>::<span style="color: #e6a8df;">Linux</span>::min_stack_allowed,
            (<span style="color: #8cc4ff;">size_t</span>)(StackYellowPages+StackRedPages+StackShadowPages) * <span style="color: #e6a8df;">Linux</span>::page_size() +
                    (2*BytesPerWord COMPILER2_PRESENT(+1)) * <span style="color: #e6a8df;">Linux</span>::vm_default_page_size());

<span style="color: #ad7fa8;">#ifdef</span> ZERO
  <span style="color: #73d216;">// </span><span style="color: #73d216;">If this is Zero, allow at the very minimum one page each for the</span>
  <span style="color: #73d216;">// </span><span style="color: #73d216;">Zero stack and the native stack.  This won't make any difference</span>
  <span style="color: #73d216;">// </span><span style="color: #73d216;">for 4k pages, but is significant for large pages.</span>
  <span style="color: #e6a8df;">os</span>::<span style="color: #e6a8df;">Linux</span>::min_stack_allowed = MAX2(<span style="color: #e6a8df;">os</span>::<span style="color: #e6a8df;">Linux</span>::min_stack_allowed,
             (<span style="color: #8cc4ff;">size_t</span>)(StackYellowPages+StackRedPages+StackShadowPages+2) * <span style="color: #e6a8df;">Linux</span>::page_size());
<span style="color: #ad7fa8;">#endif</span>

  <span style="color: #8cc4ff;">size_t</span> <span style="color: #fcaf3e;">threadStackSizeInBytes</span> = ThreadStackSize * K;
  <span style="color: #b4fa70;">if</span> (threadStackSizeInBytes != 0 &amp;&amp;
      threadStackSizeInBytes &lt; <span style="color: #e6a8df;">os</span>::<span style="color: #e6a8df;">Linux</span>::min_stack_allowed) {
        tty-&gt;print_cr(<span style="color: #e9b96e;">"\nThe stack size specified is too small, "</span>
                      <span style="color: #e9b96e;">"Specify at least %dk"</span>,
                      <span style="color: #e6a8df;">os</span>::<span style="color: #e6a8df;">Linux</span>::min_stack_allowed/ K);
        <span style="color: #b4fa70;">return</span> JNI_ERR;
  }

  &#9733;-XX:ThreadStackSize&#12398;&#20516;&#12434;&#38745;&#30340;_stack_size_at_create&#22793;&#25968;&#12395;&#20195;&#20837;&#12377;&#12427;
  <span style="color: #73d216;">// </span><span style="color: #73d216;">Make the stack size a multiple of the page size so that</span>
  <span style="color: #73d216;">// </span><span style="color: #73d216;">the yellow/red zones can be guarded.</span>
  <span style="color: #e6a8df;">JavaThread</span>::set_stack_size_at_create(round_to(threadStackSizeInBytes,
        vm_page_size()));

  &#9733;&#12452;&#12491;&#12471;&#12515;&#12523;&#12473;&#12524;&#12483;&#12489;&#12398;&#12473;&#12479;&#12483;&#12463;&#12469;&#12452;&#12474;&#35373;&#23450;&#20966;&#29702;&#65288;&#9733;TODO: &#21029;&#36884;&#35519;&#26619;&#12377;&#12427;&#65289;
  <span style="color: #e6a8df;">Linux</span>::capture_initial_stack(<span style="color: #e6a8df;">JavaThread</span>::stack_size_at_create());

  &#9733;&#20197;&#19979;&#12399;&#30465;&#30053;&#9733;
</pre>
</div>
</li>
<li>新規スレッド起動時の処理
<a href="http://hg.openjdk.java.net/jdk7u/jdk7u60/hotspot/file/ba66650acf63/src/os/linux/vm/os_linux.cpp#l901">jdk7:hotspot/src/os/linux/vm/os_linux.cpp#901</a>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #8cc4ff;">bool</span> <span style="color: #e6a8df;">os</span>::<span style="color: #fce94f;">create_thread</span>(<span style="color: #8cc4ff;">Thread</span>* <span style="color: #fcaf3e;">thread</span>, <span style="color: #8cc4ff;">ThreadType</span> <span style="color: #fcaf3e;">thr_type</span>, <span style="color: #8cc4ff;">size_t</span> <span style="color: #fcaf3e;">stack_size</span>) {

  &#9733;&#19968;&#37096;&#30465;&#30053;&#9733;

  <span style="color: #73d216;">// </span><span style="color: #73d216;">&#9733;&#12473;&#12524;&#12483;&#12489;&#31278;&#21029;&#27598;&#12395;&#12473;&#12479;&#12483;&#12463;&#12469;&#12452;&#12474;&#12434;&#27770;&#12417;&#12427;</span>
  <span style="color: #b4fa70;">if</span> (<span style="color: #e6a8df;">os</span>::<span style="color: #e6a8df;">Linux</span>::supports_variable_stack_size()) {
    <span style="color: #73d216;">// </span><span style="color: #73d216;">calculate stack size if it's not specified by caller</span>
    <span style="color: #b4fa70;">if</span> (stack_size == 0) {
      stack_size = <span style="color: #e6a8df;">os</span>::<span style="color: #e6a8df;">Linux</span>::default_stack_size(thr_type);

      <span style="color: #b4fa70;">switch</span> (thr_type) {

      <span style="color: #73d216;">//</span><span style="color: #73d216;">&#9733;Java&#12527;&#12540;&#12459;&#12473;&#12524;&#12483;&#12489;&#12398;&#22580;&#21512;</span>
      <span style="color: #b4fa70;">case</span> <span style="color: #e6a8df;">os</span>::java_thread:
        <span style="color: #73d216;">// </span><span style="color: #73d216;">Java threads use ThreadStackSize which default value can be</span>
        <span style="color: #73d216;">// </span><span style="color: #73d216;">changed with the flag -Xss</span>
        assert (<span style="color: #e6a8df;">JavaThread</span>::stack_size_at_create() &gt; 0, <span style="color: #e9b96e;">"this should be set"</span>);
        stack_size = <span style="color: #e6a8df;">JavaThread</span>::stack_size_at_create();
        <span style="color: #b4fa70;">break</span>;

      <span style="color: #73d216;">//</span><span style="color: #73d216;">&#9733;JIT&#12467;&#12531;&#12497;&#12452;&#12521;&#12473;&#12524;&#12483;&#12489;&#12398;&#22580;&#21512;</span>
      <span style="color: #b4fa70;">case</span> <span style="color: #e6a8df;">os</span>::compiler_thread:
        <span style="color: #b4fa70;">if</span> (CompilerThreadStackSize &gt; 0) {
          stack_size = (<span style="color: #8cc4ff;">size_t</span>)(CompilerThreadStackSize * K);
          <span style="color: #b4fa70;">break</span>;
        } <span style="color: #73d216;">// </span><span style="color: #73d216;">else fall through:</span>
          <span style="color: #73d216;">// </span><span style="color: #73d216;">use VMThreadStackSize if CompilerThreadStackSize is not defined</span>

      <span style="color: #73d216;">//</span><span style="color: #73d216;">&#9733;VM&#12473;&#12524;&#12483;&#12489;&#12289;GC&#12473;&#12524;&#12483;&#12489;&#12289;&#12454;&#12457;&#12483;&#12481;&#12515;&#12540;&#12473;&#12524;&#12483;&#12489;&#12398;&#22580;&#21512;</span>
      <span style="color: #b4fa70;">case</span> <span style="color: #e6a8df;">os</span>::vm_thread:
      <span style="color: #b4fa70;">case</span> <span style="color: #e6a8df;">os</span>::pgc_thread:
      <span style="color: #b4fa70;">case</span> <span style="color: #e6a8df;">os</span>::cgc_thread:
      <span style="color: #b4fa70;">case</span> <span style="color: #e6a8df;">os</span>::watcher_thread:
        <span style="color: #b4fa70;">if</span> (VMThreadStackSize &gt; 0) stack_size = (<span style="color: #8cc4ff;">size_t</span>)(VMThreadStackSize * K);
        <span style="color: #b4fa70;">break</span>;
      }
    }

    stack_size = MAX2(stack_size, <span style="color: #e6a8df;">os</span>::<span style="color: #e6a8df;">Linux</span>::min_stack_allowed);
    <span style="color: #73d216;">// </span><span style="color: #73d216;">&#9733;glic&#38306;&#25968;&#29992;&#12356;&#12390;stack&#38936;&#22495;&#12434;&#30906;&#20445;&#12377;&#12427;</span>
    pthread_attr_setstacksize(&amp;attr, stack_size);

   &#9733;&#20197;&#19979;&#12399;&#30465;&#30053;&#9733;
</pre>
</div>
</li>
</ol>

<p>
以上コードの通り、JVMから起動されたスレッドの種別毎のスタックサイズが下記XXパラメータ値が適用されてい
る。
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">引数</th>
<th scope="col" class="left">Linux/x86_64環境初期値</th>
<th scope="col" class="left">適用範囲</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">-XX:ThreadStackSize</td>
<td class="left">1M</td>
<td class="left">Javaスレッド</td>
</tr>

<tr>
<td class="left">-XX:VMThreadStackSize</td>
<td class="left">1M</td>
<td class="left">VM thread、GC threads、VM Periodic Task Threadなど</td>
</tr>

<tr>
<td class="left">-XX:CompilerThreadStackSize</td>
<td class="left">4M</td>
<td class="left">C1 C2 CompilerThread</td>
</tr>
</tbody>
</table>

<p>
以下は実機にて確認された各パラメータの初期値です。
</p>
<pre class="example">
$ java -XX:+PrintFlagsFinal -version | grep -e "CompilerThreadStackSize\|ThreadStackSize\|VMThreadStackSize"
     intx CompilerThreadStackSize                   = 0               {pd product}
     intx ThreadStackSize                           = 1024            {pd product}
     intx VMThreadStackSize                         = 1024            {pd product}
java version "1.7.0_75"
OpenJDK Runtime Environment (rhel-2.5.4.7.el7_1-x86_64 u75-b13)
OpenJDK 64-Bit Server VM (build 24.75-b04, mixed mode)
</pre>

<p>
<code>CompilerThreadStackSize</code> が指定しない場合下記コードにて初期値が代入される。
</p>

<p>
<a href="http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/9b0ca45cd756/src/os_cpu/linux_x86/vm/os_linux_x86.cpp#l652">jdk7:hotspot/src/os_cpu/linux_x86/vm/os_linux_x86.cpp#652</a>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #73d216;">// </span><span style="color: #73d216;">return default stack size for thr_type</span>
<span style="color: #8cc4ff;">size_t</span> <span style="color: #e6a8df;">os</span>::<span style="color: #e6a8df;">Linux</span>::<span style="color: #fce94f;">default_stack_size</span>(<span style="color: #e6a8df;">os</span>::<span style="color: #8cc4ff;">ThreadType</span> <span style="color: #fcaf3e;">thr_type</span>) {
  <span style="color: #73d216;">// </span><span style="color: #73d216;">default stack size (compiler thread needs larger stack)</span>
<span style="color: #ad7fa8;">#ifdef</span> AMD64
  <span style="color: #8cc4ff;">size_t</span> <span style="color: #fcaf3e;">s</span> = (thr_type == <span style="color: #e6a8df;">os</span>::compiler_thread ? 4 * M : 1 * M);
<span style="color: #ad7fa8;">#else</span>
  <span style="color: #8cc4ff;">size_t</span> <span style="color: #fcaf3e;">s</span> = (thr_type == <span style="color: #e6a8df;">os</span>::compiler_thread ? 2 * M : 512 * K);
<span style="color: #ad7fa8;">#endif</span> <span style="color: #73d216;">// </span><span style="color: #73d216;">AMD64</span>
  <span style="color: #b4fa70;">return</span> s;
}
</pre>
</div>

<p>
次のサンプルプログラムを実行して、各スレッドのスタックサイズ値を実測してみる。
</p>

<p>
<code>HelloWorld.java</code>
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #b4fa70;">public</span> <span style="color: #b4fa70;">class</span> <span style="color: #8cc4ff;">HelloWorld</span> <span style="color: #b4fa70;">implements</span> <span style="color: #8cc4ff;">Runnable</span> {

    <span style="color: #b4fa70;">public</span> <span style="color: #8cc4ff;">void</span> <span style="color: #fce94f;">run</span>(){
        <span style="color: #b4fa70;">while</span>(<span style="color: #e6a8df;">true</span>) {
            <span style="color: #b4fa70;">try</span> {
                Thread.sleep(1 * 1000L);
                System.out.println(Thread.currentThread().toString() + <span style="color: #e9b96e;">": Hello World"</span>);
            } <span style="color: #b4fa70;">catch</span> (<span style="color: #8cc4ff;">Exception</span> <span style="color: #fcaf3e;">e</span>) {
            }
        }
    }

    <span style="color: #b4fa70;">public</span> <span style="color: #b4fa70;">static</span> <span style="color: #8cc4ff;">void</span> <span style="color: #fce94f;">main</span>(<span style="color: #8cc4ff;">String</span>[] <span style="color: #fcaf3e;">args</span>) <span style="color: #b4fa70;">throws</span> <span style="color: #8cc4ff;">Exception</span> {
        <span style="color: #8cc4ff;">Thread</span>[] <span style="color: #fcaf3e;">t_arry</span> =  <span style="color: #b4fa70;">new</span> <span style="color: #8cc4ff;">Thread</span>[5];
        <span style="color: #b4fa70;">for</span> (<span style="color: #8cc4ff;">int</span> <span style="color: #fcaf3e;">i</span> = 0; i &lt; t_arry.<span style="color: #8cc4ff;">length</span>; i++) {
            t_arry[i]  =  <span style="color: #b4fa70;">new</span> <span style="color: #8cc4ff;">Thread</span>(<span style="color: #b4fa70;">new</span> <span style="color: #8cc4ff;">HelloWorld</span>());
            t_arry[i].start();
        }
        <span style="color: #b4fa70;">for</span> (<span style="color: #8cc4ff;">int</span> <span style="color: #fcaf3e;">i</span> = 0; i &lt; t_arry.<span style="color: #8cc4ff;">length</span>; i++) {
            t_arry[i].join();
        }

    }
}
</pre>
</div>

<p>
スタックサイズの実測値は次のスクリプトで取得しています。
</p>

<p>
<code>jvm_stacksize.sh</code>
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #73d216;">#</span><span style="color: #73d216;">!/bin/</span><span style="color: #b4fa70;">sh</span>

<span style="color: #b4fa70;">if</span> [ ! $<span style="color: #fcaf3e;">#</span> -eq 1 ]; <span style="color: #b4fa70;">then</span>
    <span style="color: #ad7fa8;">echo</span> <span style="color: #e9b96e;">"Usage ${0} &lt;JVM PID&gt;"</span>
    <span style="color: #b4fa70;">exit</span> 1
<span style="color: #b4fa70;">fi</span>

<span style="color: #ad7fa8;">printf</span> <span style="color: #e9b96e;">"[ PID ]\t[StackSize]\t[GuardPages]\t[Thread Name]\n"</span>

<span style="color: #73d216;"># </span><span style="color: #73d216;">jstack&#12398;&#20986;&#21147;&#32080;&#26524;&#12363;&#12425;&#12473;&#12524;&#12483;&#12489;ID&#12392;&#21517;&#21069;&#12434;&#25277;&#20986;&#12377;&#12427;</span>
jstack $<span style="color: #fcaf3e;">1</span> | grep nid | sed -e <span style="color: #e9b96e;">"s/^\"\(.*\)\".*nid=\(0x[0-9|a-z]*\).*$/\2,\1/"</span> | sort | <span style="color: #b4fa70;">while </span><span style="color: #ad7fa8;">read</span> line
<span style="color: #b4fa70;">do</span>
    <span style="color: #73d216;"># </span><span style="color: #73d216;">&#12473;&#12524;&#12483;&#12489;ID&#12434;&#20999;&#12426;&#20986;&#12377;</span>
    <span style="color: #fcaf3e;">pid_hex</span>=<span style="color: #fa8072;">`echo "${line}" | awk -F"," '{print $1}'`</span>

    <span style="color: #73d216;"># </span><span style="color: #73d216;">&#12473;&#12524;&#12483;&#12489;&#21517;&#12434;&#20999;&#12426;&#20986;&#12377;</span>
    <span style="color: #fcaf3e;">thread_name</span>=<span style="color: #fa8072;">`echo "${line}" | awk -F"," '{print $2}'`</span>

    <span style="color: #73d216;"># </span><span style="color: #73d216;">&#12473;&#12524;&#12483;&#12489;ID&#12434;10&#36914;&#25968;&#12395;&#22793;&#25563;</span>
    <span style="color: #fcaf3e;">pid</span>=<span style="color: #fa8072;">`printf '%d\n' ${pid_hex}`</span>

    <span style="color: #73d216;"># </span><span style="color: #73d216;">/proc/&lt;pid&gt;/smaps &#12501;&#12449;&#12452;&#12523;&#12363;&#12425;&#12473;&#12479;&#12483;&#12463;&#12469;&#12452;&#12474;&#12289;&#12460;&#12540;&#12489;&#12506;&#12540;&#12472;&#12469;&#12452;&#12474;&#12434;&#21462;&#24471;&#12377;&#12427;</span>
    <span style="color: #fcaf3e;">guard_page</span>=<span style="color: #fa8072;">`cat /proc/$1/smaps | grep -B15 "stack:${pid}"| head -1 | awk '{print $2}'`</span>
    <span style="color: #fcaf3e;">stack_page</span>=<span style="color: #fa8072;">`cat /proc/$1/smaps | grep -A1 "stack:${pid}" | tail -1 | awk '{print $2}'`</span>
    <span style="color: #fcaf3e;">stack_size</span>=<span style="color: #fa8072;">`expr ${guard_page} + ${stack_page}`</span>
    <span style="color: #ad7fa8;">printf</span> <span style="color: #e9b96e;">"%7d\t%11s\t%12s\t%s\n"</span> <span style="color: #e9b96e;">"${pid}"</span> <span style="color: #e9b96e;">"${stack_size}Kb"</span> <span style="color: #e9b96e;">"${guard_page}Kb"</span> <span style="color: #e9b96e;">"${thread_name}"</span>
<span style="color: #b4fa70;">done</span>
</pre>
</div>

<p>
スタックサイズを明示的に指定して、サンプルを実行する。
</p>
<ul class="org-ul">
<li>-XX:ThreadStackSize=512
</li>
<li>-XX:VMThreadStackSize: 2048
</li>
<li>-XX:CompilerThreadStackSize=3072
</li>
</ul>
<pre class="example">
java -XX:VMThreadStackSize=2048 -XX:CompilerThreadStackSize=3072 -XX:ThreadStackSize=512 HelloWorld
Thread[Thread-0,5,main]: Hello World
Thread[Thread-4,5,main]: Hello World
Thread[Thread-1,5,main]: Hello World
Thread[Thread-3,5,main]: Hello World
Thread[Thread-2,5,main]: Hello World
★以降は省略
</pre>

<p>
測定結果
</p>
<pre class="example">
$ ./jvm_stacksize.sh `ps -ef | grep "[j]ava.*HelloWorld" | awk '{print $2}'`
[ PID ] [StackSize] [GuardPages]    [Thread Name]
  17285      1048Kb         12Kb    main
  17286      2096Kb          4Kb    GC task thread#0 (ParallelGC)
  17287      2052Kb          4Kb    GC task thread#1 (ParallelGC)
  17288      2052Kb          4Kb    GC task thread#2 (ParallelGC)
  17289      2052Kb          4Kb    GC task thread#3 (ParallelGC)
  17290      2052Kb          4Kb    VM Thread
  17291     64584Kb         12Kb    Reference Handler
  17292       516Kb         12Kb    Finalizer
  17293       516Kb         12Kb    Signal Dispatcher
  17294      3076Kb         12Kb    C2 CompilerThread0
  17295      3076Kb         12Kb    C2 CompilerThread1
  17296       516Kb         12Kb    Service Thread
  17297      2052Kb          4Kb    VM Periodic Task Thread
  17298       516Kb         12Kb    Thread-0
  17299       516Kb         12Kb    Thread-1
  17300       516Kb         12Kb    Thread-2
  17301       516Kb         12Kb    Thread-3
  17302       516Kb         12Kb    Thread-4
  17342       516Kb         12Kb    Attach Listener
</pre>

<p>
実測値はXXパラメータで指定した値より１ページ分多い。これは <code>glibc</code> 内部の
<a href="https://www.sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=nptl/allocatestack.c;h=8e620c46e9523092a5cf141e77f35c94dcfd9810;hb=HEAD#l349">allocate_stack</a> 処理で追加されているものです。
</p>
</div>
</div>




<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> ulimit -sの影響範囲</h2>
<div class="outline-text-2" id="text-6">
<p>
Linux環境に置いて、JVM内のスレッドは全てglibcの <code>pthread_create</code> 関数経由で起動される。
スレッド起動時にスタックサイズ明示的に指定していない場合、 <code>ulimit -s</code> で設定された値
がスタックのデフォルトサイズとして適用される。前文に書いた通りJVMはスレッド起動時に明
示的 <code>pthread_attr_setstacksize</code> 関数でXXパラメータ値の元にスタックサイズを指定してい
るため、これらのスレッドのスタックサイズは <code>ulimit -s</code> の値に影響されないだ。
</p>

<p>
ただし、JVMランチャー自身は <code>ulimit -s</code> の制限値が適用される。
</p>

<p>
<code>ulimit</code> コマンドでスタックの上限値 <code>RLIMIT_STACK</code> を64Kbを設定し、サンプルプログラム
グライムを実行すると、ランチャーのスタックサイズが60Kbで収まった。
</p>
<pre class="example">
$ ulimit -s 64
$ java -Xss1024K -XX:VMThreadStackSize=2048 -XX:CompilerThreadStackSize=3072 -XX:ThreadStackSize=512 HelloWorld
Thread[Thread-1,5,main]: Hello World
Thread[Thread-3,5,main]: Hello World
Thread[Thread-0,5,main]: Hello World
Thread[Thread-2,5,main]: Hello World
Thread[Thread-4,5,main]: Hello World
★省略
</pre>

<p>
<code>pmap</code> コマンドで仮想メモリマップの最上位アドレス近くにランチャーのスタックサイズを確
認することができる。
</p>
<pre class="example">
$ pmap `ps -ef | grep "[j]ava.*HelloWorld" | awk '{print $2}'`
★省略
00007f39d068d000      4K r---- ld-2.17.so
00007f39d068e000      4K rw--- ld-2.17.so
00007f39d068f000      4K rw---   [ anon ]
00007fff7cf79000     60K rw---   [ stack ] ★ランチャーのスタックサイズ
00007fff7cffe000      8K r-x--   [ anon ]
ffffffffff600000      4K r-x--   [ anon ]
 total          3513684K
</pre>

<p>
JVM内の各スレッドのスタックサイズは下記の通りです、 <code>RLIMIT_STACK</code> に影響されていない
ことが分かります。
</p>
<pre class="example">
]$ ./jvm_stacksize.sh `ps -ef | grep "[j]ava.*HelloWorld" | awk '{print $2}'`
[ PID ] [StackSize] [GuardPages]    [Thread Name]
  10770      1048Kb         12Kb    main
  10771      2096Kb          4Kb    GC task thread#0 (ParallelGC)
  10772      2052Kb          4Kb    GC task thread#1 (ParallelGC)
  10773      2052Kb          4Kb    GC task thread#2 (ParallelGC)
  10774      2052Kb          4Kb    GC task thread#3 (ParallelGC)
  10775     15812Kb          4Kb    VM Thread
  10776       516Kb         12Kb    Reference Handler
  10777     63556Kb         12Kb    Finalizer
  10778       516Kb         12Kb    Signal Dispatcher
  10779      3076Kb         12Kb    C2 CompilerThread0
  10780      3076Kb         12Kb    C2 CompilerThread1
  10781       516Kb         12Kb    Service Thread
  10782      2052Kb          4Kb    VM Periodic Task Thread
  10783       516Kb         12Kb    Thread-0
  10784       516Kb         12Kb    Thread-1
  10785       516Kb         12Kb    Thread-2
  10786       516Kb         12Kb    Thread-3
  10787       516Kb         12Kb    Thread-4
  11203       516Kb         12Kb    Attach Listener
</pre>
</div>
</div>




<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> -Xssと-XX:ThreadStackSizeの違い</h2>
<div class="outline-text-2" id="text-7">
<p>
<code>-Xss</code> と <code>-XX:ThreadStackSize</code> 両方ともJavaスレッドのスタックを指定するパラメータで
ある。 ただし、JVMランチャーから起動されたイニシャルスレッドのスタックサイズの制御は
<code>-Xss</code> パラメータのみできる。
</p>

<p>
以下はJVMランチャーからイニシャルスレッド起動するまでの流れ
</p>
<pre class="example">
行
 | ★ランチャーの実行
1| openjdk/jdk/src/share/bin/main.c:93           ==&gt; int main(int, char **);
2| openjdk/jdk/src/share/bin/java.c:170            ==&gt; int JLI_Launch(int, char **, int, const char **, int, const char **, const char *, const char *, const char *, const char *, jboolean, jboolean, jboolean, jint);
3| openjdk/jdk/src/share/bin/java.c:1835             ==&gt; int ContinueInNewThread(InvocationFunctions *, jlong, int, char **, int, char *, int);
 | ★イニシャルスレッド起動
4| openjdk/jdk/src/solaris/bin/java_md_solinux.c:1021  ==&gt; int ContinueInNewThread0(int (JNICALL *continuation)(void *), jlong stack_size, void * args)
5| openjdk/jdk/src/share/bin/java.c:337                  ==&gt; int JavaMain(void *);
 | openjdk/jdk/src/share/bin/java.c:1097                 ==&gt; jboolean InitializeJVM(JavaVM **pvm, JNIEnv **penv, InvocationFunctions *ifn)
6| openjdk/hotspot/src/share/vm/prims/jni.cpp            ==&gt; jint JNI_CreateJavaVM(JavaVM**, void**, void*);
7| openjdk/hotspot/src/share/vm/runtime/thread.cpp:3271    ==&gt; jint Threads::create_vm(JavaVMInitArgs*, bool*);
8| openjdk/hotspot/src/os/linux/vm/os_linux.cpp:4898         ==&gt; jint os::init_2(void)
9| openjdk/hotspot/src/os/linux/vm/os_linux.cpp:1205           ==&gt; void os::Linux::capture_initial_stack(size_t max_size)
</pre>

<ul class="org-ul">
<li>行1: JVMランチャーのmain関数
</li>
<li>行2: <code>JLI_Launch</code> 関数にてコマンドラインパラメータのパーシング処理が実行される。
</li>
<li>行3: <code>-Xss</code> パラメータが指定されていない場合、デフォルト値(1024Kb)を取得し(4)に渡す。
</li>
<li>行4: glibcの <code>pthread_create</code> 関数を用いてイニシャルスレッドを起動する。 <code>-Xss</code> の
値がスタックサイズに適用される。
</li>
</ul>

<p>
<code>-Xss</code> と <code>-XX:ThreadStackSize</code> 片方指定する場合、と両方指定する場合効果が違うので要注意です。
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">&#xa0;</th>
<th scope="col" class="left">イニシャルスレッド</th>
<th scope="col" class="left">ワーカスレッド</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">-Xss2048K</td>
<td class="left">2048K</td>
<td class="left">2048K</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">-XX:ThreadStackSize=2048</td>
<td class="left">1024K</td>
<td class="left">2048K</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">-Xss2048K</td>
<td class="left">2048K</td>
<td class="left">512K</td>
</tr>

<tr>
<td class="left">-XX:ThreadStackSize=512</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 参考</h2>
<div class="outline-text-2" id="text-8">
<p>
本記事書く際に下記コンテンツを参考した。
</p>
<ul class="org-ul">
<li><a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2011-June/004272.html">What the difference between -Xss and -XX:ThreadStackSize is?</a>
</li>
<li><a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/toc.html">Troubleshooting Guide for HotSpot VM</a>
</li>
<li><a href="http://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html">HotSpot Runtime Overview</a>
</li>
<li><a href="http://xmlandmore.blogspot.jp/2014/09/jdk-8-thread-stack-size-tuning.html?m=1">JDK 8: Thread Stack Size Tuning </a>
</li>
<li><a href="http://www.slideshare.net/m0nstermind/java-runtime-jvm">Java Runtime: повседневные обязанности</a>
</li>
<li><a href="http://brakkee.org/site/2012/10/13/java-from-the-trenches-crash-free-and-responsive-servers/">Java from the trenches: improving reliability</a>
</li>
<li><a href="https://help.blackboard.com/en-us/Learn/9.1_SP_12_and_SP_13/Administrator/010_Release_Notes/020_SP_12_Release_Notes/Performance_and_Scalability/Recommended_JVM_Tuning_Set">Recommended JVM Tuning Set</a>
</li>
<li><a href="http://stackoverflow.com/questions/11025459/where-is-the-java-stack-allocated">where is the Java stack allocated?</a>
</li>
<li><a href="http://unix.stackexchange.com/questions/145557/how-does-stack-allocation-work-in-linux">How does stack allocation work in Linux?</a>
</li>
<li><a href="http://www.oracle.com/technetwork/articles/servers-storage-dev/mem-alloc-1557798.html">How Memory Allocation Affects Performance in Multithreaded Programs</a>
</li>
<li><a href="http://stackoverflow.com/questions/15251250/what-do-the-different-hotspot-jvm-thread-types-do">What do the different (HotSpot) JVM thread types do?</a>
</li>
<li><a href="http://stackoverflow.com/questions/25309748/what-is-thread-stack-size-option-xss-given-to-jvm-why-does-it-have-a-limit-of">What is thread stack size option(-Xss) given to jvm? Why does it have a limit of atleast 68k in a windows pc?</a>
</li>
<li><a href="http://j2eedebug.blogspot.jp/2008/12/mapping-java-thread-to-pstack-and-pmap.html?m=1">Mapping java thread to pstack and pmap</a>
</li>
<li><a href="http://msugai.fc2web.com/java/perform/storage.html">JVM のメモリ構造</a>
</li>
<li><a href="http://codezine.jp/article/detail/1970?p=2">pthreadについて（スタックサイズ）</a>
</li>
<li><a href="http://www.megadriver.info/~fumi/2010/11/linux-%25E3%2581%25AE-pthread-%25E3%2581%25AE%25E3%2583%2587%25E3%2583%2595%25E3%2582%25A9%25E3%2583%25AB%25E3%2583%2588%25E3%2582%25B9%25E3%2582%25BF%25E3%2583%2583%25E3%2582%25AF%25E3%2582%25B5%25E3%2582%25A4%25E3%2582%25BA%25E3%2581%25AB%25E3%2581%25A4%25E3%2581%2584%25E3%2581%25A6/">Linux の pthread のデフォルトスタックサイズについて</a>
</li>
<li><a href="http://linuxjm.sourceforge.jp/html/LDP_man-pages/man3/pthread_attr_setstacksize.3.html">PTHREAD_ATTR_SETSTACKSIZE</a>
</li>
<li><a href="http://docs.oracle.com/cd/E19455-01/806-2732/6jbu8v6ol/index.html#attrib-33670">マルチスレッドのプログラミング - スタックについて</a>
</li>
<li><a href="http://th0x4c.github.io/blog/2012/10/10/os-virtual-memory-map/">{OS} 仮想メモリ空間のメモリマップを調べる</a>
</li>
<li><a href="http://gntm-mdk.hatenadiary.com/entry/2015/01/21/231258">VSS RSS PSS USS の説明</a>
</li>
<li><a href="http://hllvm.group.iteye.com/group/topic/37717">咨询各位大神，使用jni，当栈内空间使用为1M时，会触发core</a>
</li>
</ul>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[調査]JBossASソケット受信バッファーのサイズ]]></title>
    <link href="http://luozengbin.github.io/blog/2015-04-01-%5B%E8%AA%BF%E6%9F%BB%5Djbossas%E3%82%BD%E3%82%B1%E3%83%83%E3%83%88%E5%8F%97%E4%BF%A1%E3%83%90%E3%83%83%E3%83%95%E3%82%A1%E3%83%BC%E3%81%AE%E3%82%B5%E3%82%A4%E3%82%BA.html"/>
    <updated>2015-04-01T00:00:00+09:00</updated>
    <id>http://luozengbin.github.io/blog/[調査]jbossasソケット受信バッファーのサイズ</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 実験シナリオ</a></li>
<li><a href="#sec-2">2. テスト信用のサーブレットを準備する</a></li>
<li><a href="#sec-3">3. サーバソケットの受信バッファーサイズを確認する</a></li>
<li><a href="#sec-4">4. Acceptorスレッドを意図的ストールさせる</a></li>
<li><a href="#sec-5">5. TCPソケット受信バッファサイズを監視する</a></li>
<li><a href="#sec-6">6. パケット通信を監視する</a></li>
<li><a href="#sec-7">7. telnetからデータを順次に送りつける</a></li>
<li><a href="#sec-8">8. 監視結果解析</a></li>
<li><a href="#sec-9">9. TCPソケット受信バッファーサイズの設定について</a></li>
<li><a href="#sec-10">10. まとめ</a></li>
<li><a href="#sec-11">11. 参考</a></li>
</ul>
</div>
</div>


<p>
以下LinuxプラットフォームでJBossASアプリケーションサーバの話です。
</p>




<p>
次のケースに置いて、Acceptorスレッドやワーカスレッドの働き状態が悪くなるため、クライ
アントから送信されてデータがサーバ側のTCPソケット受信バッファーに溜まる。バッファーが
一杯になるとパケット受信ができなくなる、TCPレーヤでパケット再送が起きる。
</p>




<ul class="org-ul">
<li>サーバが過負荷状態でCPU時間がAcceptorスレッドやワーカスレッドに回らない場合
</li>
<li>FullGCによるJBossASサーバの一時停止
</li>
</ul>




<p>
この記事はTCP受信バッファーのサイズの実測値を調査致します。
</p>




<p>
<!-- more -->
</p>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 実験シナリオ</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>テスト信用のサーブレットを準備する
</li>
<li>サーバソケットの受信バッファーサイズを確認する
</li>
<li>Acceptorスレッドを意図的ストールさせる
</li>
<li>TCPソケット受信バッファサイズを監視する
</li>
<li>パケット通信を監視する
</li>
<li>telnetからデータを順次に送りつける
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> テスト信用のサーブレットを準備する</h2>
<div class="outline-text-2" id="text-2">
<p>
受信したHTTPリクエストパラメータを出力するシンプルなサーブレットをJBossASにデプロイす
る。
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #b4fa70;">package</span> jp.co.jizai.sample.jbossas7.<span style="color: #e6a8df;">tcp</span>;

<span style="color: #b4fa70;">import</span> <span style="color: #e6a8df;">javax</span>.<span style="color: #e6a8df;">servlet</span>.<span style="color: #8cc4ff;">ServletException</span>;
<span style="color: #b4fa70;">import</span> <span style="color: #e6a8df;">javax</span>.<span style="color: #e6a8df;">servlet</span>.<span style="color: #e6a8df;">http</span>.<span style="color: #8cc4ff;">HttpServlet</span>;
<span style="color: #b4fa70;">import</span> <span style="color: #e6a8df;">javax</span>.<span style="color: #e6a8df;">servlet</span>.<span style="color: #e6a8df;">http</span>.<span style="color: #8cc4ff;">HttpServletRequest</span>;
<span style="color: #b4fa70;">import</span> <span style="color: #e6a8df;">javax</span>.<span style="color: #e6a8df;">servlet</span>.<span style="color: #e6a8df;">http</span>.<span style="color: #8cc4ff;">HttpServletResponse</span>;
<span style="color: #b4fa70;">import</span> <span style="color: #e6a8df;">java</span>.<span style="color: #e6a8df;">io</span>.<span style="color: #8cc4ff;">IOException</span>;
<span style="color: #b4fa70;">import</span> <span style="color: #e6a8df;">java</span>.<span style="color: #e6a8df;">io</span>.<span style="color: #8cc4ff;">PrintWriter</span>;
<span style="color: #b4fa70;">import</span> <span style="color: #e6a8df;">java</span>.<span style="color: #e6a8df;">util</span>.<span style="color: #8cc4ff;">Enumeration</span>;
<span style="color: #b4fa70;">import</span> <span style="color: #e6a8df;">java</span>.<span style="color: #e6a8df;">util</span>.<span style="color: #8cc4ff;">Map</span>;

<span style="color: #b4fa70;">public</span> <span style="color: #b4fa70;">class</span> <span style="color: #8cc4ff;">ShowParameterServlet</span> <span style="color: #b4fa70;">extends</span> <span style="color: #8cc4ff;">HttpServlet</span> {

    <span style="color: #b4fa70;">private</span> <span style="color: #b4fa70;">static</span> <span style="color: #b4fa70;">final</span> <span style="color: #8cc4ff;">String</span> <span style="color: #fcaf3e;">CONTENT_TYPE</span> = <span style="color: #e9b96e;">"text/html; charset=UTF-8"</span>;

    <span style="color: #b4fa70;">public</span> <span style="color: #8cc4ff;">void</span> <span style="color: #fce94f;">doGet</span>(<span style="color: #8cc4ff;">HttpServletRequest</span> <span style="color: #fcaf3e;">req</span>, <span style="color: #8cc4ff;">HttpServletResponse</span> <span style="color: #fcaf3e;">resp</span>) <span style="color: #b4fa70;">throws</span> <span style="color: #8cc4ff;">ServletException</span>, <span style="color: #8cc4ff;">IOException</span> {

        process(req, resp);
    }


    <span style="color: #b4fa70;">public</span> <span style="color: #8cc4ff;">void</span> <span style="color: #fce94f;">doPost</span>(<span style="color: #8cc4ff;">HttpServletRequest</span> <span style="color: #fcaf3e;">req</span>, <span style="color: #8cc4ff;">HttpServletResponse</span> <span style="color: #fcaf3e;">resp</span>) <span style="color: #b4fa70;">throws</span> <span style="color: #8cc4ff;">ServletException</span>, <span style="color: #8cc4ff;">IOException</span> {
        process(req, resp);
    }

    <span style="color: #b4fa70;">public</span> <span style="color: #8cc4ff;">void</span> <span style="color: #fce94f;">process</span>(<span style="color: #8cc4ff;">HttpServletRequest</span> <span style="color: #fcaf3e;">req</span>, <span style="color: #8cc4ff;">HttpServletResponse</span> <span style="color: #fcaf3e;">resp</span>) <span style="color: #b4fa70;">throws</span> <span style="color: #8cc4ff;">ServletException</span>, <span style="color: #8cc4ff;">IOException</span> {
        resp.setContentType(CONTENT_TYPE);
        <span style="color: #8cc4ff;">PrintWriter</span> <span style="color: #fcaf3e;">out</span> = resp.getWriter();
        System.out.println(<span style="color: #e9b96e;">"=== http parameter ==="</span>);
        <span style="color: #8cc4ff;">Map</span>&lt;<span style="color: #8cc4ff;">String</span>, <span style="color: #8cc4ff;">Object</span>&gt; <span style="color: #fcaf3e;">paramMap</span> = (Map&lt;<span style="color: #8cc4ff;">String</span>, Object&gt;) req.getParameterMap();
        <span style="color: #b4fa70;">for</span> (<span style="color: #e6a8df;">Map</span>.<span style="color: #8cc4ff;">Entry</span>&lt;<span style="color: #8cc4ff;">String</span>, <span style="color: #8cc4ff;">Object</span>&gt; entry : paramMap.entrySet()) {
            out.write(String.format(<span style="color: #e9b96e;">"%s = %s"</span>, entry.getKey(), entry.getValue()) + <span style="color: #e9b96e;">"&lt;br/&gt;"</span>);
        }

        System.out.println(<span style="color: #e9b96e;">"=== http attribute ==="</span>);
        <span style="color: #8cc4ff;">Enumeration</span>&lt;<span style="color: #8cc4ff;">String</span>&gt; <span style="color: #fcaf3e;">attrNames</span> = (<span style="color: #8cc4ff;">Enumeration</span>&lt;<span style="color: #8cc4ff;">String</span>&gt;) req.getAttributeNames();
        <span style="color: #b4fa70;">while</span> (attrNames.hasMoreElements()) {
            <span style="color: #8cc4ff;">String</span> <span style="color: #fcaf3e;">attrName</span> = attrNames.nextElement();
            out.write(String.format(<span style="color: #e9b96e;">"%s = %s"</span>, attrName, req.getAttribute(attrName)) + <span style="color: #e9b96e;">"&lt;br/&gt;"</span>);
        }
        out.close();
    }
}
</pre>
</div>
</div>
</div>




<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> サーバソケットの受信バッファーサイズを確認する</h2>
<div class="outline-text-2" id="text-3">
<p>
新規接続のサーバソケットのgetReceiveBufferSize()メソッドをコールする <code>Byteman</code> スクリ
プトを実行中のJBassASにアタッチメントする。
</p>
<div class="org-src-container">

<pre class="src src-sh">RULE trace http ReceiveBufferSize
CLASS org.apache.tomcat.util.net.JIoEndpoint
METHOD processSocket
AT ENTRY
BIND socket = $<span style="color: #fcaf3e;">1</span>
IF TRUE
DO
  traceln(<span style="color: #e9b96e;">"socket.getReceiveBufferSize() = "</span> + socket.getReceiveBufferSize()), traceStack()
ENDRULE
</pre>
</div>

<p>
クライアントブラウザからテスト用サーブレットをアクセスすると、サーバログに以下の内容
が出力される。
</p>

<pre class="example">
15:46:11,002 INFO  [stdout] (http-/0.0.0.0:8080-Acceptor-0) socket.getReceiveBufferSize() = 43690
15:46:11,004 INFO  [stdout] (http-/0.0.0.0:8080-Acceptor-0) Stack trace for thread http-/0.0.0.0:8080-Acceptor-0
15:46:11,004 INFO  [stdout] (http-/0.0.0.0:8080-Acceptor-0) org.apache.tomcat.util.net.JIoEndpoint.processSocket(JIoEndpoint.java:-1)
15:46:11,004 INFO  [stdout] (http-/0.0.0.0:8080-Acceptor-0) org.apache.tomcat.util.net.JIoEndpoint$Acceptor.run(JIoEndpoint.java:315)
15:46:11,005 INFO  [stdout] (http-/0.0.0.0:8080-Acceptor-0) java.lang.Thread.run(Thread.java:745)
</pre>

<p>
<code>[[https://docs.oracle.com/javase/jp/6/api/java/net/Socket.html#setReceiveBufferSize%2528int%2529][java.net.Socket.getReceiveBufferSize]]()</code> で取れた値→ <code>43690</code> 単位がよくわからないの
でJavaDocを引いてみた。
</p>

<pre class="example">
public int getReceiveBufferSize()
                         throws SocketException

    この Socket で使われる SO_RCVBUF オプションの値を取得します。これは、この Socket で入力用としてプラットフォームが使うバッファーのサイズです。

    戻り値:
        この Socket の SO_RCVBUF オプションの値 
    例外:
        SocketException - 使用しているプロトコルでエラー (TCP エラーなど) が発生した場合
    導入されたバージョン:
        1.2
    関連項目:
        setReceiveBufferSize(int)
</pre>

<p>
やはり、分からないので <code>SO_RCVBUF</code> オプションの単位を探って見る。
</p>

<pre class="example">
SO_RCVBUF
    ソケットの受信バッファーの最大サイズを設定・取得する (バイト単位)。 setsockopt(2)
    を使って値が設定されたときに (管理オーバヘッド用の領域を確保するために) カーネルは
    この値を 2倍し、 getsockopt(2) はこの 2倍された値を返す。 デフォルトの値は
    /proc/sys/net/core/rmem_default ファイルで設定され、許容される最大の値は
    /proc/sys/net/core/rmem_max ファイルで設定される。 このオプションの最小値は (2倍し
    た値で) 256 である
</pre>

<p>
僕の日本語理解力が低いので、正確な意味が掴めないままだが。一先ず受信バッファーサイズの
単位がバイトだそうです。 <code>43690</code> バイトは約42KB、またTCP受信バッファーカーネルパラメー
タ <code>net.ipv4.tcp_rmem</code> の値は下記の通りとなります。 <code>43690</code> は丁度 <code>net.ipv4.tcp_rmem</code>
のデフォルト値の 1/2 であることが分かりました。
</p>

<pre class="example">
# sysctl -a | grep net.ipv4.tcp_rmem
net.ipv4.tcp_rmem = 4096    87380   4194304
</pre>
</div>
</div>




<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Acceptorスレッドを意図的ストールさせる</h2>
<div class="outline-text-2" id="text-4">
<p>
新規接続を受け付ける処理 <code>org.apache.tomcat.util.net.JIoEndpoint.processSocket(Socket
socket)</code> でスレッドを30秒間Sleepされる <code>Byteman</code> スクリプトを実行中のJBossASにアタッチ
メントする。
</p>
<div class="org-src-container">

<pre class="src src-sh">RULE pause acceptor thread
CLASS org.apache.tomcat.util.net.JIoEndpoint
METHOD processSocket
AT ENTRY
BIND socket = $<span style="color: #fcaf3e;">1</span>
IF TRUE
DO
  Thread.sleep(300000)
ENDRULE
</pre>
</div>
</div>
</div>




<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> TCPソケット受信バッファサイズを監視する</h2>
<div class="outline-text-2" id="text-5">
<p>
以下のコマンドでTCPソケット受信バッファサイズを監視する
</p>
<pre class="example">
$ watch -n 2 'netstat -an | grep ESTABLISHED | grep 8080'
</pre>
</div>
</div>




<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> パケット通信を監視する</h2>
<div class="outline-text-2" id="text-6">
<p>
クライアント側にて以下のコマンドでパケット通信の監視を行う
</p>
<pre class="example">
$sudo tcpdump -n -i virbr0 port 8080
</pre>
</div>
</div>




<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> telnetからデータを順次に送りつける</h2>
<div class="outline-text-2" id="text-7">
<p>
<code>net.ipv4.tcp_rmem</code> パラメータデフォルト値 <code>87380</code> より大きい電文を送るようにHTTPヘッ
ダーに <code>Content-Length: 120100</code> を指定する。
</p>

<pre class="example">
$ telnet jbossas-lab02 8080
POST /jbossas7-tcp-basic/ShowParameterServlet HTTP/1.1
Host: jbossas-lab02:8080
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:36.0) Gecko/20100101 Firefox/36.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: ja,en-US;q=0.7,en;q=0.3
Accept-Encoding: gzip, deflate
Referer: http://jbossas-lab002:8080/jbossas7-tcp-basic/
Connection: Close
Content-Type: application/x-www-form-urlencoded
Content-Length: 120100

★まず100バイト分を送る(エンターは2バイト分になります)
param1=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ★エンターを押す

★以下4000バイト文字を30回繰り返しサーバに送る
bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
</pre>
</div>
</div>




<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 監視結果解析</h2>
<div class="outline-text-2" id="text-8">
<p>
以下TCPソケット受信バッファサイズの監視結果、文中の★マークは結果の解析コメントとなり
ます。
</p>
<pre class="example">
# while [ true ]; do netstat -an | grep ESTABLISHED | grep 8080; sleep  2; done
★1 TCP3WHS 接続確立
tcp        0      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 

★2 HTTPヘッダー受信
tcp      447      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 

★3 リクエストデータの受信
tcp      547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp     4547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp     8547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    12547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    16547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    20547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    24547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    28547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    32547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    36547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    40547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 

★4 アプリ予約バッファサイズに達した、以降は管理領域を食い始めた
★  このタイミングからサーバ受信ウィンドウサイズが徐々に縮める
tcp    44547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    48547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    52547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    56547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    60547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    64547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    68547      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    72211      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 

★5 以降TCPバッファが満タン
tcp    72211      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    72211      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    72211      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    72211      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    72211      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    72211      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    72211      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED 
tcp    72211      0 192.168.122.66:8080         192.168.122.1:40976         ESTABLISHED
</pre>


<p>
パケット監視結果は以下の通りです。
</p>
<pre class="example">
★1 TCP3WHS 接続確立
16:45:01.262499 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [S], seq 3028524293, win 29200, options [mss 1460,sackOK,TS val 50120659 ecr 0,nop,wscale 7], length 0
16:45:01.262697 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [S.], seq 1682372075, ack 3028524294, win 14480, options [mss 1460,sackOK,TS val 3798305 ecr 50120659,nop,wscale 7], length 0
16:45:01.262773 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], ack 1, win 229, options [nop,nop,TS val 50120659 ecr 3798305], length 0


★2 HTTPヘッダー送信
16:45:09.935452 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 1:57, ack 1, win 229, options [nop,nop,TS val 50123261 ecr 3798305], length 56: HTTP: POST /jbossas7-tcp-basic/ShowParameterServlet HTTP/1.1
16:45:09.935789 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 57, win 114, options [nop,nop,TS val 3806979 ecr 50123261], length 0
16:45:09.935850 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 57:422, ack 1, win 229, options [nop,nop,TS val 50123261 ecr 3806979], length 365: HTTP
16:45:09.935905 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 422, win 122, options [nop,nop,TS val 3806979 ecr 50123261], length 0
16:45:10.330264 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 422:446, ack 1, win 229, options [nop,nop,TS val 50123379 ecr 3806979], length 24: HTTP
16:45:10.330448 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 446, win 122, options [nop,nop,TS val 3807373 ecr 50123379], length 0
16:45:10.897750 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 446:448, ack 1, win 229, options [nop,nop,TS val 50123550 ecr 3807373], length 2: HTTP
16:45:10.897911 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 448, win 122, options [nop,nop,TS val 3807941 ecr 50123550], length 0

★3 リクエストデータの送信
16:45:19.464509 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 448:548, ack 1, win 229, options [nop,nop,TS val 50126120 ecr 3807941], length 100: HTTP
16:45:19.464668 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 548, win 122, options [nop,nop,TS val 3816507 ecr 50126120], length 0
16:45:26.602423 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 548:4548, ack 1, win 229, options [nop,nop,TS val 50128261 ecr 3816507], length 4000: HTTP
16:45:26.602602 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 4548, win 145, options [nop,nop,TS val 3823645 ecr 50128261], length 0
16:45:32.436162 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 4548:8548, ack 1, win 229, options [nop,nop,TS val 50130011 ecr 3823645], length 4000: HTTP
16:45:32.436338 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 8548, win 167, options [nop,nop,TS val 3829479 ecr 50130011], length 0
16:45:35.452590 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 8548:12548, ack 1, win 229, options [nop,nop,TS val 50130916 ecr 3829479], length 4000: HTTP
16:45:35.452721 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 12548, win 190, options [nop,nop,TS val 3832495 ecr 50130916], length 0
16:45:38.082228 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 12548:16548, ack 1, win 229, options [nop,nop,TS val 50131705 ecr 3832495], length 4000: HTTP
16:45:38.082396 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 16548, win 212, options [nop,nop,TS val 3835125 ecr 50131705], length 0
16:45:40.743705 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 16548:20548, ack 1, win 229, options [nop,nop,TS val 50132504 ecr 3835125], length 4000: HTTP
16:45:40.743848 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 20548, win 235, options [nop,nop,TS val 3837787 ecr 50132504], length 0
16:45:43.016683 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 20548:24548, ack 1, win 229, options [nop,nop,TS val 50133185 ecr 3837787], length 4000: HTTP
16:45:43.016863 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 24548, win 258, options [nop,nop,TS val 3840060 ecr 50133185], length 0
16:45:45.721066 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 24548:28548, ack 1, win 229, options [nop,nop,TS val 50133997 ecr 3840060], length 4000: HTTP
16:45:45.721253 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 28548, win 280, options [nop,nop,TS val 3842764 ecr 50133997], length 0
16:45:49.227814 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 28548:32548, ack 1, win 229, options [nop,nop,TS val 50135049 ecr 3842764], length 4000: HTTP
16:45:49.227964 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 32548, win 253, options [nop,nop,TS val 3846271 ecr 50135049], length 0
16:45:51.671841 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 32548:36548, ack 1, win 229, options [nop,nop,TS val 50135782 ecr 3846271], length 4000: HTTP

★4 ここから再送が発生する
16:45:51.680266 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 35444:36548, ack 1, win 229, options [nop,nop,TS val 50135785 ecr 3846271], length 1104: HTTP
16:45:51.711839 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 36548, win 225, options [nop,nop,TS val 3848755 ecr 50135782,nop,nop,sack 1 {35444:36548}], length 0
16:45:55.390996 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 36548:40548, ack 1, win 229, options [nop,nop,TS val 50136898 ecr 3848755], length 4000: HTTP
16:45:55.430802 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 40548, win 197, options [nop,nop,TS val 3852474 ecr 50136898], length 0
16:45:59.291140 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], seq 40548:43444, ack 1, win 229, options [nop,nop,TS val 50138068 ecr 3852474], length 2896: HTTP
16:45:59.291169 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 43444:44548, ack 1, win 229, options [nop,nop,TS val 50138068 ecr 3852474], length 1104: HTTP
16:45:59.310296 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 43444:44548, ack 1, win 229, options [nop,nop,TS val 50138074 ecr 3852474], length 1104: HTTP
16:45:59.330773 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 44548, win 166, options [nop,nop,TS val 3856374 ecr 50138068,nop,nop,sack 1 {43444:44548}], length 0
16:46:01.367501 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], seq 44548:47444, ack 1, win 229, options [nop,nop,TS val 50138691 ecr 3856374], length 2896: HTTP
16:46:01.367533 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 47444:48548, ack 1, win 229, options [nop,nop,TS val 50138691 ecr 3856374], length 1104: HTTP
16:46:01.406803 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 48548, win 135, options [nop,nop,TS val 3858450 ecr 50138691], length 0
16:46:03.523326 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], seq 48548:51444, ack 1, win 229, options [nop,nop,TS val 50139337 ecr 3858450], length 2896: HTTP
16:46:03.523356 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 51444:52548, ack 1, win 229, options [nop,nop,TS val 50139337 ecr 3858450], length 1104: HTTP
16:46:03.553582 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 51444:52548, ack 1, win 229, options [nop,nop,TS val 50139347 ecr 3858450], length 1104: HTTP
16:46:03.553716 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 52548, win 104, options [nop,nop,TS val 3860596 ecr 50139337,nop,nop,sack 1 {51444:52548}], length 0
16:46:06.322183 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], seq 52548:55444, ack 1, win 229, options [nop,nop,TS val 50140177 ecr 3860596], length 2896: HTTP
16:46:06.322212 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 55444:56548, ack 1, win 229, options [nop,nop,TS val 50140177 ecr 3860596], length 1104: HTTP
16:46:06.361777 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 56548, win 73, options [nop,nop,TS val 3863405 ecr 50140177], length 0
16:46:08.944983 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], seq 56548:57996, ack 1, win 229, options [nop,nop,TS val 50140964 ecr 3863405], length 1448: HTTP
16:46:08.945017 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], seq 57996:59444, ack 1, win 229, options [nop,nop,TS val 50140964 ecr 3863405], length 1448: HTTP
16:46:08.945027 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 59444:60548, ack 1, win 229, options [nop,nop,TS val 50140964 ecr 3863405], length 1104: HTTP
16:46:08.945188 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 57996, win 62, options [nop,nop,TS val 3865988 ecr 50140964], length 0
16:46:08.983605 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 59444:60548, ack 1, win 229, options [nop,nop,TS val 50140976 ecr 3865988], length 1104: HTTP
16:46:08.983765 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 60548, win 43, options [nop,nop,TS val 3866027 ecr 50140964,nop,nop,sack 1 {59444:60548}], length 0
16:46:10.874178 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], seq 60548:63444, ack 1, win 229, options [nop,nop,TS val 50141543 ecr 3866027], length 2896: HTTP
16:46:10.874209 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 63444:64548, ack 1, win 229, options [nop,nop,TS val 50141543 ecr 3866027], length 1104: HTTP
16:46:10.913789 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 64548, win 12, options [nop,nop,TS val 3867957 ecr 50141543], length 0
16:46:13.263314 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], seq 64548:65996, ack 1, win 229, options [nop,nop,TS val 50142259 ecr 3867957], length 1448: HTTP
16:46:13.263477 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 65996, win 1, options [nop,nop,TS val 3870306 ecr 50142259], length 0
16:46:13.483589 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 65996:66124, ack 1, win 229, options [nop,nop,TS val 50142326 ecr 3870306], length 128: HTTP
16:46:13.483812 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 66124, win 46, options [nop,nop,TS val 3870527 ecr 50142326], length 0
16:46:13.483865 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], seq 66124:67572, ack 1, win 229, options [nop,nop,TS val 50142326 ecr 3870527], length 1448: HTTP
16:46:13.483885 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 67572:68548, ack 1, win 229, options [nop,nop,TS val 50142326 ecr 3870527], length 976: HTTP
16:46:13.523583 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 67572:68548, ack 1, win 229, options [nop,nop,TS val 50142338 ecr 3870527], length 976: HTTP
16:46:13.523752 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 68548, win 28, options [nop,nop,TS val 3870567 ecr 50142326,nop,nop,sack 1 {67572:68548}], length 0
16:46:15.144825 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], seq 68548:69996, ack 1, win 229, options [nop,nop,TS val 50142824 ecr 3870567], length 1448: HTTP
16:46:15.144860 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], seq 69996:71444, ack 1, win 229, options [nop,nop,TS val 50142824 ecr 3870567], length 1448: HTTP
16:46:15.145025 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 69996, win 17, options [nop,nop,TS val 3872188 ecr 50142824], length 0
16:46:15.184796 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 71444, win 6, options [nop,nop,TS val 3872228 ecr 50142824], length 0
16:46:15.406939 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [P.], seq 71444:72212, ack 1, win 229, options [nop,nop,TS val 50142903 ecr 3872228], length 768: HTTP


★5 ここからサーバから受信可能なTCPウィンドウサイズが0の応答パケットが出始めた
16:46:15.407110 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 72212, win 0, options [nop,nop,TS val 3872450 ecr 50142903], length 0
16:46:15.626933 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], ack 1, win 229, options [nop,nop,TS val 50142969 ecr 3872450], length 0
16:46:15.627096 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 72212, win 0, options [nop,nop,TS val 3872670 ecr 50142903], length 0
16:46:16.066943 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], ack 1, win 229, options [nop,nop,TS val 50143101 ecr 3872670], length 0
16:46:16.067143 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 72212, win 0, options [nop,nop,TS val 3873110 ecr 50142903], length 0
16:46:16.950253 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], ack 1, win 229, options [nop,nop,TS val 50143366 ecr 3873110], length 0
16:46:16.950401 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 72212, win 0, options [nop,nop,TS val 3873993 ecr 50142903], length 0
16:46:18.716950 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], ack 1, win 229, options [nop,nop,TS val 50143896 ecr 3873993], length 0
16:46:18.717129 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 72212, win 0, options [nop,nop,TS val 3875760 ecr 50142903], length 0
16:46:22.250259 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], ack 1, win 229, options [nop,nop,TS val 50144956 ecr 3875760], length 0
16:46:22.250438 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 72212, win 0, options [nop,nop,TS val 3879293 ecr 50142903], length 0
16:46:29.303610 IP 192.168.122.1.40976 &gt; 192.168.122.66.8080: Flags [.], ack 1, win 229, options [nop,nop,TS val 50147072 ecr 3879293], length 0
16:46:29.303785 IP 192.168.122.66.8080 &gt; 192.168.122.1.40976: Flags [.], ack 72212, win 0, options [nop,nop,TS val 3886347 ecr 50142903], length 0
</pre>
</div>
</div>




<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> TCPソケット受信バッファーサイズの設定について</h2>
<div class="outline-text-2" id="text-9">
<p>
JavaDocから引用
</p>

<ul class="org-ul">
<li><a href="https://docs.oracle.com/javase/jp/6/api/java/net/Socket.html#setReceiveBufferSize%2528int%2529">java.net.Socket.setReceiveBufferSize</a>
この Socket の SO_RCVBUF オプションを指定された値に設定します。SO_RCVBUF オプション
は、使用するネットワーク入出力バッファーに設定するサイズのヒントとして、プラットフォー
ムのネットワークコードが使います。

<p>
受信バッファーのサイズを増やすと、大規模な接続でのネットワーク入出力のパフォーマンス
を上げることができます。一方、サイズを減らすと、受信データのバックログを減らすことが
できます。
</p>

<p>
SO_RCVBUF は <code>ヒント</code> なので、アプリケーションでバッファーのサイズ設定を調べる必要が
ある場合は、getReceiveBufferSize() を呼び出してください。
</p>

<p>
SO_RCVBUF の値は、リモートピアに通知される TCP 受信ウィンドウの設定にも使用されます。
一般に、ソケットが接続されているかぎり、このウィンドウサイズはいつでも変更できます。
ただし、64K を超える受信ウィンドウを要求する場合は、ソケットをリモートピアに接続する
前に変更を要求する必要があります。次の 2 つの場合に注意してください。
</p>

<p>
ServerSocket から受け入れたソケットの場合、ServerSocket をローカルアドレスにバインド
する前に、ServerSocket.setReceiveBufferSize(int) を呼び出してこれを実行する必要があ
ります。
</p>

<p>
クライアントソケットの場合、ソケットをそのリモートピアに接続する前に、
setReceiveBufferSize() を呼び出す必要があります。
</p>
</li>
<li><a href="https://docs.oracle.com/javase/jp/6/api/java/net/ServerSocket.html#setReceiveBufferSize%2528int%2529">java.net.ServerSocket.setReceiveBufferSize</a>
  この ServerSocket から受け入れられたソケットの SO_RCVBUF オプションのデフォルト推
奨値を設定します。受け入れられたソケット内に実際に設定されている値を確認してください。
それには、accept() からソケットが返されたあとで Socket.getReceiveBufferSize() を呼び
出します。

<p>
  SO_RCVBUF の値は、内部ソケット受信バッファーのサイズの設定と、リモートピアに通知さ
れる TCP 受信ウィンドウのサイズの設定の両方に使用されます。
</p>

<p>
  その後、Socket.setReceiveBufferSize(int) を呼び出すことで値を変更できます。ただし、
アプリケーションが RFC1323 で定義されている 64K バイトを超える受信ウィンドウを使用可
能にする必要がある場合には、ローカルアドレスにバインドする前に 推奨値を
ServerSocket で設定する必要があります。つまり、引数なしコンストラクタを使って
ServerSocket を作成し、次に setReceiveBufferSize() を呼び出し、最後に bind() を呼び
出して ServerSocket をアドレスにバインドする必要があることを意味します。
</p>

<p>
  これに失敗してもエラーは発生せず、バッファーサイズは要求された値に設定されます。た
だし、この ServerSocket から受け取るソケットの TCP 受信ウィンドウは 64K バイト以下に
なります。
</p>
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> まとめ</h2>
<div class="outline-text-2" id="text-10">
<ul class="org-ul">
<li>JBossASソケット受信バッファーのデフォルトサイズは <code>net.ipv4.tcp_rmem</code> の1/2が適用さ
れる(約42KB)。
</li>
<li>リクエストデータサイズが42KBバイト以下の場合、パケット再送発生しない
</li>
<li>実際に受信できる最大サイズは <code>net.ipv4.tcp_rmem</code> 値の8割ぐらい
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> 参考</h2>
<div class="outline-text-2" id="text-11">
<ul class="org-ul">
<li><a href="http://linuxjm.sourceforge.jp/html/LDP_man-pages/man7/socket.7.html">Section: Linux Programmer&#8217;s Manual (7)</a>
</li>
<li><a href="https://docs.oracle.com/javase/jp/6/api/java/net/Socket.html">Socket (Java Platform SE 6)</a>
</li>
</ul>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[メモ]JBoss ASでBytemanを使う]]></title>
    <link href="http://luozengbin.github.io/blog/2015-04-01-%5B%E3%83%A1%E3%83%A2%5Djbossas%E3%81%A7byteman%E3%82%92%E4%BD%BF%E3%81%86.html"/>
    <updated>2015-04-01T00:00:00+09:00</updated>
    <id>http://luozengbin.github.io/blog/[メモ]jbossasでbytemanを使う</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 前提</a></li>
<li><a href="#sec-2">2. インストール</a></li>
<li><a href="#sec-3">3. JBossASプロセスへのアタッチ</a></li>
<li><a href="#sec-4">4. トレース用スクリプトの作成</a></li>
<li><a href="#sec-5">5. スクリプトの実行</a></li>
<li><a href="#sec-6">6. 参考</a></li>
</ul>
</div>
</div>


<p>
ミドルウェアの内部動作をトレースするためによく使うので手順を残しておきます。
</p>




<p>
<!-- more -->
</p>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 前提</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>JBossAS 7系
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> インストール</h2>
<div class="outline-text-2" id="text-2">
<pre class="example">
$ wget http://downloads.jboss.org/byteman/2.2.1/byteman-download-2.2.1-bin.zip
$ unzip byteman-download-2.2.1-bin.zip
</pre>
</div>
</div>




<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> JBossASプロセスへのアタッチ</h2>
<div class="outline-text-2" id="text-3">
<pre class="example">
$ export BYTEMAN_HOME=`pwd`/byteman-download-2.2.1
$ export JAVA_HOME=/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.65.x86_64
$ JBOSS_PID=`ps -ef | grep [j]boss-modules.jar | awk '{print $2}'`
$ ${BYTEMAN_HOME}/bin/bminstall.sh -b ${JBOSS_PID}
</pre>
</div>
</div>




<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> トレース用スクリプトの作成</h2>
<div class="outline-text-2" id="text-4">
<p>
JBossASサーバソケット受信バッファーサイズを調べるスクリプト
<code>trace_socket_receive_buffer_size.btm</code> を作成する
</p>

<pre class="example">
RULE trace http ReceiveBufferSize
CLASS org.apache.tomcat.util.net.JIoEndpoint
METHOD processSocket
AT ENTRY
BIND socket = $1
IF TRUE
DO
  traceln("socket.getReceiveBufferSize() = " + socket.getReceiveBufferSize()), traceStack()
ENDRULE
</pre>
</div>
</div>




<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> スクリプトの実行</h2>
<div class="outline-text-2" id="text-5">
<pre class="example">
$ ${BYTEMAN_HOME}/bin/bmsubmit.sh trace_socket_receive_buffer_size.btm
</pre>
</div>
</div>




<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 参考</h2>
<div class="outline-text-2" id="text-6">
<ul class="org-ul">
<li><a href="https://developer.jboss.org/wiki/ABytemanTutorial#how_do_i_run_jboss_as_with_byteman">A Byteman Tutorial</a>
</li>
<li><a href="http://nekop.hatenablog.com/entry/20101220/1292825812">BytemanによるJava黒魔術</a>
</li>
<li><a href="http://d.hatena.ne.jp/Kazuhira/20131022/1382455739">バイトコード操作ツール、Bytemanを試す</a>
</li>
</ul>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[まとめ]JBoss as 7過負荷時TCPコネクションの振る舞い]]></title>
    <link href="http://luozengbin.github.io/blog/2015-04-01-%5B%E3%81%BE%E3%81%A8%E3%82%81%5Deap6%E9%81%8E%E8%B2%A0%E8%8D%B7%E6%99%82tcp%E3%82%B3%E3%83%8D%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E6%8C%AF%E3%82%8B%E8%88%9E%E3%81%84.html"/>
    <updated>2015-04-01T00:00:00+09:00</updated>
    <id>http://luozengbin.github.io/blog/[まとめ]eap6過負荷時tcpコネクションの振る舞い</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 前提事項</a></li>
<li><a href="#sec-2">2. 最大ワーカスレッド数の設定方法</a></li>
<li><a href="#sec-3">3. スレッド起動のタイミング</a></li>
<li><a href="#sec-4">4. 過負荷時の挙動</a>
<ul>
<li><a href="#sec-4-1">4.1. A.クライアントからPSHパケット再送が発生するパターン</a></li>
<li><a href="#sec-4-2">4.2. B.TCP3WHSパケット再送が発生するパターン</a></li>
<li><a href="#sec-4-3">4.3. C.新規接続が拒否されるパターン</a></li>
</ul>
</li>
<li><a href="#sec-5">5. 過負荷の対策</a></li>
<li><a href="#sec-6">6. 参考</a></li>
</ul>
</div>
</div>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 前提事項</h2>
<div class="outline-text-2" id="text-1">
<p>
本記事は以下の環境を前提とする。
</p>

<ul class="org-ul">
<li>Linux/x86_64
</li>
<li>JBoss AS 7
</li>
</ul>

<p>
<!-- more -->
</p>
</div>
</div>




<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 最大ワーカスレッド数の設定方法</h2>
<div class="outline-text-2" id="text-2">
<ul class="org-ul">
<li>方式1: -Dorg.apache.tomcat.util.net.MAX_THREADS=999
</li>
<li>方式2: コネクタ定義のmax-connectionsで指定する
</li>
</ul>

<p>
両方指定した場合、方式2が優先される。指定しない場合 512 x JVMに割り当てたコア数
</p>
</div>
</div>




<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> スレッド起動のタイミング</h2>
<div class="outline-text-2" id="text-3">
<p>
サーバ起動時にワーカースレッドの初期値が0、リクエストが来るたびに新規スレッドを作る。
スレッドの数がmax-connectionsの数に達した時にログに以下のメッセージがを出力される。
</p>

<pre class="example">
INFO [JIoEndpoint] Maximum number of threads (xxx) created for connector with address /127.0.0.1 and port 8080
</pre>
</div>
</div>




<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 過負荷時の挙動</h2>
<div class="outline-text-2" id="text-4">
<p>
下記AとBの何れが起きた場合、クライアントからすると無応答や応答が激遅いことが感じるので
防止の対策を講じることをおすすめします。
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> A.クライアントからPSHパケット再送が発生するパターン</h3>
<div class="outline-text-3" id="text-4-1">
<p>
以下の状況に置いて、クライアントからのリクエスデータがサーバ側のTCPバッファーに詰ま
る。TCPバッファーが一杯になると、パケットがdropされるのでクライアントからのデータ再
送が発生する。
</p>

<ul class="org-ul">
<li>CPU高負荷時、Acceptorスレッドが回らない状況
</li>
<li>GCによって、Acceptorスレッドの働きが良くない状況
</li>
<li>CPU高負荷時、ワーカスレッドがリクエストデータ受信処理で止まっている
</li>
<li>GCによって、ワーカスレッドがリクエストデータ受信処理で止まっている
</li>
</ul>

<p>
また、Acceptorスレッドが止まる場合新規接続(3WHS完了)がbacklogキューに溜まるので
backlogキューが溢れる可能性もあります。
</p>

<p>
※上記に関して、Threadサブシステム利用時も同様です。
</p>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> B.TCP3WHSパケット再送が発生するパターン</h3>
<div class="outline-text-3" id="text-4-2">
<p>
CPU高負荷でAcceptorスレッドが止まってかつbacklogキューが溢れた場合、コネクションの確立
ができない、クライアントからのsyn(1)やack(3)の再送が起きる。
TCP SYNの再送間隔は以下の通り、約64秒でタイムアウトになる。
</p>
<pre class="example">
1回目 +1秒
2回目 +2秒
3回目 +4秒
4回目 +8秒
5回目 +16秒
6回目 +32秒  タイムアウト
</pre>
<p>
クライアントからすると応答が激遅いと感じることがある。
</p>

<p>
※上記に関して、Threadサブシステム利用時も同様です。
</p>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> C.新規接続が拒否されるパターン</h3>
<div class="outline-text-3" id="text-4-3">
<p>
同時接続数がmax-connections値を超えた場合、Acceptorスレッドが新規コネクションを受付し、
その後のワーカースレッド割り当て処理でワーカースレッドがないことを気付き、ソケットをク
ローズする(FINパケットを送出)。
</p>

<p>
注意：
このケースに置いて必ずじもCPU高負荷とは限らない、ワーカスレッドがアプリに掴み放しの場
合も起こりえる。
</p>
</div>
</div>
</div>




<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 過負荷の対策</h2>
<div class="outline-text-2" id="text-5">
<p>
実際の運用上はどちらも発生しりえる。それぞれのパターンに置いてLBがどう振る舞うかを明確
した上でワーカースレッドのbusy数とCPUの使用率を監視し、閉塞運用、スペアインスタンスの
運用などを設計することが大事だと思います。
</p>
</div>
</div>




<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 参考</h2>
<div class="outline-text-2" id="text-6">
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[メモ]CMS GCログの見方]]></title>
    <link href="http://luozengbin.github.io/blog/2014-11-05-%5B%E3%83%A1%E3%83%A2%5Dcms-gc%E3%83%AD%E3%82%B0%E3%81%AE%E8%A6%8B%E6%96%B9.html"/>
    <updated>2014-11-05T00:00:00+09:00</updated>
    <id>http://luozengbin.github.io/blog/[メモ]cms-gcログの見方</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 基本おさらい</a></li>
<li><a href="#sec-2">2. 実験するためのプログラム</a></li>
<li><a href="#sec-3">3. CMSログの見方</a>
<ul>
<li><a href="#sec-3-1">3.1. New領域GCログ</a></li>
<li><a href="#sec-3-2">3.2. Old領域GCログ</a></li>
<li><a href="#sec-3-3">3.3. concurrent mode failure</a></li>
<li><a href="#sec-3-4">3.4. 手動FullGC時のログ</a></li>
</ul>
</li>
<li><a href="#sec-4">4. 参考</a></li>
</ul>
</div>
</div>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 基本おさらい</h2>
<div class="outline-text-2" id="text-1">
<p>
CMSとは <code>Concurrent Mark &amp; Sweep</code> 、JVM OLD領域GC処理アルゴリズムの一種です。
CMSはアプリケーションを停止する時間を削減することが出来ます。処理の流れは下図に示す。
</p>

<p>
※Concurrentは同時という意味です。
</p>

<pre class="example">
       ①        ②          ③    ④
---&gt; | ==&gt; | ============&gt; | ==&gt; | ==========&gt; -----&gt;
---&gt; |     | ------------&gt; | ==&gt; | -----------------&gt;
---&gt; |     | ------------&gt; | ==&gt; | -----------------&gt;
---&gt; |     | ------------&gt; | ==&gt; | -----------------&gt;
---&gt; |     | ------------&gt; | ==&gt; | -----------------&gt;
---&gt; |     | ------------&gt; | ==&gt; | -----------------&gt;
       STW                   STW

凡例
+--------------------+
| ==&gt; GCスレッド     |
| --&gt; アプリスレッド |
+--------------------+
</pre>

<p>
図上示している通り、①と③の処理だけアプリケーションが停止する。
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">①</td>
<td class="left">Initial Mark</td>
<td class="left">STW</td>
<td class="left">Rootを起点に利用されてるオブジェクトをマークする</td>
</tr>

<tr>
<td class="left">②-1</td>
<td class="left">Concurrent Mark</td>
<td class="left">&#xa0;</td>
<td class="left">①でマークされたオブジェクトを起点に使用中のオブジェクトをマークする</td>
</tr>

<tr>
<td class="left">②-2</td>
<td class="left">Concurrent precleaning</td>
<td class="left">&#xa0;</td>
<td class="left">②-1処理中アプリによる生じた変化部分をマークする、③の処理時間を短縮するため</td>
</tr>

<tr>
<td class="left">③</td>
<td class="left">Parallel Remark</td>
<td class="left">STW</td>
<td class="left">②処理中アプリによる生じた変化部分をマークする</td>
</tr>

<tr>
<td class="left">④-1</td>
<td class="left">Concurrent Sweeping</td>
<td class="left">&#xa0;</td>
<td class="left">マーク処理によって判明した使用済みオブジェクトを削除する</td>
</tr>

<tr>
<td class="left">④-2</td>
<td class="left">Concurrent Reset</td>
<td class="left">&#xa0;</td>
<td class="left">CMS処理自体のリセット</td>
</tr>
</tbody>
</table>

<p>
<!-- more -->
</p>
</div>
</div>




<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 実験するためのプログラム</h2>
<div class="outline-text-2" id="text-2">
<p>
メモリを大量に消費するWebサービス
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #f0dfaf; font-weight: bold;">package</span> test.<span style="color: #bfebbf;">example</span>;

<span style="color: #f0dfaf; font-weight: bold;">import</span> <span style="color: #bfebbf;">javax</span>.<span style="color: #bfebbf;">jws</span>.<span style="color: #8cd0d3;">WebMethod</span>;
<span style="color: #f0dfaf; font-weight: bold;">import</span> <span style="color: #bfebbf;">javax</span>.<span style="color: #bfebbf;">jws</span>.<span style="color: #8cd0d3;">WebParam</span>;
<span style="color: #f0dfaf; font-weight: bold;">import</span> <span style="color: #bfebbf;">javax</span>.<span style="color: #bfebbf;">jws</span>.<span style="color: #8cd0d3;">WebService</span>;
<span style="color: #f0dfaf; font-weight: bold;">import</span> <span style="color: #bfebbf;">javax</span>.<span style="color: #bfebbf;">jws</span>.<span style="color: #bfebbf;">soap</span>.<span style="color: #8cd0d3;">SOAPBinding</span>;

<span style="color: #bfebbf;">@WebService</span>
<span style="color: #bfebbf;">@SOAPBinding</span>(style = <span style="color: #bfebbf;">SOAPBinding</span>.<span style="color: #bfebbf;">Style</span>.DOCUMENT, use = <span style="color: #bfebbf;">SOAPBinding</span>.<span style="color: #bfebbf;">Use</span>.LITERAL, parameterStyle = <span style="color: #bfebbf;">SOAPBinding</span>.<span style="color: #bfebbf;">ParameterStyle</span>.WRAPPED)
<span style="color: #f0dfaf; font-weight: bold;">public</span> <span style="color: #f0dfaf; font-weight: bold;">class</span> <span style="color: #8cd0d3;">HelloWorld</span> {

    <span style="color: #bfebbf;">@WebMethod</span>(action = <span style="color: #cc9393;">"sayHello"</span>)
    <span style="color: #f0dfaf; font-weight: bold;">public</span> <span style="color: #8cd0d3;">String</span> <span style="color: #8cd0d3;">sayHello</span>(<span style="color: #bfebbf;">@WebParam</span>(name = <span style="color: #cc9393;">"name"</span> ) <span style="color: #8cd0d3;">String</span> <span style="color: #dfaf8f;">name</span>) <span style="color: #f0dfaf; font-weight: bold;">throws</span> <span style="color: #8cd0d3;">CustomException</span> {

        System.out.println(<span style="color: #cc9393;">"Hello: "</span> + name);

        <span style="color: #bfebbf;">java</span>.<span style="color: #bfebbf;">util</span>.<span style="color: #8cd0d3;">List</span> <span style="color: #dfaf8f;">l</span>  =  <span style="color: #f0dfaf; font-weight: bold;">new</span> <span style="color: #bfebbf;">java</span>.<span style="color: #bfebbf;">util</span>.<span style="color: #8cd0d3;">ArrayList</span>&lt;&gt;();
        <span style="color: #8cd0d3;">int</span> <span style="color: #dfaf8f;">x</span>  = 0;
        <span style="color: #f0dfaf; font-weight: bold;">while</span> (x &lt; 6300) {
            <span style="color: #8cd0d3;">Thread</span> <span style="color: #dfaf8f;">t</span>  =  <span style="color: #f0dfaf; font-weight: bold;">new</span> <span style="color: #8cd0d3;">Thread</span>();
            l.add(t);

            <span style="color: #f0dfaf; font-weight: bold;">try</span> {
                Thread.sleep(10);
            } <span style="color: #f0dfaf; font-weight: bold;">catch</span> (<span style="color: #8cd0d3;">Exception</span> <span style="color: #dfaf8f;">e</span>) {
            }
            x++;
            System.out.println(x);
        }
        <span style="color: #f0dfaf; font-weight: bold;">return</span> <span style="color: #cc9393;">"Hello "</span> + name + <span style="color: #cc9393;">"!"</span>;
    }
}
</pre>
</div>

<p>
Webサービスを載せるAPサーバの起動オプションにGC関係のパラメータを追加する。
Old領域のGCを発生しやすくため、ヒープサイズを小さめに割り当てる。
</p>
<pre class="example">
JAVA_OPTS="$JAVA_OPTS -Xms512m -Xmx512m -XX:MaxPermSize=256m"
JAVA_OPTS="$JAVA_OPTS -XX:+UseConcMarkSweepGC -XX:+CMSClassUnloadingEnabled"
JAVA_OPTS="$JAVA_OPTS -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps"
JAVA_OPTS="$JAVA_OPTS -Xloggc:/tmp/gc-`date '+%Y-%m-%d'`.log"
</pre>

<p>
以下のオプション、GC時に詳細なオブジェクト統計情報も出力する。ここでは略します。
</p>
<pre class="example">
JAVA_OPTS="$JAVA_OPTS -XX:+PrintHeapAtGC -XX:+PrintTenuringDistribution"
</pre>

<p>
SoapUIから100多重で負荷を掛けて、テストアプリを実行させる。
</p>

<p>
SoapUIから負荷を掛けた後はしばらく、New領域のGCログが出続ける。Old領域が満タンな状態
になる前にOld領域のGCログが出始める。以下はOld領域GC発生前後のログを示す。
</p>

<pre class="example">
2014-11-05T14:24:49.336+0900: 214.204: [GC2014-11-05T14:24:49.336+0900: 214.204: [DefNew: 76672K-&gt;8512K(76672K), 0.0978870 secs] 455251K-&gt;395770K(515776K), 0.0981100 secs] [Times: user=0.08 sys=0.00, real=0.10 secs] 
2014-11-05T14:24:51.971+0900: 216.840: [GC2014-11-05T14:24:51.971+0900: 216.840: [DefNew: 76672K-&gt;8412K(76672K), 0.0816580 secs] 463930K-&gt;404301K(515776K), 0.0818720 secs] [Times: user=0.06 sys=0.00, real=0.08 secs] 
2014-11-05T14:24:54.767+0900: 219.636: [GC2014-11-05T14:24:54.767+0900: 219.636: [DefNew: 76572K-&gt;8415K(76672K), 0.1165260 secs] 472461K-&gt;412833K(515776K), 0.1172920 secs] [Times: user=0.06 sys=0.01, real=0.12 secs] 
2014-11-05T14:24:54.899+0900: 219.768: [GC [1 CMS-initial-mark: 404417K(439104K)] 414152K(515776K), 0.0252080 secs] [Times: user=0.02 sys=0.00, real=0.03 secs] 
2014-11-05T14:24:55.043+0900: 219.912: [CMS-concurrent-mark-start]
2014-11-05T14:24:56.941+0900: 221.810: [GC2014-11-05T14:24:56.941+0900: 221.810: [DefNew: 76575K-&gt;8512K(76672K), 0.0933500 secs] 480993K-&gt;423185K(515776K), 0.0935560 secs] [Times: user=0.07 sys=0.00, real=0.10 secs] 
2014-11-05T14:24:58.119+0900: 222.988: [CMS-concurrent-mark: 2.773/3.076 secs] [Times: user=2.38 sys=0.46, real=3.07 secs] 
2014-11-05T14:24:58.119+0900: 222.988: [CMS-concurrent-preclean-start]
2014-11-05T14:24:58.127+0900: 222.996: [CMS-concurrent-preclean: 0.007/0.008 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
2014-11-05T14:24:58.127+0900: 222.996: [CMS-concurrent-abortable-preclean-start]
 CMS: abort preclean due to time 2014-11-05T14:25:03.224+0900: 228.092: [CMS-concurrent-abortable-preclean: 2.683/5.096 secs] [Times: user=2.44 sys=0.08, real=5.10 secs] 
2014-11-05T14:25:03.224+0900: 228.093: [GC[YG occupancy: 48273 K (76672 K)]2014-11-05T14:25:03.224+0900: 228.093: [Rescan (non-parallel) 2014-11-05T14:25:03.224+0900: 228.093: [grey object rescan, 0.0011680 secs]2014-11-05T14:25:03.225+0900: 228.094: [root rescan, 0.2362360 secs], 0.2375020 secs]2014-11-05T14:25:03.462+0900: 228.331: [weak refs processing, 0.0044290 secs]2014-11-05T14:25:03.466+0900: 228.335: [class unloading, 0.0089260 secs]2014-11-05T14:25:03.475+0900: 228.344: [scrub symbol table, 0.0179240 secs]2014-11-05T14:25:03.493+0900: 228.362: [scrub string table, 0.0013030 secs] [1 CMS-remark: 414673K(439104K)] 462947K(515776K), 0.2714240 secs] [Times: user=0.26 sys=0.00, real=0.27 secs] 
2014-11-05T14:25:03.504+0900: 228.373: [CMS-concurrent-sweep-start]
2014-11-05T14:25:03.816+0900: 228.685: [CMS-concurrent-sweep: 0.310/0.312 secs] [Times: user=0.23 sys=0.00, real=0.31 secs] 
2014-11-05T14:25:03.817+0900: 228.686: [CMS-concurrent-reset-start]
2014-11-05T14:25:03.819+0900: 228.687: [CMS-concurrent-reset: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2014-11-05T14:25:04.454+0900: 229.323: [GC [1 CMS-initial-mark: 394635K(439104K)] 443918K(515776K), 0.0809520 secs] [Times: user=0.08 sys=0.00, real=0.08 secs] 
2014-11-05T14:25:04.538+0900: 229.407: [CMS-concurrent-mark-start]
2014-11-05T14:25:05.602+0900: 230.471: [CMS-concurrent-mark: 1.064/1.064 secs] [Times: user=1.01 sys=0.00, real=1.07 secs] 
2014-11-05T14:25:05.603+0900: 230.471: [CMS-concurrent-preclean-start]
2014-11-05T14:25:05.605+0900: 230.474: [CMS-concurrent-preclean: 0.003/0.003 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
2014-11-05T14:25:05.605+0900: 230.474: [CMS-concurrent-abortable-preclean-start]
 CMS: abort preclean due to time 2014-11-05T14:25:10.648+0900: 235.516: [CMS-concurrent-abortable-preclean: 1.979/5.042 secs] [Times: user=1.89 sys=0.01, real=5.04 secs] 
2014-11-05T14:25:10.648+0900: 235.517: [GC[YG occupancy: 55959 K (76672 K)]2014-11-05T14:25:10.648+0900: 235.517: [Rescan (non-parallel) 2014-11-05T14:25:10.648+0900: 235.517: [grey object rescan, 0.0012890 secs]2014-11-05T14:25:10.649+0900: 235.518: [root rescan, 0.1016560 secs], 0.1030300 secs]2014-11-05T14:25:10.751+0900: 235.620: [weak refs processing, 0.0000500 secs]2014-11-05T14:25:10.751+0900: 235.620: [class unloading, 0.0078410 secs]2014-11-05T14:25:10.759+0900: 235.628: [scrub symbol table, 0.0162830 secs]2014-11-05T14:25:10.775+0900: 235.644: [scrub string table, 0.0010720 secs] [1 CMS-remark: 394635K(439104K)] 450595K(515776K), 0.1292870 secs] [Times: user=0.12 sys=0.01, real=0.13 secs] 
2014-11-05T14:25:10.777+0900: 235.646: [CMS-concurrent-sweep-start]
2014-11-05T14:25:10.981+0900: 235.850: [CMS-concurrent-sweep: 0.203/0.203 secs] [Times: user=0.20 sys=0.00, real=0.20 secs] 
2014-11-05T14:25:10.981+0900: 235.850: [CMS-concurrent-reset-start]
2014-11-05T14:25:10.983+0900: 235.852: [CMS-concurrent-reset: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2014-11-05T14:25:32.473+0900: 257.342: [GC2014-11-05T14:25:32.474+0900: 257.342: [DefNew: 76664K-&gt;2361K(76672K), 0.0146410 secs] 463666K-&gt;389381K(515776K), 0.0148600 secs] [Times: user=0.01 sys=0.00, real=0.02 secs] 
2014-11-05T14:26:44.480+0900: 329.349: [GC2014-11-05T14:26:44.480+0900: 329.349: [DefNew: 70521K-&gt;1291K(76672K), 0.0214830 secs] 457541K-&gt;388311K(515776K), 0.0216760 secs] [Times: user=0.01 sys=0.00, real=0.02 secs] 
2014-11-05T14:27:56.504+0900: 401.373: [GC2014-11-05T14:27:56.504+0900: 401.373: [DefNew: 69451K-&gt;1214K(76672K), 0.0102000 secs] 456471K-&gt;388234K(515776K), 0.0103740 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]
</pre>
</div>
</div>




<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> CMSログの見方</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> New領域GCログ</h3>
<div class="outline-text-3" id="text-3-1">
<p>
New領域のGCは <code>minor GC</code> と呼ばれる場合があります。
</p>

<p>
<code>DefNew</code> と <code>PraNew</code> 文字が含まれた行は <code>New</code> 領域のGC処理ログです。シングルコアの場合
<code>DefNew=、マルチコアは =PraNew</code> となります。
</p>

<p>
New領域のGCログは一行で完結する。ログ先頭の <code>GC</code> タグはSTWであることを示している。(つ
まりNew領域のGC処理はStop the worldです)続きの部分はGC前後New領域内メモリの変化を示し
ている、その次の部分は、JVM全体のメモリ使用量の変化を示している。
</p>
<pre class="example">
2014-11-05T16:59:21.544+0900: 9486.413: [GC2014-11-05T16:59:21.544+0900: 9486.413: [DefNew: 68932K-&gt;1046K(76672K), 0.0122090 secs] 472847K-&gt;405094K(515776K), 0.0123880 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 
                                          ★                                        ~~~~~~  ~~~~~   ~~~~  ~~~~                     ~~~~~~~  ~~~~~~
                                                                                      A       B       C     D                         E       F
</pre>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">A</td>
<td class="left">New領域のGC</td>
<td class="left">DefNew</td>
</tr>

<tr>
<td class="left">B</td>
<td class="left">GC前New領域の使用量</td>
<td class="left">68932K</td>
</tr>

<tr>
<td class="left">C</td>
<td class="left">GC後New領域の使用量</td>
<td class="left">1046K</td>
</tr>

<tr>
<td class="left">D</td>
<td class="left">New領域GCの閾値</td>
<td class="left">76672K</td>
</tr>

<tr>
<td class="left">E</td>
<td class="left">GC前JVMメモリの使用量</td>
<td class="left">472847K</td>
</tr>

<tr>
<td class="left">F</td>
<td class="left">GC後JVMメモリの使用量</td>
<td class="left">405094K</td>
</tr>
</tbody>
</table>

<p>
New領域容量の変化とJMV全体のメモリ容量の変化からOLD領域の増加サイズを算出する。
</p>

<pre class="example">
New領域変化容量： 68932 K - 1046K   = 67886K
JVM全体変化容量： 472847K - 405094K = 67753K
★OLD領域の増加サイズ： New領域変化容量 - JVM全体変化容量 = 133K
</pre>

<p>
最後の <code>real</code> 部分はSTW(アプリ停止時間)の時間となります、10ミリ秒ですね。
</p>
<pre class="example">
[Times: user=0.01 sys=0.00, real=0.01 secs]
</pre>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Old領域GCログ</h3>
<div class="outline-text-3" id="text-3-2">
<p>
以下は通常なCMS処理のログです。
</p>
<pre class="example">
★CMS起きる前のNewGCログ
2014-11-05T16:59:21.544+0900: 9486.413: [GC2014-11-05T16:59:21.544+0900: 9486.413: [DefNew: 68932K-&gt;1046K(76672K), 0.0122090 secs] 472847K-&gt;405094K(515776K), 0.0123880 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 

★①
2014-11-05T16:59:21.564+0900: 9486.433: [GC [1 CMS-initial-mark: 404047K(439104K)] 405358K(515776K), 0.0084940 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 

★②-1
2014-11-05T16:59:21.573+0900: 9486.442: [CMS-concurrent-mark-start]
2014-11-05T16:59:21.727+0900: 9486.596: [CMS-concurrent-mark: 0.154/0.154 secs] [Times: user=0.14 sys=0.00, real=0.15 secs] 

★②-2
2014-11-05T16:59:21.727+0900: 9486.596: [CMS-concurrent-preclean-start]
2014-11-05T16:59:21.754+0900: 9486.623: [CMS-concurrent-preclean: 0.027/0.027 secs] [Times: user=0.00 sys=0.00, real=0.03 secs] 

★③
2014-11-05T16:59:21.754+0900: 9486.623: [GC[YG occupancy: 1535 K (76672 K)]2014-11-05T16:59:21.754+0900: 9486.623: [Rescan (non-parallel) 2014-11-05T16:59:21.754+0900: 9486.623: [grey object rescan, 0.0012560 secs]2014-11-05T16:59:21.755+0900: 9486.624: [root rescan, 0.0064000 secs], 0.0077470 secs]2014-11-05T16:59:21.762+0900: 9486.631: [weak refs processing, 0.0003290 secs]2014-11-05T16:59:21.762+0900: 9486.631: [class unloading, 0.0108870 secs]2014-11-05T16:59:21.773+0900: 9486.642: [scrub symbol table, 0.0156480 secs]2014-11-05T16:59:21.789+0900: 9486.658: [scrub string table, 0.0012200 secs] [1 CMS-remark: 404047K(439104K)] 405583K(515776K), 0.0371740 secs] [Times: user=0.04 sys=0.01, real=0.04 secs] 

★④-1
2014-11-05T16:59:21.792+0900: 9486.661: [CMS-concurrent-sweep-start]
2014-11-05T16:59:22.187+0900: 9487.056: [CMS-concurrent-sweep: 0.395/0.395 secs] [Times: user=0.38 sys=0.00, real=0.39 secs] 

★④-2
2014-11-05T16:59:22.189+0900: 9487.057: [CMS-concurrent-reset-start]

2014-11-05T16:59:22.190+0900: 9487.059: [CMS-concurrent-reset: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 

★CMS後のNewGCログ
2014-11-05T17:00:32.559+0900: 9557.428: [GC2014-11-05T17:00:32.559+0900: 9557.428: [DefNew: 69206K-&gt;1062K(76672K), 0.0103860 secs] 104633K-&gt;36628K(515776K), 0.0105880 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]
</pre>
<p>
CMS前後のNewGCログのJVMメモリ使用量からメモリが掃除されることをわかります。
405094K → 104633K、約293MBが掃除された。
</p>

<p>
Initial Markフェースログの先頭に <code>GC</code> 文字が現れるので、STWが発生することが分かります。
</p>
<pre class="example">
★①
2014-11-05T16:59:21.564+0900: 9486.433: [GC [1 CMS-initial-mark: 404047K(439104K)] 405358K(515776K), 0.0084940 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 
                                                                 ~~~~~~  ~~~~~~    ~~~~~~  ~~~~~~                                                 ~~~~~~~~~~~~
                                                                   A        B        C       D                                                         E
</pre>
<p>
Initial Markフェースログの内訳
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">A</td>
<td class="left">CMS起動時のOLD領域使用量</td>
<td class="left">404047K</td>
</tr>

<tr>
<td class="left">B</td>
<td class="left">CMSトリガーするOLD領域閾値</td>
<td class="left">439104K</td>
</tr>

<tr>
<td class="left">C</td>
<td class="left">CMS起動時JVMのメモリの使用量</td>
<td class="left">405358K</td>
</tr>

<tr>
<td class="left">D</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">E</td>
<td class="left">Initial Markフェースで消費した時間</td>
<td class="left">10 ミリ秒</td>
</tr>
</tbody>
</table>

<p>
続いて、Concurrent MarkとConcurrent precleaning処理の時間を示している。この部分の処理
はアプリケーションと平行で行われるため、停止時間生じない。
</p>
<pre class="example">
★②-1
2014-11-05T16:59:21.573+0900: 9486.442: [CMS-concurrent-mark-start]
2014-11-05T16:59:21.727+0900: 9486.596: [CMS-concurrent-mark: 0.154/0.154 secs] [Times: user=0.14 sys=0.00, real=0.15 secs] 
                                                                                                            ~~~~~~~~~~~~~~
                                                                                                                  F
★②-2
2014-11-05T16:59:21.727+0900: 9486.596: [CMS-concurrent-preclean-start]
2014-11-05T16:59:21.754+0900: 9486.623: [CMS-concurrent-preclean: 0.027/0.027 secs] [Times: user=0.00 sys=0.00, real=0.03 secs] 
                                                                                                                ~~~~~~~~~~~~~~
                                                                                                                      G
</pre>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">F</td>
<td class="left">Concurrent Markフェースで消費した時間</td>
<td class="left">150 ミリ秒</td>
</tr>

<tr>
<td class="left">G</td>
<td class="left">Concurrent Precleanフェースで消費した時間</td>
<td class="left">30ミリ秒</td>
</tr>
</tbody>
</table>

<p>
Parallel Remarkフェーズのログは１行で完結する、折り返してインデントを付けると次の形に
なります。
</p>
<pre class="example">
★③
2014-11-05T16:59:21.754+0900: 9486.623:
[GC
    [YG occupancy: 1535 K (76672 K)]
                   ~~~~    ~~~~~
                    H        I
    2014-11-05T16:59:21.754+0900: 9486.623:
                                            [
                                              Rescan (non-parallel)
                                                2014-11-05T16:59:21.754+0900: 9486.623: [grey object rescan, 0.0012560 secs]
                                                2014-11-05T16:59:21.755+0900: 9486.624: [root rescan, 0.0064000 secs]
                                             , 0.0077470 secs
                                            ]
    2014-11-05T16:59:21.762+0900: 9486.631: [weak refs processing, 0.0003290 secs]
    2014-11-05T16:59:21.762+0900: 9486.631: [class unloading, 0.0108870 secs]
    2014-11-05T16:59:21.773+0900: 9486.642: [scrub symbol table, 0.0156480 secs]
    2014-11-05T16:59:21.789+0900: 9486.658: [scrub string table, 0.0012200 secs]

    [1 CMS-remark: 404047K(439104K)] 405583K(515776K), 0.0371740 secs
                   ~~~~~~  ~~~~~~    ~~~~~~  ~~~~~~
                     J       K         L       M
]
[Times: user=0.04 sys=0.01, real=0.04 secs]
                            ~~~~~~~~~~~~~~
                                 N
</pre>
<p>
内訳
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">H</td>
<td class="left">現時点New領域の使用量</td>
<td class="left">1535K</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">I</td>
<td class="left">New領域GCの閾値</td>
<td class="left">76672K</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">J</td>
<td class="left">現時点OLD領域使用量</td>
<td class="left">404047K</td>
<td class="left">変化なし</td>
</tr>

<tr>
<td class="left">K</td>
<td class="left">CMSトリガーするOLD領域閾値</td>
<td class="left">439104K</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">L</td>
<td class="left">現時点JVMのメモリの使用量</td>
<td class="left">405583K</td>
<td class="left">225K増加</td>
</tr>

<tr>
<td class="left">M</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">N</td>
<td class="left">Parallel Remarkフェーズで消費した時間</td>
<td class="left">40 ミリ秒</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>
<p>
処理時間からみるとParallel RemarkフェーズはInitial Markフフェーズより時間がかかること
が分かりました。
</p>

<p>
続いて、Concurrent SweepとConcurrent Reset処理の時間を示している。この部分の処理
はアプリケーションと平行で行われるため、停止時間生じない。
</p>
<pre class="example">
★④-1
2014-11-05T16:59:21.792+0900: 9486.661: [CMS-concurrent-sweep-start]
2014-11-05T16:59:22.187+0900: 9487.056: [CMS-concurrent-sweep: 0.395/0.395 secs] [Times: user=0.38 sys=0.00, real=0.39 secs]
                                                                                                             ~~~~~~~~~~~~~~
                                                                                                                   O
★④-2
2014-11-05T16:59:22.189+0900: 9487.057: [CMS-concurrent-reset-start]
2014-11-05T16:59:22.190+0900: 9487.059: [CMS-concurrent-reset: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]
                                                                                                             ~~~~~~~~~~~~~~~
                                                                                                                   P
</pre>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">O</td>
<td class="left">Concurrent Sweepフェースで消費した時間</td>
<td class="left">390 ミリ秒</td>
</tr>

<tr>
<td class="left">P</td>
<td class="left">Concurrent Resetフェースで消費した時間</td>
<td class="left">10ミリ秒</td>
</tr>
</tbody>
</table>

<p>
フェース①〜④の処理時間とJVMメモリ容量変化は以下となります。
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="right" />

<col  class="right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">&#xa0;</th>
<th scope="col" class="left">フェーズ名</th>
<th scope="col" class="left">一時停止</th>
<th scope="col" class="right">処理時間(ミリ秒)</th>
<th scope="col" class="right">JVMメモリ(MB)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">①</td>
<td class="left">Initial Mark</td>
<td class="left">◯</td>
<td class="right">10</td>
<td class="right">395.8</td>
</tr>

<tr>
<td class="left">②-1</td>
<td class="left">Concurrent Mark</td>
<td class="left">&#xa0;</td>
<td class="right">150</td>
<td class="right">&#xa0;</td>
</tr>

<tr>
<td class="left">②-2</td>
<td class="left">Concurrent precleaning</td>
<td class="left">&#xa0;</td>
<td class="right">30</td>
<td class="right">&#xa0;</td>
</tr>

<tr>
<td class="left">③</td>
<td class="left">Parallel Remark</td>
<td class="left">◯</td>
<td class="right">40</td>
<td class="right">396.0</td>
</tr>

<tr>
<td class="left">④-1</td>
<td class="left">Concurrent Sweeping</td>
<td class="left">&#xa0;</td>
<td class="right">390</td>
<td class="right">102.0</td>
</tr>

<tr>
<td class="left">④-2</td>
<td class="left">Concurrent Reset</td>
<td class="left">&#xa0;</td>
<td class="right">10</td>
<td class="right">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="right">630</td>
<td class="right">-294</td>
</tr>
</tbody>
</table>
<p>
CMS全体処理で630ミリ秒かかる、そのうち50ミリ秒の停止時間が発生する。掃除されたメモリ
容量約294MB。
</p>
</div>
</div>


<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> concurrent mode failure</h3>
<div class="outline-text-3" id="text-3-3">
<p>
次の状況に置いて、コンカレントGCが縮退しFullGCを引き起こす可能性があります。
</p>
<ul class="org-ul">
<li>システムが高負荷時に、新しいオブジェクトの生成速度がGCのメモリ解放速度より早い
</li>
<li>Java ヒープの断片化率が非常に高い時
</li>
</ul>

<p>
また、縮退後のFullGCは <code>Serial Old</code> モードで行われるため、アプリ停止時間が長くなります。
</p>

<p>
<code>Initial Mark</code> 次の <code>Concurrent Mark</code> で縮退が起きて、 <code>FullGC</code> が起こった例。
</p>
<pre class="example">
2014-11-20T14:04:17.969+0900: 423.523: [GC [1 CMS-initial-mark: 439103K(439104K)] 451488K(515776K), 0.0209760 secs] [Times: user=0.02 sys=0.00, real=0.02 secs] 
2014-11-20T14:04:18.110+0900: 423.663: [CMS-concurrent-mark-start]
2014-11-20T14:04:19.105+0900: 424.659: [Full GC2014-11-20T14:04:19.105+0900: 424.659: [CMS2014-11-20T14:04:19.745+0900: 425.299: [CMS-concurrent-mark: 1.632/1.636 secs] [Times: user=1.41 sys=0.17, real=1.64 secs] 
 (concurrent mode failure): 439103K-&gt;439103K(439104K), 1.7507640 secs] 515775K-&gt;458321K(515776K), [CMS Perm : 57066K-&gt;57066K(95504K)], 1.7509190 secs] [Times: user=1.74 sys=0.00, real=1.75 secs]
</pre>

<p>
<code>FullGC</code> を示すログに内容を分解すると次のようになります。
</p>
<pre class="example">
2014-11-20T14:04:19.105+0900: 424.659:
    [Full GC2014-11-20T14:04:19.105+0900: 424.659: 

          ★CMS失敗時の内容
          [CMS2014-11-20T14:04:19.745+0900: 425.299: 
               [CMS-concurrent-mark: 1.632/1.636 secs]
               [Times: user=1.41 sys=0.17, real=1.64 secs]  
               (concurrent mode failure): 439103K-&gt;439103K(439104K), 1.7507640 secs] 

          ★縮退後、FullGC実施後の結果
          515775K-&gt;458321K(515776K), [CMS Perm : 57066K-&gt;57066K(95504K)], 1.7509190 secs]

    [Times: user=1.74 sys=0.00, real=1.75 secs]
</pre>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> 手動FullGC時のログ</h3>
<div class="outline-text-3" id="text-3-4">
<p>
CMS GCを利用した場合でも手動でFullGCを起こすことは可能です。以下は手動GC掛けられた時
にのGCログとなります。
</p>

<pre class="example">
2014-11-20T15:03:39.462+0900: 2611.658: [Full GC2014-11-20T15:03:39.462+0900: 2611.658: [CMS: 365597K-&gt;33109K(439104K), 0.3923750 secs] 408803K-&gt;33109K(515776K), [CMS Perm : 57580K-&gt;57357K(95888K)], 0.3925240 secs] [Times: user=0.36 sys=0.00, real=0.39 secs] 

★分解
2014-11-20T15:03:39.462+0900: 2611.658: 
    [Full GC2014-11-20T15:03:39.462+0900: 2611.658: 
          [CMS: 365597K-&gt;33109K(439104K), 0.3923750 secs] 408803K-&gt;33109K(515776K), 
          [CMS Perm : 57580K-&gt;57357K(95888K)], 0.3925240 secs] 
    [Times: user=0.36 sys=0.00, real=0.39 secs]
</pre>
</div>
</div>
</div>




<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 参考</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li><a href="http://wall-climb.com/2009/10/12/%25E3%2582%25B3%25E3%2583%25B3%25E3%2582%25AB%25E3%2583%25AC%25E3%2583%25B3%25E3%2583%2588gc%25E3%2581%25AE%25E6%25B3%25A8%25E6%2584%258F%25E7%2582%25B9/">コンカレントGCの注意点</a>
</li>
<li><a href="http://automation123.blogspot.jp/2012/02/understanding-concurrent-mark-sweep.html">Understanding Concurrent Mark Sweep Garbage Collector Logs</a>
</li>
<li><a href="https://blogs.oracle.com/poonam/entry/understanding_cms_gc_logs">Understanding CMS GC Logs</a>
</li>
<li><a href="http://a4dosanddos.hatenablog.com/entry/2014/01/24/011007">「Java」GC ログを出力する</a>
</li>
<li><a href="http://h50146.www5.hp.com/products/software/oe/hpux/developer/column02/gabage_02/">Javaのかなめ、「ガベージ・コレクション」をやさしく学ぶ・後編</a>
</li>
</ul>
</div>
</div>

]]></content>
  </entry>
  
</feed>
