<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | Akira's Tech Notes]]></title>
  <link href="http://luozengbin.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://luozengbin.github.io/"/>
  <updated>2015-07-02T19:17:14+09:00</updated>
  <id>http://luozengbin.github.io/</id>
  <author>
    <name><![CDATA[luozengbin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[tips][Java]メモリswapによる無応答]]></title>
    <link href="http://luozengbin.github.io/blog/2015-06-29-%5Btips%5D%5Bjava%5D%E3%83%A1%E3%83%A2%E3%83%AAswap%E3%81%AB%E3%82%88%E3%82%8B%E7%84%A1%E5%BF%9C%E7%AD%94.html"/>
    <updated>2015-06-29T00:00:00+09:00</updated>
    <id>http://luozengbin.github.io/blog/[tips][java]メモリswapによる無応答</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 環境</a></li>
<li><a href="#sec-2">2. 現象</a></li>
<li><a href="#sec-3">3. 分析するためのデータを取る</a></li>
<li><a href="#sec-4">4. 原因／考察</a></li>
</ul>
</div>
</div>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 環境</h2>
<div class="outline-text-2" id="text-1">
<p>
業務用の開発サーバ
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">項目</th>
<th scope="col" class="left">スペック</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">CPU</td>
<td class="left">Intel(R) Core(TM)2 Duo CPU E8400 3.00GHz</td>
</tr>

<tr>
<td class="left">Core数</td>
<td class="left">2</td>
</tr>

<tr>
<td class="left">Memory</td>
<td class="left">7G弱</td>
</tr>

<tr>
<td class="left">OS</td>
<td class="left">Red Hat Enterprise Linux Server release 5.8 (Tikanga)</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">Middleware</td>
<td class="left">java 1.7.0_75</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">Weblogic 10.3.5.0</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">Oracle BPM Suite 11g (メモリを多めに割り当てた：6Gぐらい)</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">※他にものもの結構乗っている</td>
</tr>
</tbody>
</table>
</div>
</div>




<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 現象</h2>
<div class="outline-text-2" id="text-2">
<ul class="org-ul">
<li>特定のWeblogic管理対象サーバから応答が時々遅い(数秒程度)
</li>
<li>Full GCが起きると状況が悪化し、FullGCが終わらない
</li>
</ul>

<p>
<!-- more -->
</p>
</div>
</div>




<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 分析するためのデータを取る</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>GCログからParNew処理が5秒以上のレコードを時間を抽出する。
</li>
</ul>
<pre class="example">
2015-06-24T18:08:32.220+0900:  5.2666840
2015-06-25T01:50:56.578+0900:  5.6046080
2015-06-25T04:50:52.234+0900:  6.0052120
2015-06-25T12:05:52.068+0900:  9.2609380
2015-06-25T13:20:37.953+0900:  5.0946760
2015-06-25T13:20:58.403+0900:  5.6533820
2015-06-25T20:24:49.357+0900:  7.3204730
2015-06-25T21:16:10.126+0900:  6.7909460
2015-06-25T22:50:58.756+0900:  5.8355060
2015-06-26T01:50:50.893+0900:  9.3892250
2015-06-26T04:50:53.219+0900:  13.1395190
2015-06-26T07:50:54.425+0900:  11.7807430
2015-06-26T07:51:07.269+0900:  5.2793300
2015-06-26T10:50:51.114+0900:  9.3924480
2015-06-26T13:17:06.286+0900:  6.2010290
2015-06-26T13:17:54.396+0900:  7.3440480
2015-06-26T13:34:05.326+0900:  7.6791300
2015-06-26T13:51:04.590+0900:  10.2367630
2015-06-26T14:00:00.516+0900:  5.7046080
2015-06-26T14:00:13.463+0900:  6.6349530
2015-06-26T14:23:00.180+0900:  5.6609030
2015-06-26T14:26:28.796+0900:  7.6549640
2015-06-26T14:27:00.169+0900:  11.8500770
2015-06-26T14:29:39.363+0900:  7.1499710
2015-06-26T14:30:24.067+0900:  5.6382340
2015-06-26T14:31:45.304+0900:  10.1924060
2015-06-26T14:32:00.774+0900:  9.6242400
2015-06-26T16:51:18.422+0900:  9.6966490
2015-06-26T16:51:45.363+0900:  6.2090530
2015-06-26T18:30:49.993+0900:  6.2954670
2015-06-26T18:38:00.437+0900:  8.8749850
2015-06-26T18:50:00.391+0900:  7.4192490
2015-06-26T18:54:00.271+0900:  6.4426840
2015-06-26T18:54:08.234+0900:  5.7452440
2015-06-27T01:50:50.387+0900:  5.8063930
2015-06-27T01:51:05.004+0900:  5.2115420
2015-06-27T04:50:58.781+0900:  12.9891770
2015-06-27T04:51:35.039+0900:  5.7282510
2015-06-27T07:50:51.112+0900:  13.1250670
2015-06-27T07:51:06.604+0900:  6.5727200
2015-06-27T07:51:29.483+0900:  5.3706130
2015-06-27T07:51:36.469+0900:  7.0014700
2015-06-27T07:51:49.055+0900:  7.4964390
2015-06-27T07:52:01.446+0900:  5.2537540
2015-06-27T08:01:04.920+0900:  21.8820470
2015-06-27T09:53:02.648+0900:  7.4830120
2015-06-27T10:50:52.478+0900:  12.4821770
2015-06-27T10:51:07.595+0900:  6.6430700
2015-06-27T10:51:34.192+0900:  5.4682220
2015-06-27T10:51:59.431+0900:  5.8981600
2015-06-27T13:50:54.701+0900:  13.1269190
2015-06-27T13:52:23.353+0900:  6.3293780
2015-06-27T16:46:06.634+0900:  7.5433970
2015-06-28T04:51:06.881+0900:  5.2944910
2015-06-28T13:50:55.136+0900:  7.2090390
2015-06-28T16:50:52.379+0900:  6.3410470
2015-06-28T17:01:07.773+0900:  6.1038880
2015-06-28T19:50:50.750+0900:  7.1304960
2015-06-28T19:50:59.538+0900:  14.1206920
2015-06-28T19:51:39.786+0900:  7.8585130
2015-06-28T20:10:05.988+0900:  5.1535220
2015-06-28T22:46:07.996+0900:  6.3876340
2015-06-28T22:50:56.687+0900:  5.4313050
2015-06-29T01:51:06.697+0900:  7.4033850
2015-06-29T05:24:56.775+0900:  6.1023960
2015-06-29T06:01:13.724+0900:  6.7346550
2015-06-29T07:16:11.399+0900:  21.2494760
2015-06-29T07:50:59.386+0900:  5.9733680
2015-06-29T10:11:13.076+0900:  10.1998490
2015-06-29T10:51:20.998+0900:  10.4616600
2015-06-29T11:02:06.230+0900:  6.6641290
</pre>

<p>
図形にPlotしてみたら、ParNewが高いGCの時間帯があんまり規則がないので、定期イベントに
よるものではないと判断した。
</p>


<div class="figure">
<p><img src="img/2015-06-29-ParNewGC_TimeChart.png" alt="2015-06-29-ParNewGC_TimeChart.png" />
</p>
</div>

<ul class="org-ul">
<li>FullGC時システムリソースの変化状況
</li>
</ul>
<pre class="example">
$ vmstat 5 60
 1|procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------
 2| r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 3| 0  0 3379376 115268   9804 467464   12    9   107    34    1    1  8  2 89  1  0
 4| 0  0 3379376 113584   9808 468660    0    0   237    41  512  719  4  1 93  1  0
 5| 0  1 3377744  95484   9828 469060  749    0   825    15  567  793  5  1 78 16  0
 6| 0  1 3369436  80108   9836 469092 3175    0  3175    44  471  759  1  1 50 49  0
 7| 0  1 3360436  60896   9836 469072 3807    0  3807     3  451  776  0  1 49 49  0
 8| 0  1 3352216  48620   9844 465784 3375  155  3375   158  450  744  0  1 50 49  0
 9| 0  1 3347272  51844   9804 450912 2879  874  2879   878  568  739  1  2 49 49  0
10| 0  1 3339972  49380   9652 444336 2601  541  2601   558  551  697  0  1 47 52  0
11| 1  1 3336692  50752   9560 434856 2364  768  2364   768  605  692  1  1 49 49  0
12| 1  1 3332740  52108   9416 425016 2293  761  2293   791  604  682  1  1 49 49  0
13| 0  1 3325100  52224   9400 412236 3399  662  3399   675  564  730  0  1 50 49  0
14| 0  1 3320168  48248   9336 405168 2868  530  2868   533  513  717  0  1 49 49  0
</pre>
<p>
5行目はFullGC実施のタイミングです。5行目以降si/so/si/boの数値が上がる。
</p>
</div>
</div>




<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 原因／考察</h2>
<div class="outline-text-2" id="text-4">
<p>
swpd列の値を見れば原因は明白ですね、物理メモリが足らずJavaプロセスのメモリが大半スワー
プアウトされた、FullGCを掛けるとオブジェクトの参照を検査するためにヒープ全体を舐める。
メモリから追い出されたヒープメモリをディスクから読み戻し、また読み戻した分の領域を確
報するため、相対的に使っていないメモリをディスクに追い出す処理が激しく繰り返した。
</p>

<ul class="org-ul">
<li>Javaプロセスのヒープ／Permに物理メモリの容量以上を割り当てしては行けない
</li>
<li>Swapと共にFullGCが起きると、 <code>kill -9</code> で強制停止する
</li>
</ul>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[メモ]JavaBeans仕様を再認識する]]></title>
    <link href="http://luozengbin.github.io/blog/2015-06-13-%5B%E3%83%A1%E3%83%A2%5Djavabeans%E4%BB%95%E6%A7%98%E3%82%92%E5%86%8D%E8%AA%8D%E8%AD%98%E3%81%99%E3%82%8B.html"/>
    <updated>2015-06-13T00:00:00+09:00</updated>
    <id>http://luozengbin.github.io/blog/[メモ]javabeans仕様を再認識する</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 仕様のゴール</a></li>
<li><a href="#sec-2">2. JavaBeansとは</a></li>
<li><a href="#sec-3">3. JavaBeansの出番</a></li>
<li><a href="#sec-4">4. APIパッケージの概要</a></li>
<li><a href="#sec-5">5. よく出てくるクラス</a></li>
<li><a href="#sec-6">6. サードパーティライブラリ</a></li>
<li><a href="#sec-7">7. 参考情報</a></li>
</ul>
</div>
</div>


<p>
勉強メモ
</p>




<p>
<!-- more -->
</p>




<p>
JCPサイト <code>JavaBeans</code> で検索したら <a href="https://jcp.org/en/jsr/summary?id=javabeans">;-(</a> EJBの仕様しかなかったで、JavaBeans APIで検索
するとヒットしました。
</p>




<p>
これがが一番わかり易いと思います。→ <a href="http://otndnld.oracle.co.jp/tech/java/htdocs/java_roadmap/javabean/listing.htm">Oracle Javaロードマップ:JavaBeans</a>
</p>




<p>
公式の仕様はここ → <a href="http://download.oracle.com/otndocs/jcp/7224-javabeans-1.01-fr-spec-oth-JSpec/">JavaBeans Spec</a>
</p>




<p>
仕様変更履歴
</p>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="right" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="right">&#xa0;</th>
<th scope="col" class="right">仕様のバージョン</th>
<th scope="col" class="left">JDKバージョン</th>
</tr>
</thead>
<tbody>
<tr>
<td class="right">1996</td>
<td class="right">1.0.0</td>
<td class="left">JDK1.1</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="right">1997</td>
<td class="right">1.0.1</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>


<p>
<a href="http://ja.wikipedia.org/wiki/Java_Community_Process">JCP設立</a> されるまで策定された仕様なのでJSR番号が付いていないですね。
1997以降仕様更新あり？なし？分からない、掲示がないので恐らく大きな更新がないでしょう。
</p>




<p>
PDF版は114ページで結構のボリュームです。
</p>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 仕様のゴール</h2>
<div class="outline-text-2" id="text-1">
<p>
JavaBeans Specより
</p>
<pre class="example">
The goal of the JavaBeans APIs is to define a software component model for Java, so
that thirdparty ISVs can create and ship Java components that can be composed
together into applica-tions by end users.
</pre>

<p>
<a href="http://otndnld.oracle.co.jp/tech/java/htdocs/java_roadmap/glossary.htm#434709">オラクルの用語集より</a>
</p>
<pre class="example">
Javaで作成された移植可能なプラットフォームに依存しないコンポーネント・モデルで、
JavaBean仕様に従う。 再使用可能なコンポーネントを作成できる。
</pre>
</div>
</div>




<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> JavaBeansとは</h2>
<div class="outline-text-2" id="text-2">
<p>
JavaBeans Specの2.1 What is a Bean?より
</p>
<pre class="example">
Let's start with an initial definition and then refine it:
“A Java Bean is a reusable software component that can be manipulated visually in a builder tool.”
This covers a wide range of different possibilities.
The builder tools may include web page builders, visual application builders, GUI layout build-
ers, or even server application builders. Sometimes the “builder tool” may simply be a docu-
ment editor that is including some beans as part of a compound document.
Some Java Beans may be simple GUI elements such as buttons and sliders. Other Java Beans
may be sophisticated visual software components such as database viewers, or data feeds.
Some Java Beans may have no GUI appearance of their own, but may still be composed togeth-
er visually using an application builder.
Some builder tools may operate entirely visually, allowing the direct plugging together of Java
Beans. Other builders may enable users to conveniently write Java classes that interact with and
control a set of beans. Other builders may provide a simple scripting language to allow easy
high-level scripting of a set of beans.
Individual Java Beans will vary in the functionality they support, but the typical unifying fea-
tures that distinguish a Java Bean are:
•  Support for "introspection" so that a builder tool can analyze how a bean works
•  Support for "customization" so that when using an application builder a user can
   customize the appearance and behaviour of a bean.
•  Support for "events"  as a simple communication metaphor than can be used to connectup beans.
•  Support for "properties", both for customization and for programmatic use.
•  Support for persistence, so that a bean can be customized in an application builder and
   then have its customized state saved away and reloaded later.

A bean is not required to inherit from any particular base class or interface. Visible beans must
inherit from java.awt.Component so that they can be added to visual containers, but invisible
beans (see 2.7 below) aren’t required to do this.
Note that while beans are primarily targeted at builder tools they are also entirely usable by hu-
man programmers. All the key APIs such as events, properties, and persistence, have been de-
signed to work well both for human programmers and for builder tools.
Many beans will have a strong visual aspect, in both the application builder and in the final con-
structed application, but while this is common it is not required
</pre>
<p>
なんとなくAWT/SwingのGUI系コンポネント向けの仕様ですね。
</p>

<p>
現在はAWT/Swing/JSFなどMVCアーキテクチャのモデルとして利用することが多いいでしょう。
</p>

<ul class="org-ul">
<li>JSFからJavaBeansの利用例
<pre class="example">
&lt;tr:inputText valueChangeListener="#{myBean.valueChangeHandler}" value="#{myBean.value}"/&gt;
</pre>
</li>

<li>Swing/AWT
<ul class="org-ul">
<li>Swing/AWTにJButtonからはじめ多くのGUIコンポネントがJavaBeansの仕様に基づいている。
</li>
<li><a href="http://www.wakhok.ac.jp/~tatsuo/JavaWorld/11th/bean.html">2-2 JavaBeansとしての Swingコンポーネント</a>
</li>
</ul>
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> JavaBeansの出番</h2>
<div class="outline-text-2" id="text-3">
<ol class="org-ol">
<li>JavaBeansのインスタンス化 (constructor)
</li>
<li>JavaBeansプロパティの設定 (setter/getter)
</li>
<li>メソッドの起動 (normal method)
</li>
<li>イベントのイベント・ハンドラの登録
</li>
</ol>

<p>
※Oracle JDeveloperを使うとJavaBeans作成用の専用ウィザードが提供されている
</p>

<p>
4がピンとこないですね。下記の例で理解できると思います。
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #ffffff;">public</span> <span style="color: #ffffff;">class</span> <span style="color: #7fffd4;">MyBean</span> {

     <span style="color: #ffffff;">private</span> <span style="color: #ffffff;">final</span> <span style="color: #7fffd4;">PropertyChangeSupport</span> <span style="color: #9acd32;">pcs</span> = <span style="color: #ffffff;">new</span> <span style="color: #7fffd4;">PropertyChangeSupport</span>(<span style="color: #ffffff;">this</span>);

     <span style="color: #ffffff;">public</span> <span style="color: #7fffd4;">void</span> <span style="color: #98fb98;">addPropertyChangeListener</span>(<span style="color: #7fffd4;">PropertyChangeListener</span> <span style="color: #9acd32;">listener</span>) {
         <span style="color: #ffffff;">this</span>.pcs.addPropertyChangeListener(listener);
     }

     <span style="color: #ffffff;">public</span> <span style="color: #7fffd4;">void</span> <span style="color: #98fb98;">removePropertyChangeListener</span>(<span style="color: #7fffd4;">PropertyChangeListener</span> <span style="color: #9acd32;">listener</span>) {
         <span style="color: #ffffff;">this</span>.pcs.removePropertyChangeListener(listener);
     }

     <span style="color: #ffffff;">private</span> <span style="color: #7fffd4;">String</span> <span style="color: #9acd32;">value</span>;

     <span style="color: #ffffff;">public</span> <span style="color: #7fffd4;">String</span> <span style="color: #98fb98;">getValue</span>() {
         <span style="color: #ffffff;">return</span> <span style="color: #ffffff;">this</span>.value;
     }

     <span style="color: #ffffff;">public</span> <span style="color: #7fffd4;">void</span> <span style="color: #98fb98;">setValue</span>(<span style="color: #7fffd4;">String</span> <span style="color: #9acd32;">newValue</span>) {
         <span style="color: #7fffd4;">String</span> <span style="color: #9acd32;">oldValue</span> = <span style="color: #ffffff;">this</span>.value;
         <span style="color: #ffffff;">this</span>.value = newValue;
         <span style="color: #ffffff;">this</span>.pcs.firePropertyChange(<span style="color: #bdb76b;">"value"</span>, oldValue, newValue);
     }
}

<span style="color: #ffffff;">public</span> <span style="color: #ffffff;">class</span> <span style="color: #7fffd4;">MyBeanTest</span> {
    <span style="color: #ffffff;">static</span> <span style="color: #ffffff;">class</span> <span style="color: #7fffd4;">MyBeanPropertyListener</span> <span style="color: #ffffff;">implements</span> <span style="color: #7fffd4;">PropertyChangeListener</span> {

        <span style="color: #40e0d0;">@Override</span>
        <span style="color: #ffffff;">public</span> <span style="color: #7fffd4;">void</span> <span style="color: #98fb98;">propertyChange</span>(<span style="color: #7fffd4;">PropertyChangeEvent</span> <span style="color: #9acd32;">evt</span>) {
            System.out.println(<span style="color: #bdb76b;">"evt.getPropertyName() = "</span> +  evt.getPropertyName());
            System.out.println(<span style="color: #bdb76b;">"evt.getSource()       = "</span> + evt.getSource());
            System.out.println(<span style="color: #bdb76b;">"evt.getOldValue()     = "</span> + evt.getOldValue());
            System.out.println(<span style="color: #bdb76b;">"evt.getNewValue()     = "</span> + evt.getNewValue());
        }
    }
    <span style="color: #ffffff;">public</span> <span style="color: #ffffff;">static</span> <span style="color: #7fffd4;">void</span> <span style="color: #98fb98;">main</span>(<span style="color: #7fffd4;">String</span>[] <span style="color: #9acd32;">args</span>) {
        <span style="color: #7fffd4;">MyBean</span> <span style="color: #9acd32;">myBean</span> = <span style="color: #ffffff;">new</span> <span style="color: #7fffd4;">MyBean</span>();
        myBean.addPropertyChangeListener(<span style="color: #ffffff;">new</span> <span style="color: #7fffd4;">MyBeanPropertyListener</span>());
        myBean.setValue(<span style="color: #bdb76b;">"hello"</span>);
    }
}
</pre>
</div>

<p>
<code>MyBean</code> のvalue属性変更時にPropertyChangeEventを発火させ、MyBeanPropertyListenerでイ
ベントをハンドリングする。Web開発用MVCフレームワークでもよく利用されている。
</p>
</div>
</div>




<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> APIパッケージの概要</h2>
<div class="outline-text-2" id="text-4">
<p>
<a href="http://docs.oracle.com/javase/jp/7/api/java/beans/package-summary.html">JavaDoc</a> より
</p>
<pre class="example">
パッケージ java.beans の説明
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
JavaBeans™ アーキテクチャーに基づいたコンポーネントである Bean の開発に関連したクラス
が含まれています。一部のクラスは、アプリケーションの実行中に Bean によって使用されま
す。たとえば、イベントクラスは、プロパティーと拒否可能な変更イベントをトリガーする
Bean によって使用されます (PropertyChangeEvent を参照)。しかし、このパッケージに含ま
れるほとんどのクラスは、Bean エディタ (アプリケーションを作成するために Bean のカスタ
マイズおよび組み合わせを行う開発環境) 用です。こうしたクラスを使用すれば、Bean エディ
タで Bean のカスタマイズ用ユーザーインタフェースを簡単に作成できます。たとえば、Bean
エディタでは処理できない特殊な型のプロパティーを持つ Bean があるとします。この場合、
Bean 開発者は PropertyEditor インタフェースを使って、この特殊な型のエディタを提供でき
ます。

Bean による消費リソースを最小限に抑えるため、Bean エディタによって使用されるクラスが
読み込まれるのは、Bean の編集時だけとなります。アプリケーションで Bean が実行されてい
るときは必要ないため、読み込まれません。この情報は、Bean 情報 (BeanInfo を参照) に保
管されます。

明示しない限り、null 値または空の文字列は、このパッケージのメソッドで有効なパラメータ
ではありません。そのようなパラメータが使用されると、例外が発生する可能性があります。
</pre>

<p>
イマイチですね、わかりづらい
</p>
</div>
</div>




<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> よく出てくるクラス</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>java.beans.PropertyDescriptor
<div class="org-src-container">

<pre class="src src-java"><span style="color: #7fffd4;">PropertyDescriptor</span> <span style="color: #9acd32;">nameProp</span> = <span style="color: #ffffff;">new</span> <span style="color: #7fffd4;">PropertyDescriptor</span>(<span style="color: #bdb76b;">"value"</span>, MyBean.<span style="color: #ffffff;">class</span>);
System.out.println(nameProp.getReadMethod().invoke(myBean));
System.out.println(nameProp.getWriteMethod().invoke(myBean, <span style="color: #bdb76b;">"goodbye"</span>));
System.out.println(nameProp.getReadMethod().invoke(myBean));
</pre>
</div>
</li>
<li>java.beans.PropertyChangeListener
PropertyChange イベントは、Bean が「バウンド」プロパティーを変更するたびにトリガーされます。
</li>
<li>java.beans.PropertyChangeEvent
Bean が「バウンド」プロパティーまたは「制約」プロパティーを変更するたびに送信されます。
</li>

<li>PropertyChangeSupport
バウンドプロパティーをサポートする Bean で使用できるユーティリティークラスです。
PropertyChangeSupport インスタンスはスレッドセーフです。このクラスは直列化可能です。
直列化した場合、直列化可能なリスナーが保存および復元されます。直列化の際、直列化可能
でないリスナーはスキップされます。
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> サードパーティライブラリ</h2>
<div class="outline-text-2" id="text-6">
<ul class="org-ul">
<li><a href="http://commons.apache.org/proper/commons-beanutils/">Apache Commons BeanUtils</a>
</li>
</ul>
</div>
</div>


<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> 参考情報</h2>
<div class="outline-text-2" id="text-7">
<ul class="org-ul">
<li><a href="http://java.sun.com/docs/books/tutorial/javabeans/">『Java Tutorial』の続編</a>
</li>
<li><a href="http://docstore.mik.ua/orelly/java-ent/jnut/ch06_01.htm">Java™ in a Nutshell: A Deskop Quick Referenceの6章</a>
</li>
<li><a href="http://otndnld.oracle.co.jp/tech/java/htdocs/java_roadmap/javabean/listing.htm">Oracle Javaロードマップ:JavaBeans</a>
</li>
</ul>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[調査]URLパラメータデコード処理について]]></title>
    <link href="http://luozengbin.github.io/blog/2015-05-14-%5B%E8%AA%BF%E6%9F%BB%5Durl%E3%83%91%E3%83%A9%E3%83%A1%E3%83%BC%E3%82%BF%E3%83%87%E3%82%B3%E3%83%BC%E3%83%89%E5%87%A6%E7%90%86%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6.html"/>
    <updated>2015-05-14T00:00:00+09:00</updated>
    <id>http://luozengbin.github.io/blog/[調査]urlパラメータデコード処理について</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. URLパラメータのエンコーディング仕様</a></li>
<li><a href="#sec-2">2. 文字化けの原因</a></li>
<li><a href="#sec-3">3. Tomcat7の実装</a>
<ul>
<li><a href="#sec-3-1">3.1. URIEncoding属性値</a></li>
<li><a href="#sec-3-2">3.2. useBodyEncodingForURI属性値</a></li>
<li><a href="#sec-3-3">3.3. 設定と挙動のまとめ</a></li>
</ul>
</li>
<li><a href="#sec-4">4. Weblogic 11gの設定</a>
<ul>
<li><a href="#sec-4-1">4.1. 起動パラメータで指定する</a></li>
<li><a href="#sec-4-2">4.2. weblogic.xmlにて指定する</a></li>
<li><a href="#sec-4-3">4.3. ServletRequest.setCharacterEncoding(String env) APIで指定する</a></li>
<li><a href="#sec-4-4">4.4. ADFフレームワーク利用時の注意事項</a></li>
</ul>
</li>
<li><a href="#sec-5">5. 参考</a></li>
</ul>
</div>
</div>


<p>
URLパラメータの日本語文字が化けたので、APサーバのURLパラメータデコード処理について
調べました。
</p>




<p>
<!-- more -->
</p>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> URLパラメータのエンコーディング仕様</h2>
<div class="outline-text-2" id="text-1">
<p>
HTTPプロトコルのGETメソッドで通信する場合、URLパラメータをエンコーディングしなければ
いけません。その仕様は <a href="http://tools.ietf.org/html/rfc3986#section-2.1">rfc3986:Uniform Resource Identifier (URI): Generic Syntax</a> にて
定義されている。
</p>

<p>
例えばブラウザに下記URLを入力して送信する。
</p>
<pre class="example">
http://www.yahoo.co.jp/?param1=あきら
</pre>

<p>
パケットレベルで実際に送信された内容を確認するとURLに日本語パラメータ部分が<a href="http://ja.wikipedia.org/wiki/%25E3%2583%2591%25E3%2583%25BC%25E3%2582%25BB%25E3%2583%25B3%25E3%2583%2588%25E3%2582%25A8%25E3%2583%25B3%25E3%2582%25B3%25E3%2583%25BC%25E3%2583%2587%25E3%2582%25A3%25E3%2583%25B3%25E3%2582%25B0">パーセン
トエンコーディング</a>されていることが分かります。
</p>

<pre class="example">
GET http://www.yahoo.co.jp/?param1=%E3%81%82%E3%81%8D%E3%82%89 HTTP/1.1
Host: www.yahoo.co.jp
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:38.0) Gecko/20100101 Firefox/38.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: ja,en-US;q=0.7,en;q=0.3
Accept-Encoding: gzip, deflate
</pre>

<p>
<code>param1=あきら</code> にマルチバイト部分が下記のイメージでエンコードされる。
</p>
<pre class="example">
+-------------------+-------------------+-------------------+
|       あ          |         き        |         ら        |
+-----+------+------+-----+------+------+-----+------+------+
| -29 | -127 | -126 | -29 | -127 | -155 | -29 | -126 | -119 | ← ステップ1
+-----+------+------+-----+------+------+-----+------+------+
| 0xe3| 0x81 | 0x82 | 0xe3| 0x81 | 0x8d | 0xe3| 0x82 | 0x89 | ← ステップ2
+-----+------+------+-----+------+------+-----+------+------+
| %E3 | %81  | %82  | %E3 | %81  | %8D  | %E3 | %82  | %89  | ← ステップ3
+-----+------+------+-----+------+------+-----+------+------+
</pre>
<p>
<code>表1</code>
</p>

<ul class="org-ul">
<li>ステップ1: &#8220;あきら&#8221;文字列をUTF-8符号化バイト表現に変換する
</li>
<li>ステップ2: 16進数に見直す。1オクテットは、2桁の十六進表記で表現することができる。
</li>
<li>ステップ3: 2桁の十六進表現を大文字にして、先頭に&#8221;%&#8221;を追加する
</li>
</ul>

<p>
ステップ1の文字コード(UTF-8)はブラウザの実装／設定に依存する。一般にUTF-8を採用するこ
とが多いい。
</p>

<p>
Javaに下記URLエンコード／デコード用の標準APIが用意されている。
</p>
<ul class="org-ul">
<li><a href="https://docs.oracle.com/javase/jp/6/api/java/net/URLEncoder.html#encode%2528java.lang.String,%2520java.lang.String%2529">java.net.URLEncoder.encode(String s, String enc)</a>
</li>
<li><a href="https://docs.oracle.com/javase/jp/6/api/java/net/URLDecoder.html">java.net.URLDecoder.decode(String s, String enc)</a>
</li>
</ul>

<p>
<code>表1</code> にエンコードの流れについて下記サンプルプログラムで確認することができる。
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ffffff;">import</span> <span style="color: #40e0d0;">java</span>.<span style="color: #40e0d0;">io</span>.<span style="color: #7fffd4;">UnsupportedEncodingException</span>;
<span style="color: #ffffff;">import</span> <span style="color: #40e0d0;">java</span>.<span style="color: #40e0d0;">net</span>.<span style="color: #7fffd4;">URLEncoder</span>;

<span style="color: #ffffff;">public</span> <span style="color: #ffffff;">class</span> <span style="color: #7fffd4;">URLEncoderTest</span> {
    <span style="color: #ffffff;">public</span> <span style="color: #ffffff;">static</span> <span style="color: #7fffd4;">void</span> <span style="color: #98fb98;">main</span>(<span style="color: #7fffd4;">String</span>[] <span style="color: #9acd32;">args</span>) <span style="color: #ffffff;">throws</span> <span style="color: #7fffd4;">UnsupportedEncodingException</span> {

        System.out.println(URLEncoder1.encode(<span style="color: #bdb76b;">"&#12354;&#12365;&#12425;"</span>, <span style="color: #bdb76b;">"UTF-8"</span>));

        <span style="color: #00cd66;">// </span><span style="color: #00cd66;">UTF-8&#12496;&#12452;&#12488;&#34920;&#29694;&#12434;&#20986;&#21147;&#12377;&#12427;</span>
        <span style="color: #7fffd4;">byte</span>[] <span style="color: #9acd32;">bs</span> = <span style="color: #bdb76b;">"&#12354;&#12365;&#12425;"</span>.getBytes(<span style="color: #bdb76b;">"UTF-8"</span>);
        <span style="color: #ffffff;">for</span> (<span style="color: #7fffd4;">byte</span> <span style="color: #9acd32;">b</span> : bs) {
            System.out.print(b);
            System.out.print(<span style="color: #bdb76b;">" | "</span>);
        }
        System.out.print(<span style="color: #bdb76b;">"\n"</span>);

        <span style="color: #00cd66;">// </span><span style="color: #00cd66;">16&#36914;&#25968;&#34920;&#29694;&#12434;&#20986;&#21147;&#12377;&#12427;</span>
        <span style="color: #ffffff;">for</span> (<span style="color: #7fffd4;">byte</span> <span style="color: #9acd32;">b</span> : bs) {
            System.out.println(Integer.toHexString(b));
        }
    }
}
</pre>
</div>

<p>
出力結果
</p>
<pre class="example">
%E3%81%82%E3%81%8D%E3%82%89
-29 | -127 | -126 | -29 | -127 | -115 | -29 | -126 | -119 |
ffffffe3
ffffff81
ffffff82
ffffffe3
ffffff81
ffffff8d
ffffffe3
ffffff82
ffffff89
</pre>
</div>
</div>




<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 文字化けの原因</h2>
<div class="outline-text-2" id="text-2">
<p>
HTTPリクエストを受ける側(Web/APサーバ)、上記 <code>表1</code> と逆順でURLパラメータをデコードし
なければいけません。URLパラメータのデコード処理はAPサーバを隠蔽してくれるので業務AP側
あんまり意識しないかもしれないですが。ステップ1でクライアントとAPサーバが異なる文字
コードを使用すると文字化けが起こりえるので要注意です。
</p>

<p>
URLパラメータの文字コードについて、クライアントとAPサーバ間のネゴシエーション仕様は
HTTPプロトコル上明確に定義されていないため、ベンダによって実装が変わる。主に以下のよ
うな処理パターンが存在するでしょう。
</p>

<ol class="org-ol">
<li>HTTPヘッダにContent-Type値に基づく、URLパラメータの文字コードを決める
</li>
<li>APサーバの設定パラメータに基づく、URLパラメータの文字コードを決める
</li>
<li><a href="http://docs.oracle.com/javaee/6/api/javax/servlet/ServletRequest.html#setCharacterEncoding%2528java.lang.String%2529">javax.servlet.ServletRequest.setCharacterEncoding(String env)</a> APIで設定された値に
基づく、URLパラメータの文字コードを決める
</li>
</ol>

<p>
HTTPヘッダのContent-Type値はPOSTリクエストにHTTPボディ部分の文字コードを示す項目です
が、GETリクエストにContent-Type値を含めることは稀に見ないでしょう。
</p>
</div>
</div>




<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Tomcat7の実装</h2>
<div class="outline-text-2" id="text-3">
<p>
環境: apache-tomcat-7.0.47
</p>

<p>
検証用サンプルプログラム <code>profiler.MainServlet.java</code>
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ffffff;">package</span> <span style="color: #40e0d0;">profiler</span>;

<span style="color: #ffffff;">import</span> <span style="color: #40e0d0;">java</span>.<span style="color: #40e0d0;">io</span>.<span style="color: #7fffd4;">IOException</span>;

<span style="color: #ffffff;">import</span> <span style="color: #40e0d0;">javax</span>.<span style="color: #40e0d0;">servlet</span>.<span style="color: #7fffd4;">ServletException</span>;
<span style="color: #ffffff;">import</span> <span style="color: #40e0d0;">javax</span>.<span style="color: #40e0d0;">servlet</span>.<span style="color: #40e0d0;">annotation</span>.<span style="color: #7fffd4;">WebServlet</span>;
<span style="color: #ffffff;">import</span> <span style="color: #40e0d0;">javax</span>.<span style="color: #40e0d0;">servlet</span>.<span style="color: #40e0d0;">http</span>.<span style="color: #7fffd4;">HttpServlet</span>;
<span style="color: #ffffff;">import</span> <span style="color: #40e0d0;">javax</span>.<span style="color: #40e0d0;">servlet</span>.<span style="color: #40e0d0;">http</span>.<span style="color: #7fffd4;">HttpServletRequest</span>;
<span style="color: #ffffff;">import</span> <span style="color: #40e0d0;">javax</span>.<span style="color: #40e0d0;">servlet</span>.<span style="color: #40e0d0;">http</span>.<span style="color: #7fffd4;">HttpServletResponse</span>;

<span style="color: #bdb76b;">/**</span>
<span style="color: #bdb76b;"> * Servlet implementation class MainServlet</span>
<span style="color: #bdb76b;"> */</span>
<span style="color: #40e0d0;">@WebServlet</span>(<span style="color: #bdb76b;">"/MainServlet"</span>)
<span style="color: #ffffff;">public</span> <span style="color: #ffffff;">class</span> <span style="color: #7fffd4;">MainServlet</span> <span style="color: #ffffff;">extends</span> <span style="color: #7fffd4;">HttpServlet</span> {
    <span style="color: #ffffff;">private</span> <span style="color: #ffffff;">static</span> <span style="color: #ffffff;">final</span> <span style="color: #7fffd4;">long</span> <span style="color: #9acd32;">serialVersionUID</span> = 1L;

    <span style="color: #ffffff;">public</span> <span style="color: #98fb98;">MainServlet</span>() {
        <span style="color: #ffffff;">super</span>();
    }

    <span style="color: #ffffff;">protected</span> <span style="color: #7fffd4;">void</span> <span style="color: #98fb98;">doGet</span>(<span style="color: #7fffd4;">HttpServletRequest</span> <span style="color: #9acd32;">request</span>, <span style="color: #7fffd4;">HttpServletResponse</span> <span style="color: #9acd32;">response</span>) <span style="color: #ffffff;">throws</span> <span style="color: #7fffd4;">ServletException</span>, <span style="color: #7fffd4;">IOException</span> {
      <span style="color: #00cd66;">// </span><span style="color: #00cd66;">URL&#12497;&#12521;&#12513;&#12540;&#12479;&#12434;&#20986;&#21147;&#12377;&#12427;</span>
        System.out.println(request.getParameter(<span style="color: #bdb76b;">"param1"</span>));
    }

    <span style="color: #ffffff;">protected</span> <span style="color: #7fffd4;">void</span> <span style="color: #98fb98;">doPost</span>(<span style="color: #7fffd4;">HttpServletRequest</span> <span style="color: #9acd32;">request</span>, <span style="color: #7fffd4;">HttpServletResponse</span> <span style="color: #9acd32;">response</span>) <span style="color: #ffffff;">throws</span> <span style="color: #7fffd4;">ServletException</span>, <span style="color: #7fffd4;">IOException</span> {
    }
}
</pre>
</div>

<p>
Debugモードで上記サンプルをトレースしてみると、URLパラメータデコード処理時の実行スタッ
クは以下となります。
</p>
<pre class="example">
at org.apache.tomcat.util.buf.UDecoder.convert(UDecoder.java:100)
at org.apache.tomcat.util.http.Parameters.urlDecode(Parameters.java:489)
at org.apache.tomcat.util.http.Parameters.processParameters(Parameters.java:396)
at org.apache.tomcat.util.http.Parameters.processParameters(Parameters.java:501)
at org.apache.tomcat.util.http.Parameters.handleQueryParameters(Parameters.java:194)
at org.apache.catalina.connector.Request.parseParameters(Request.java:3059)
at org.apache.catalina.connector.Request.getParameter(Request.java:1151)
at org.apache.catalina.connector.RequestFacade.getParameter(RequestFacade.java:384)
at profiler.MainServlet.doGet(MainServlet.java:32)
</pre>

<p>
実行スタックから見ると <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/ServletRequest.html#getParameter%2528java.lang.String%2529">javax.servlet.ServletRequest.getParameter(String name)</a> が初回
呼ばれた時に次のJavaクラスが実行され、URLパラメータのデコード処理が行われることが分か
ります。
</p>

<ul class="org-ul">
<li><a href="https://github.com/apache/tomcat70/blob/trunk/java/org/apache/catalina/connector/Request.java">org.apache.catalina.connector.Request.java</a>
</li>
<li><a href="https://github.com/apache/tomcat70/blob/trunk/java/org/apache/tomcat/util/http/Parameters.java">org.apache.tomcat.util.http.Parameters.java</a>
</li>
</ul>

<p>
※記述が冗長のため、以降はRequestとParametersで記述する。
</p>

<p>
以下はParameters.javaにURLパラメータの文字コード決める部分の抜粋です。
</p>
<div class="org-src-container">

<pre class="src src-java"> 1 |<span style="color: #ffffff;">package</span> org.apache.tomcat.util.<span style="color: #40e0d0;">http</span>;
 2 |(<span style="color: #7fffd4;">&#20013;&#30053;</span>)
 3 |<span style="color: #ffffff;">public</span> <span style="color: #ffffff;">final</span> <span style="color: #ffffff;">class</span> Parameters {
 4 | 
 5 |    (<span style="color: #7fffd4;">&#20013;&#30053;</span>)
 6 | 
 7 |    <span style="color: #ffffff;">public</span> <span style="color: #7fffd4;">void</span> handleQueryParameters() {
 8 |        (<span style="color: #7fffd4;">&#20013;&#30053;</span>) 14&#34892;&#30446;&#12434;&#21628;&#12403;&#20986;&#12375;
 9 |        processParameters( decodedQuery, queryStringEncoding );
10 |    }
11 | 
12 |    (<span style="color: #7fffd4;">&#20013;&#30053;</span>)
13 | 
14 |    <span style="color: #ffffff;">public</span> <span style="color: #7fffd4;">void</span> processParameters( <span style="color: #7fffd4;">MessageBytes</span> <span style="color: #9acd32;">data</span>, <span style="color: #7fffd4;">String</span> <span style="color: #9acd32;">encoding</span> ) {
15 |        (<span style="color: #7fffd4;">&#20013;&#30053;</span>) 22&#34892;&#30446;&#12434;&#21628;&#12403;&#20986;&#12375;&#12390;&#12363;&#12425;34&#34892;&#30446;&#12434;&#23455;&#34892;&#12377;&#12427;
16 |        processParameters( bc.getBytes(), bc.getOffset(),
17 |                           bc.getLength(), getCharset(encoding));
18 |    }
19 | 
20 |    (<span style="color: #7fffd4;">&#20013;&#30053;</span>)
21 | 
22 |    <span style="color: #ffffff;">private</span> Charset getCharset(<span style="color: #7fffd4;">String</span> <span style="color: #9acd32;">encoding</span>) {
23 |        <span style="color: #ffffff;">if</span> (encoding == <span style="color: #40e0d0;">null</span>) {
24 |            <span style="color: #ffffff;">return</span> DEFAULT_CHARSET;  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">ISO-8859-1</span>
25 |        }
26 |        <span style="color: #ffffff;">try</span> {
27 |            <span style="color: #ffffff;">return</span> B2CConverter.getCharset(encoding);
28 |        } <span style="color: #ffffff;">catch</span> (<span style="color: #7fffd4;">UnsupportedEncodingException</span> <span style="color: #9acd32;">e</span>) {
29 |            <span style="color: #ffffff;">return</span> DEFAULT_CHARSET;
30 |        }
31 |    }
32 | 
33 |    (<span style="color: #7fffd4;">&#20013;&#30053;</span>)
34 |    <span style="color: #ffffff;">private</span> <span style="color: #7fffd4;">void</span> processParameters(<span style="color: #7fffd4;">byte</span> <span style="color: #9acd32;">bytes</span>[], <span style="color: #7fffd4;">int</span> <span style="color: #9acd32;">start</span>, <span style="color: #7fffd4;">int</span> <span style="color: #9acd32;">len</span>,
35 |                                  Charset charset) {
36 | 
37 |        <span style="color: #ffffff;">if</span>(log.isDebugEnabled()) {
38 |            log.debug(sm.getString(<span style="color: #bdb76b;">"parameters.bytes"</span>,
39 |                    <span style="color: #ffffff;">new</span> <span style="color: #7fffd4;">String</span>(bytes, start, len, DEFAULT_CHARSET)));
40 |        }
41 | 
42 |        (<span style="color: #7fffd4;">&#20013;&#30053;</span>)
43 |                String name;
44 |                String value;
45 | 
46 |                <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733;1 &#12497;&#12521;&#12513;&#12540;&#12479;&#21517;&#12398;&#12487;&#12467;&#12540;&#12489;</span>
47 | 
48 |                <span style="color: #ffffff;">if</span> (decodeName) {
49 |                    urlDecode(tmpName);
50 |                }
51 | 
52 |                tmpName.setCharset(charset);
53 |                name = tmpName.toString();
54 | 
55 |                <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733;2 &#12497;&#12521;&#12513;&#12540;&#12479;&#20516;&#12398;&#12487;&#12467;&#12540;&#12489;</span>
56 | 
57 |                <span style="color: #ffffff;">if</span> (valueStart &gt;= 0) {
58 |                    <span style="color: #ffffff;">if</span> (decodeValue) {
59 |                        urlDecode(tmpValue);
60 |                    }
61 | 
62 |                    tmpValue.setCharset(charset);
63 |                    value = tmpValue.toString();
64 |                } <span style="color: #ffffff;">else</span> {
65 |                    value = <span style="color: #bdb76b;">""</span>;
66 |                }
67 | 
68 |        (<span style="color: #7fffd4;">&#20013;&#30053;</span>)
69 |    }
70 |}
</pre>
</div>

<p>
<code>62</code> 行目でURLパラメータ値パーセントデコード後バイト表現の文字コードを指定しています。
ここのcharset値は次のメカニズムで決められる。
</p>

<p>
Parameters.javaのqueryStringEncodingフィールド値が設定された場合その値が適用される。
そうでない場合、デフォルト値 <code>ISO-8859-1</code> が適用される。
</p>

<p>
Tomcat7にqueryStringEncodingフィールドの値を設定しているところは以下4箇所です。
</p>
<pre class="example">
1| org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:386)
2| org.apache.catalina.connector.Request.parseParameters(Request.java:3048)
3| org.apache.catalina.connector.Request.parseParameters(Request.java:3054)
4| org.apache.catalina.authenticator.FormAuthenticator.restoreRequest(FormAuthenticator.jaba:586)
</pre>

<ol class="org-ol">
<li>HTTPリクエスト受けった時に Request オブジェクトを初期化するところで
<code>conf/server.xml</code> にConnectorのURIEncoding属性値をRequestオブジェクトの
queryStringEncodingに設定する。実行時スタックは下記の通りです。
<pre class="example">
"http-bio-8080-exec-1" - Thread t@23
   java.lang.Thread.State: RUNNABLE
    at org.apache.tomcat.util.http.Parameters.setQueryStringEncoding(Parameters.java:98)
    at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:386)
    at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1041)
    at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:603)
    at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:310)
    - locked &lt;63f701a0&gt; (a org.apache.tomcat.util.net.SocketWrapper)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
</pre>
</li>

<li>ServletRequest.getParameter(String name)初回実行時にURLパラメータの解析処理、以下
は中身の詳細です。
<div class="org-src-container">

<pre class="src src-java"> 1 |<span style="color: #ffffff;">package</span> org.apache.catalina.<span style="color: #40e0d0;">connector</span>;
 2 |(<span style="color: #7fffd4;">&#20013;&#30053;</span>)
 3 |<span style="color: #ffffff;">public</span> <span style="color: #ffffff;">class</span> Request
 4 |     <span style="color: #ffffff;">implements</span> <span style="color: #7fffd4;">HttpServletRequest</span> {
 5 | 
 6 |     (<span style="color: #7fffd4;">&#20013;&#30053;</span>)
 7 | 
 8 |     <span style="color: #bdb76b;">/**</span>
<span style="color: #bdb76b;"> 9 |      * Parse request parameters.</span>
<span style="color: #bdb76b;">10 |      */</span>
11 |     <span style="color: #ffffff;">protected</span> <span style="color: #7fffd4;">void</span> parseParameters() {
12 | 
13 |       parametersParsed = <span style="color: #40e0d0;">true</span>;
14 | 
15 |       Parameters parameters = coyoteRequest.getParameters();
16 |       <span style="color: #7fffd4;">boolean</span> success = <span style="color: #40e0d0;">false</span>;
17 |       <span style="color: #ffffff;">try</span> {
18 |           <span style="color: #00cd66;">// </span><span style="color: #00cd66;">Set this every time in case limit has been changed via JMX</span>
19 |           parameters.setLimit(getConnector().getMaxParameterCount());
20 | 
21 |           <span style="color: #00cd66;">// </span><span style="color: #00cd66;">getCharacterEncoding() may have been overridden to search for</span>
22 |           <span style="color: #00cd66;">// </span><span style="color: #00cd66;">hidden form field containing request encoding</span>
23 | 
24 |           <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733;1</span>
25 |           <span style="color: #00cd66;">// </span><span style="color: #00cd66;">org.apache.coyote.Request.java&#12398;charEncoding&#12501;&#12451;&#12540;&#12523;&#12489;&#20516;&#12289;</span>
26 |           <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#12418;&#12375;&#12367;&#12399;HTTP&#12504;&#12483;&#12480;&#12398;Content-Type&#20516;&#12363;&#12425;&#25991;&#23383;&#12467;&#12540;&#12489;&#24773;&#22577;&#12398;&#21462;&#24471;</span>
27 |           String enc = getCharacterEncoding();
28 | 
29 |           <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733;2</span>
30 |           <span style="color: #00cd66;">// </span><span style="color: #00cd66;">server.xml&#12395;Connector&#12398;useBodyEncodingForURI&#23646;&#24615;&#20516;&#12398;&#21462;&#24471;</span>
31 |           <span style="color: #7fffd4;">boolean</span> useBodyEncodingForURI = connector.getUseBodyEncodingForURI();
32 | 
33 | 
34 |           <span style="color: #ffffff;">if</span> (enc != <span style="color: #40e0d0;">null</span>) {
35 |               <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733;3</span>
36 |               <span style="color: #00cd66;">// </span><span style="color: #00cd66;">HTTP&#12504;&#12483;&#12480;&#12398;Content-Type&#20516;&#12364;&#25351;&#23450;&#12373;&#12428;&#12383;&#22580;&#21512;&#12289;&#36969;&#29992;&#12377;&#12427;</span>
37 |               parameters.setEncoding(enc);
38 |
39 |               <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733;4</span>
40 |               <span style="color: #00cd66;">// </span><span style="color: #00cd66;">useBodyEncodingForURI&#23646;&#24615;&#20516;&#12364;true&#12398;&#22580;&#21512;&#12289;</span>
41 |               <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#12300;&#9733;1&#12301;&#12391;&#21462;&#12428;&#12383;&#20516;&#12434;org.apache.tomcat.util.http.Parameters.java&#12398;</span>
42 |               <span style="color: #00cd66;">// </span><span style="color: #00cd66;">queryStringEncoding&#12501;&#12451;&#12540;&#12523;&#12489;&#12395;&#36969;&#29992;&#12377;&#12427;</span>
43 |               <span style="color: #ffffff;">if</span> (useBodyEncodingForURI) {
44 |                   parameters.setQueryStringEncoding(enc);
45 |               }
46 |           } <span style="color: #ffffff;">else</span> {
47 | 
48 |               <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733;5</span>
49 |               <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#12300;&#9733;1&#12301;&#20516;&#12364;&#21462;&#12428;&#12394;&#12356;&#22580;&#21512;&#12289;&#12487;&#12501;&#12457;&#12523;&#12488;&#20516;(ISO-8859-1)&#12434;&#36969;&#29992;&#12377;&#12427;</span>
50 |
51 |               parameters.setEncoding
52 |                   (<span style="color: #40e0d0;">org</span>.<span style="color: #40e0d0;">apache</span>.<span style="color: #40e0d0;">coyote</span>.<span style="color: #40e0d0;">Constants</span>.DEFAULT_CHARACTER_ENCODING);
53 |               <span style="color: #ffffff;">if</span> (useBodyEncodingForURI) {
54 |                   parameters.setQueryStringEncoding
55 |                       (<span style="color: #40e0d0;">org</span>.<span style="color: #40e0d0;">apache</span>.<span style="color: #40e0d0;">coyote</span>.<span style="color: #40e0d0;">Constants</span>.DEFAULT_CHARACTER_ENCODING);
56 |               }
57 |           }
58 |             <span style="color: #00cd66;">// </span><span style="color: #00cd66;">org.apache.tomcat.util.http.Parameters.java&#12398;&#35299;&#26512;&#20966;&#29702;&#12434;&#12467;&#12540;&#12523;</span>
59 |           parameters.handleQueryParameters();
60 | 
61 |     (&#20013;&#30053;)
</pre>
</div>
<p>
<code>リスト1</code>
</p>

<p>
<code>profiler.MainServlet.java</code> サンプルプログラムに置いて、上記 <code>27</code> 行目実行時のスタッ
クトレースを以下に示す。
</p>

<pre class="example">
"http-bio-8080-exec-1" - Thread t@29
   java.lang.Thread.State: RUNNABLE
    at org.apache.tomcat.util.http.ContentType.getCharsetFromContentType(ContentType.java:41)
    at org.apache.coyote.Request.getCharacterEncoding(Request.java:264)
    at org.apache.catalina.connector.Request.getCharacterEncoding(Request.java:1048)
    at org.apache.catalina.connector.Request.parseParameters(Request.java:3042)
    at org.apache.catalina.connector.Request.getParameter(Request.java:1151)
    at org.apache.catalina.connector.RequestFacade.getParameter(RequestFacade.java:384)
    at profiler.MainServlet.doGet(MainServlet.java:32)
</pre>
</li>

<li>上記2の説明に含まている
</li>

<li>今回の調査範囲外のため、別途&#x2026;
</li>
</ol>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> URIEncoding属性値</h3>
<div class="outline-text-3" id="text-3-1">
<p>
<code>conf/server.xml</code> にConnectorのURIEncoding属性値にてURLパラメータの文字コードのデフォ
ルト値を指定することができる。ほどんどんのブラウザはUTF-8を採用しているため、この値を
<code>UTF-8</code> に見直すべきでしょう。
</p>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> useBodyEncodingForURI属性値</h3>
<div class="outline-text-3" id="text-3-2">
<p>
<code>conf/server.xml</code> にConnectorのuseBodyEncodingForURI属性値がtrueの場合、 <code>リスト1</code> の
<code>44</code> と <code>55</code> 行目が実行され、URLパラメータの文字コードとHTTPボディの文字コードが統一
される。
</p>

<p>
Content-Type HTTPヘッダを含めないGETリクエストの場合 <code>27</code> 行目の値が null のため、URL
パラメータにマルチバイト文字が化けでしょう。
</p>

<p>
ServletRequest.getParameter(String name)を評価する前に
<code>ServletRequest.setCharacterEncoding(String enc)</code> で予め
org.apache.coyote.Request.javaのcharEncodingフィールド値を初期化すれば、文字化け問題
を回避することが出来ます。
</p>

<p>
と言うわけで <code>useBodyEncodingForURI</code> 属性値をtrueに指定する場合、業務APでURLパラメー
タを参照する前に <code>ServletRequest.setCharacterEncoding(String enc)</code> を実行して文字コー
ド明示した方がよいでしょう。
</p>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> 設定と挙動のまとめ</h3>
<div class="outline-text-3" id="text-3-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="right">No</th>
<th scope="col" class="left">URIEncoding</th>
<th scope="col" class="left">useBodyEncodingForURI</th>
<th scope="col" class="left">Content-Type</th>
<th scope="col" class="left">結果</th>
</tr>
</thead>
<tbody>
<tr>
<td class="right">1</td>
<td class="left">-</td>
<td class="left">false</td>
<td class="left">有り／無し</td>
<td class="left">文字化け</td>
</tr>

<tr>
<td class="right">4</td>
<td class="left">UTF-8</td>
<td class="left">false</td>
<td class="left">有り／無し</td>
<td class="left">OK</td>
</tr>

<tr>
<td class="right">3</td>
<td class="left">任意</td>
<td class="left">true</td>
<td class="left">なし</td>
<td class="left">文字化け</td>
</tr>

<tr>
<td class="right">2</td>
<td class="left">任意</td>
<td class="left">true</td>
<td class="left">有り</td>
<td class="left">OK</td>
</tr>
</tbody>
</table>

<p>
Tomcat6の場合、この２つパラメータは次のシステムプロパティとして指定することになります。
</p>
<ul class="org-ul">
<li>org.apache.catalina.connector.URI_ENCODING
</li>
<li>org.apache.catalina.connector.USE_BODY_ENCODING_FOR_QUERY_STRING
</li>
</ul>

<p>
JBossAS7/EAP6もTomcat6と同じ方法です。
</p>
</div>
</div>
</div>




<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Weblogic 11gの設定</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> 起動パラメータで指定する</h3>
<div class="outline-text-3" id="text-4-1">
<p>
<a href="http://otndnld.oracle.co.jp/document/products/wls/docs90/ja/relnotes_ja.html">URL デコードする際の文字エンコーディングを指定する方法</a>
</p>

<pre class="example">
-Dweblogic.http.URIDecodeEncoding=UTF-8
</pre>

<p>
ただし、この設定は1つのサーバインスタンスで1つのみ可能です。
</p>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> weblogic.xmlにて指定する</h3>
<div class="outline-text-3" id="text-4-2">
<p>
<a href="https://docs.oracle.com/middleware/1212/wls/WBAPP/configurejsp.htm#WBAPP187">Mapping IANA Character Sets to Java Character Sets</a>
</p>
<pre class="example">
&lt;input-charset&gt;
  &lt;resource-path&gt;/foo/*&lt;/resource-path&gt;
  &lt;java-charset-name&gt;UTF-8&lt;/java-charset-name&gt;
&lt;/input-charset&gt;
</pre>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> ServletRequest.setCharacterEncoding(String env) APIで指定する</h3>
<div class="outline-text-3" id="text-4-3">
<p>
文字コード制御用のFilterにて実装することが多いい。
</p>
</div>
</div>

<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> ADFフレームワーク利用時の注意事項</h3>
<div class="outline-text-3" id="text-4-4">
<p>
ADFフレームワーク内でHTTP Requestオブジェクトをラッピング時にFilterで指定した文字コー
ド情報をロストしてしまうケースがあります。ADFフレームワーク利用時にJSFフェースリスナー
のRESTORE_VIEWフェーズにて行うのが適切です。
</p>
</div>
</div>
</div>




<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 参考</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li><a href="https://tomcat.apache.org/tomcat-7.0-doc/config/http.html">Apache Tomcat 7 - The HTTP Connector</a>
</li>
<li><a href="http://tools.ietf.org/html/rfc3986#section-2">rfc3986#section-2</a>
</li>
<li><a href="http://ja.wikipedia.org/wiki/%25E3%2583%2591%25E3%2583%25BC%25E3%2582%25BB%25E3%2583%25B3%25E3%2583%2588%25E3%2582%25A8%25E3%2583%25B3%25E3%2582%25B3%25E3%2583%25BC%25E3%2583%2587%25E3%2582%25A3%25E3%2583%25B3%25E3%2582%25B0">パーセントエンコーディング</a>
</li>
</ul>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[メモ]デバッグ版OpenJDKのビルド]]></title>
    <link href="http://luozengbin.github.io/blog/2015-05-10-%5B%E3%83%A1%E3%83%A2%5D%E3%83%87%E3%83%90%E3%83%83%E3%82%B0%E7%89%88openjdk%E3%81%AE%E3%83%93%E3%83%AB%E3%83%89.html"/>
    <updated>2015-05-10T00:00:00+09:00</updated>
    <id>http://luozengbin.github.io/blog/[メモ]デバッグ版openjdkのビルド</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 環境</a></li>
<li><a href="#sec-2">2. ビルド手順</a></li>
<li><a href="#sec-3">3. gdbでデバッグしてみる</a></li>
<li><a href="#sec-4">4. valgrindでコールグラフ出してみる</a></li>
<li><a href="#sec-5">5. 参考</a></li>
</ul>
</div>
</div>


<p>
今まで、JVM中身の調査は <code>SystemTap + java-1.x.x-openjdk-debuginfo.x86_64</code> 利用してい
たが。もう少しJVMの中身を踏み込みたいのでデバッグ版JVMをビルドしてみました。
</p>




<p>
<a href="http://hg.openjdk.java.net/jdk7/jdk7/raw-file/tip/README-builds.html">http://hg.openjdk.java.net/jdk7/jdk7/raw-file/tip/README-builds.html</a> の手順でビルドし
てもいいのですが、トライ・アンド・エラーで時間が取られそうなので、自分が使っている
<code>Arch Linux</code> 環境で一番手取りの早い手順で行いました。
</p>




<p>
<!-- more -->
</p>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 環境</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>Arch Linux
</li>
<li>OpenJDK 7系
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> ビルド手順</h2>
<div class="outline-text-2" id="text-2">
<p>
まずはパッケージリポジトリから <a href="https://www.archlinux.org/packages/extra/x86_64/jdk7-openjdk/">jdk7-openjdk</a> のビルドファイルやパッチファイルを入手する。
</p>
<ul class="org-ul">
<li><a href="https://projects.archlinux.org/svntogit/packages.git/tree/trunk?h=packages/java7-openjdk">入手先</a>
</li>
</ul>
<pre class="example">
★ダウンロード
$ wget https://projects.archlinux.org/svntogit/packages.git/plain/trunk/PKGBUILD?h=packages/java7-openjdk -O PKGBUILD
$ wget https://projects.archlinux.org/svntogit/packages.git/plain/trunk/fontconfig-paths.diff?h=packages/java7-openjdk -O fontconfig-paths.diff
$ wget https://projects.archlinux.org/svntogit/packages.git/plain/trunk/jdk7-openjdk.install?h=packages/java7-openjdk -O jdk7-openjdk.install
$ wget https://projects.archlinux.org/svntogit/packages.git/plain/trunk/jre7-openjdk-headless.install?h=packages/java7-openjdk -O jre7-openjdk-headless.install
$ wget https://projects.archlinux.org/svntogit/packages.git/plain/trunk/jre7-openjdk.install?h=packages/java7-openjdk -O jre7-openjdk.install
$ wget https://projects.archlinux.org/svntogit/packages.git/plain/trunk/openjdk7_nonreparenting-wm.diff?h=packages/java7-openjdk -O openjdk7_nonreparenting-wm.diff
★ファイル一覧確認
$ ls -al
合計 52
drwxr-xr-x  2 akira users  4096  5月 10 11:24 .
drwxr-xr-x 21 akira users  4096  5月 10 11:23 ..
-rw-r--r--  1 akira users 12429  5月 10 11:24 PKGBUILD
-rw-r--r--  1 akira users  8302  5月 10 11:24 fontconfig-paths.diff
-rw-r--r--  1 akira users  1053  5月 10 11:24 jdk7-openjdk.install
-rw-r--r--  1 akira users   974  5月 10 11:24 jre7-openjdk-headless.install
-rw-r--r--  1 akira users  1201  5月 10 11:24 jre7-openjdk.install
-rw-r--r--  1 akira users  2324  5月 10 11:24 openjdk7_nonreparenting-wm.diff
</pre>

<p>
<code>PKGBUILD</code> ファイルにデバッグビルドオプションを有効化する。
</p>
<ol class="org-ol">
<li><code>--enable-native-debuginfo=yes</code> build with native code debuginfo [default=yes]
</li>
<li><code>--enable-java-debuginfo=yes</code> build with Java bytecode debuginfo [default=yes]
</li>
<li><code>make icedtea-debug</code> デバッグビルドターゲットに変える
</li>
</ol>

<p>
<code>1</code> と <code>2</code> の規定値は <code>yes</code> なので、指定しなくても問題ありません。 <code>3</code> が肝ですね。
</p>

<div class="org-src-container">

<pre class="src src-sh">  ..........&#30465;&#30053;.........
  |build() {
  |  <span style="color: #63b8ff;">cd</span> <span style="color: #bcee68; font-style: italic;">"${srcdir}/icedtea-${_icedtea_ver}"</span>
  | 
  |  <span style="color: #63b8ff;">export</span> <span style="color: #ff6347;">ALT_PARALLEL_COMPILE_JOBS</span>=<span style="color: #bcee68; font-style: italic;">"${MAKEFLAGS/-j}"</span>
  |  <span style="color: #63b8ff;">export</span> <span style="color: #ff6347;">HOTSPOT_BUILD_JOBS</span>=<span style="color: #bcee68; font-style: italic;">"${ALT_PARALLEL_COMPILE_JOBS}"</span>
  | 
  |  <span style="color: #63b8ff;">.</span> /etc/profile.d/apache-ant.sh
  | 
  |  cp <span style="color: #bcee68; font-style: italic;">"${srcdir}"</span>/*.diff <span style="color: #bcee68; font-style: italic;">"${srcdir}"</span>/icedtea-${<span style="color: #ff6347;">_icedtea_ver</span>}/patches
  |  <span style="color: #63b8ff;">export</span> <span style="color: #ff6347;">DISTRIBUTION_PATCHES</span>=<span style="color: #bcee68; font-style: italic;">"patches/fontconfig-paths.diff \</span>
<span style="color: #bcee68; font-style: italic;">  |                               patches/openjdk7_nonreparenting-wm.diff"</span>
  | 
  |  <span style="color: #00bfff; font-weight: bold;">if</span> [ <span style="color: #bcee68; font-style: italic;">"$_bootstrap"</span> = <span style="color: #bcee68; font-style: italic;">"1"</span> ]; <span style="color: #00bfff; font-weight: bold;">then</span>
  |     <span style="color: #ff6347;">BOOTSTRAPOPT</span>=<span style="color: #bcee68; font-style: italic;">"--enable-bootstrap --with-ecj-jar=/usr/share/java/ecj.jar"</span>
  |   <span style="color: #00bfff; font-weight: bold;">else</span>
  |     <span style="color: #ff6347;">BOOTSTRAPOPT</span>=<span style="color: #bcee68; font-style: italic;">"--disable-bootstrap"</span>
  |  <span style="color: #00bfff; font-weight: bold;">fi</span>
  | 
  |  ./configure <span style="color: #bcee68; font-style: italic;">\</span>
  |        ${<span style="color: #ff6347;">BOOTSTRAPOPT</span>} <span style="color: #bcee68; font-style: italic;">\</span>
  |        --with-parallel-jobs=<span style="color: #bcee68; font-style: italic;">"${MAKEFLAGS/-j}"</span> <span style="color: #bcee68; font-style: italic;">\</span>
  |        --disable-tests <span style="color: #bcee68; font-style: italic;">\</span>
  |        --disable-downloading --disable-Werror <span style="color: #bcee68; font-style: italic;">\</span>
  |        --with-pkgversion=<span style="color: #bcee68; font-style: italic;">"Arch Linux build ${pkgver}-${pkgrel}-${CARCH}"</span> <span style="color: #bcee68; font-style: italic;">\</span>
  |        --with-jdk-home=${<span style="color: #ff6347;">JAVA_HOME</span>} <span style="color: #bcee68; font-style: italic;">\</span>
  |        --with-openjdk-src-zip=<span style="color: #bcee68; font-style: italic;">"${srcdir}/icedtea_${_icedtea_ver}_openjdk.tar.bz2"</span> <span style="color: #bcee68; font-style: italic;">\</span>
  |        --with-hotspot-src-zip=<span style="color: #bcee68; font-style: italic;">"${srcdir}/icedtea_${_icedtea_ver}_hotspot.tar.bz2"</span> <span style="color: #bcee68; font-style: italic;">\</span>
  |        --with-corba-src-zip=<span style="color: #bcee68; font-style: italic;">"${srcdir}/icedtea_${_icedtea_ver}_corba.tar.bz2"</span> <span style="color: #bcee68; font-style: italic;">\</span>
  |        --with-jaxp-src-zip=<span style="color: #bcee68; font-style: italic;">"${srcdir}/icedtea_${_icedtea_ver}_jaxp.tar.bz2"</span> <span style="color: #bcee68; font-style: italic;">\</span>
  |        --with-jaxws-src-zip=<span style="color: #bcee68; font-style: italic;">"${srcdir}/icedtea_${_icedtea_ver}_jaxws.tar.bz2"</span> <span style="color: #bcee68; font-style: italic;">\</span>
  |        --with-jdk-src-zip=<span style="color: #bcee68; font-style: italic;">"${srcdir}/icedtea_${_icedtea_ver}_jdk.tar.bz2"</span> <span style="color: #bcee68; font-style: italic;">\</span>
  |        --with-langtools-src-zip=<span style="color: #bcee68; font-style: italic;">"${srcdir}/icedtea_${_icedtea_ver}_langtools.tar.bz2"</span> <span style="color: #bcee68; font-style: italic;">\</span>
  |        --enable-nss <span style="color: #bcee68; font-style: italic;">\</span>
  |        --with-rhino <span style="color: #bcee68; font-style: italic;">\</span>
  |        --with-abs-install-dir=${<span style="color: #ff6347;">_jvmdir</span>} <span style="color: #bcee68; font-style: italic;">\</span>
1.|        --enable-native-debuginfo=yes <span style="color: #bcee68; font-style: italic;">\</span>
2.|        --enable-java-debuginfo=yes <span style="color: #bcee68; font-style: italic;">\</span>
  |        --enable-infinality=no
  |        <span style="color: #888a85;"># </span><span style="color: #888a85;">TODO latest version of openjdk will disable infinality by default</span>
  |
3.|    make icedtea-debug
  |}
  ..........&#30465;&#30053;.........
</pre>
</div>

<p>
あとは <a href="https://archlinuxjp.kusakata.com/wiki/Makepkg">makepkg</a> でビルドするだけです。コーヒーいっぱい分の時間かかります。
</p>
<pre class="example">
$ makepkg
==&gt; パッケージを作成: java7-openjdk 7.u79_2.5.5-1 (2015年  5月 10日 日曜日 11:43:40 JST)
==&gt; ランタイムの依存関係を確認...
==&gt; ビルドタイムの依存関係を確認...
==&gt; ソースを取得...
..........省略.........

★肝心のhotspotビルド
########################################################################
##### Entering hotspot for target(s) all_debug                     #####
########################################################################
..........省略.........

★ビルド時のオプション
g++ 
-DLINUX
-D_GNU_SOURCE 
-DAMD64 
-DASSERT 
-DDEBUG -I. -I/home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/share/vm/prims -I/home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/share/vm -I/home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/share/vm/precompiled -I/home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/cpu/x86/vm -I/home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/os_cpu/linux_x86/vm -I/home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/os/linux/vm -I/home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/os/posix/vm -I../generated 
-DHOTSPOT_RELEASE_VERSION="\"24.79-b02\"" 
-DHOTSPOT_BUILD_TARGET="\"jvmg\"" 
-DHOTSPOT_BUILD_USER="\"akira\"" 
-DHOTSPOT_LIB_ARCH=\"amd64\" 
-DHOTSPOT_VM_DISTRO="\"OpenJDK\"" 
-DDERIVATIVE_ID="\"IcedTea 2.5.5\"" 
-DDISTRIBUTION_ID="\"Arch Linux, package Arch Linux build 7.u79_2.5.5-1-x86_64\""
-march=x86-64 -mtune=generic -O2 -pipe -fstack-protector-strong --param=ssp-buffer-size=4
-DTARGET_OS_FAMILY_linux 
-DTARGET_ARCH_x86 
-DTARGET_ARCH_MODEL_x86_64 
-DTARGET_OS_ARCH_linux_x86 
-DTARGET_OS_ARCH_MODEL_linux_x86_64 
-DTARGET_COMPILER_gcc 
-DCOMPILER2 
-DCOMPILER1  -fno-rtti -fno-exceptions 
-D_REENTRANT -fcheck-new -fvisibility=hidden -m64 -pipe -g 
-DTARGET_OS_FAMILY_linux 
-DTARGET_ARCH_x86 
-DTARGET_ARCH_MODEL_x86_64 
-DTARGET_OS_ARCH_linux_x86 
-DTARGET_OS_ARCH_MODEL_linux_x86_64 
-DTARGET_COMPILER_gcc 
-DCOMPILER2 
-DCOMPILER1 -fpic -fno-rtti -fno-exceptions 
-D_REENTRANT -fcheck-new -fvisibility=hidden -m64 -pipe 
★カスタマイズdebugビルドフラグ
-g -finstrument-functions -fvar-tracking-assignments -rdynamic
-D_NMT_NOINLINE_ 
-DVM_LITTLE_ENDIAN 
-D_LP64=1 -fno-omit-frame-pointer 
-DINCLUDE_TRACE=1  -Wpointer-arith -Wsign-compare    -c -fpch
-Deps -MMD -MP -MF ../generated/dependencies/osThread_linux.o.d -o osThread_linux.o /home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/os/linux/vm/osThread_linux.cpp

Compiling /home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/os/linux/vm/os_linux.cpp

..........省略.........

-- Build times ----------
Target all_product_build
Start 2015-05-10 11:43:19
End   2015-05-10 12:41:39
00:09:54 corba
00:11:03 hotspot
00:01:15 jaxp
00:01:25 jaxws
00:31:45 jdk
00:02:58 langtools
00:58:20 TOTAL
-------------------------
..........省略.........
</pre>

<p>
僕の環境では約1時間ぐらいかかりました。
</p>
<ul class="org-ul">
<li>CPU: Intel(R) Core(TM) i5-2557M CPU @ 1.70GHz
</li>
<li>Memory: 4G
</li>
<li>SSD
</li>
</ul>


<p>
ビルド成果物はワークディレクトリの下記場所に出力される。
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">デバッグ版OpenJDK</td>
<td class="left">src/icedtea-2.5.5/openjdk.build-debug</td>
</tr>

<tr>
<td class="left">hotspot単体</td>
<td class="left">src/icedtea-2.5.5/openjdk.build-debug/hotspot/outputdir/linux_amd64_compiler2/jvmg</td>
</tr>
</tbody>
</table>
</div>
</div>




<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> gdbでデバッグしてみる</h2>
<div class="outline-text-2" id="text-3">
<ol class="org-ol">
<li>hotspot単体の出力先へ移動する
</li>
<li><code>-gdb</code> オプションを付けて <code>./hotspot</code> を起動する
</li>
<li>デバッグ版のJVMランチャーに既にBreakpointが設定されている
</li>
<li><code>p</code> で変数の値を確認する
</li>
<li><code>next</code> でステップオーバーでデバッグする
</li>
<li><code>step</code> でステップインでデバッグする
</li>
<li><code>backtrace</code> でスタックトレースを確認する
</li>
<li><code>continue</code> で最後まで実行される
</li>
</ol>

<pre class="example">
1.|$ cd src/icedtea-2.5.5/openjdk.build-debug/hotspot/outputdir/linux_amd64_compiler2/jvmg
2.|$ ./hotspot -gdb -version
  |GNU gdb (GDB) 7.9
  |Copyright (C) 2015 Free Software Foundation, Inc.
  |License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
  |This is free software: you are free to change and redistribute it.
  |There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
  |and "show warranty" for details.
  |This GDB was configured as "x86_64-unknown-linux-gnu".
  |Type "show configuration" for configuration details.
  |For bug reporting instructions, please see:
  |&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
  |Find the GDB manual and other documentation resources online at:
  |&lt;http://www.gnu.org/software/gdb/documentation/&gt;.
  |For help, type "help".
  |Type "apropos word" to search for commands related to "word".
  |Breakpoint 1 at 0x4042f7: file /home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/share/tools/launcher/java.c, line 1270.
  |[Thread debugging using libthread_db enabled]
  |Using host libthread_db library "/usr/lib/libthread_db.so.1".
  |Using java runtime at: /home/akira/temp/java7-openjdk/src/icedtea-2.5.5/bootstrap/jdk1.6.0/jre
  |[New Thread 0x7ffff7fa6700 (LWP 15629)]
  |[Switching to Thread 0x7ffff7fa6700 (LWP 15629)]
  | 
3.|Breakpoint 1, InitializeJVM (pvm=0x7ffff7fa5e38, penv=0x7ffff7fa5e30, ifn=0x7ffff7fa5e40)
  |    at /home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/share/tools/launcher/java.c:1270
  |1270     memset(&amp;args, 0, sizeof(args));
4.|(gdb) p args
  |$1 = {version = 0, nOptions = 0, options = 0x0, ignoreUnrecognized = 0 '\000'}
5.|(gdb) next
  |1271     args.version  = JNI_VERSION_1_2;
  |(gdb) next
  |1272     args.nOptions = numOptions;
  |(gdb) next
  |1273     args.options  = options;
  |(gdb) next
  |1274     args.ignoreUnrecognized = JNI_FALSE;
  |(gdb) next
  |1276     if (_launcher_debug) {
  |(gdb) next
  |1288     r = ifn-&gt;CreateJavaVM(pvm, (void **)penv, &amp;args);
6.|(gdb) step
  |JNI_CreateJavaVM (vm=0x7ffff7fa5e38, penv=0x7ffff7fa5e30, args=0x7ffff7fa5df0)
  |    at /home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/share/vm/prims/jni.cpp:5121
  |5121   if (Atomic::xchg(1, &amp;vm_created) == 1) {
7.|(gdb) backtrace 
  |#0  JNI_CreateJavaVM (vm=0x7ffff7fa5e38, penv=0x7ffff7fa5e30, args=0x7ffff7fa5df0)
  |    at /home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/share/vm/prims/jni.cpp:5121
  |#1  0x00000000004043fd in InitializeJVM (pvm=0x7ffff7fa5e38, penv=0x7ffff7fa5e30, ifn=0x7ffff7fa5e40)
  |    at /home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/share/tools/launcher/java.c:1288
  |#2  0x00000000004031ea in JavaMain (_args=0x7fffffffc080)
  |    at /home/akira/temp/java7-openjdk/src/icedtea-2.5.5/openjdk/hotspot/src/share/tools/launcher/java.c:423
  |#3  0x00007ffff5c17374 in start_thread () from /usr/lib/libpthread.so.0
  |#4  0x00007ffff595527d in clone () from /usr/lib/libc.so.6
8.|(gdb) continue
  |Continuing.
  |java version "1.7.0_79"
  |OpenJDK Runtime Environment (IcedTea 2.5.5) (Arch Linux build 7.u79_2.5.5-1-x86_64)
  |OpenJDK 64-Bit Server VM (build 24.79-b02-jvmg, mixed mode)
  |[Thread 0x7ffff7fa6700 (LWP 16481) exited]
  [Thread 0x7ffff7fa8740 (LWP 16477) exited]
  [Inferior 1 (process 16477) exited normally]
  (gdb) q
  $
</pre>
</div>
</div>




<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> valgrindでコールグラフ出してみる</h2>
<div class="outline-text-2" id="text-4">
<p>
valgrindでコールグラフを出してみました。
</p>

<p>
必要なパッケージを入れておく。
</p>
<pre class="example">
$ sudo pacman -S valgrind
$ sudo pacman -S kdesdk-kcachegrind
</pre>

<ol class="org-ol">
<li>デバッグ版OpenJDKの出力先へ移動する
</li>
<li><code>valgrind</code> カーバーして <code>java -version</code> を実行する
</li>
<li><code>kcachegrind</code> で出力結果を解析する
</li>
</ol>

<pre class="example">
1.|$ cd src/icedtea-2.5.5/openjdk.build-debug
2.|$ valgrind --tool=callgrind bin/java -version
  |==18306== Callgrind, a call-graph generating cache profiler
  |==18306== Copyright (C) 2002-2013, and GNU GPL'd, by Josef Weidendorfer et al.
  |==18306== Using Valgrind-3.10.1 and LibVEX; rerun with -h for copyright info
  |==18306== Command: bin/java -version
  |==18306== 
  |==18306== For interactive control, run 'callgrind_control -h'.
  |java version "1.7.0_79-debug"
  |OpenJDK Runtime Environment (IcedTea 2.5.5) (Arch Linux build 7.u79_2.5.5-1-x86_64)
  |OpenJDK 64-Bit Server VM (build 24.79-b02-jvmg, mixed mode)
  |==18306== 
  |==18306== Events    : Ir
  |==18306== Collected : 1610140735
  |==18306== 
  |==18306== I   refs:      1,610,140,735
  |$ ls -al callgrind.out.*
  |-rw------- 1 akira users 5003407  5月 10 12:50 callgrind.out.18306
3.|$ kcachegrind callgrind.out.18306
</pre>

<p>
コールグラフ
</p>


<div class="figure">
<p><img src="img/20150510125343_callgrind.png" alt="20150510125343_callgrind.png" />
</p>
</div>

<p>
バッチリですね！
</p>
</div>
</div>




<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 参考</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li><a href="https://sourceware.org/gdb/onlinedocs/gdb/Variables.html">Variables - Debugging with GDB</a>
</li>
</ul>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[調査]JVMのスタックサイズについて]]></title>
    <link href="http://luozengbin.github.io/blog/2015-04-22-%5B%E8%AA%BF%E6%9F%BB%5Djvm%E3%81%AE%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E3%82%B5%E3%82%A4%E3%82%BA%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6.html"/>
    <updated>2015-04-22T00:00:00+09:00</updated>
    <id>http://luozengbin.github.io/blog/[調査]jvmのスタックサイズについて</id>
    <content type="html"><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 環境</a></li>
<li><a href="#sec-2">2. JVMのスタック領域について</a></li>
<li><a href="#sec-3">3. Javaスレッドのスタックページ構成</a></li>
<li><a href="#sec-4">4. HotSpotの実装</a>
<ul>
<li><a href="#sec-4-1">4.1. glibc guard page</a></li>
<li><a href="#sec-4-2">4.2. HotSpot Guard Pages</a></li>
<li><a href="#sec-4-3">4.3. Normal Stack</a></li>
</ul>
</li>
<li><a href="#sec-5">5. スタックサイズの制御</a></li>
<li><a href="#sec-6">6. ulimit -sの影響範囲</a></li>
<li><a href="#sec-7">7. -Xssと-XX:ThreadStackSizeの違い</a></li>
<li><a href="#sec-8">8. 参考</a></li>
</ul>
</div>
</div>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 環境</h2>
<div class="outline-text-2" id="text-1">
<p>
本記事の内容は以下環境を前提としています。
</p>
<ul class="org-ul">
<li>GNU/Linux x86_64
</li>
<li>OpenJDK 64-Bit 1.7.0_xx
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> JVMのスタック領域について</h2>
<div class="outline-text-2" id="text-2">
<p>
<code>-Xss</code> 、 <code>-XX:ThreadStackSize</code> パラメータ値と <code>ulimit -s</code> リソースリミット制限値を混
乱している記事を見受けたため、HotSpotの中身を調べることにしました。
</p>

<p>
結論を先に、
</p>
<ul class="org-ul">
<li><code>ulimit -s</code> のスタック最大サイズ制限値は親プロセスであるJVMランチャーのみ適用される。
</li>
<li>JVMランチャーやJavaAPIから起動されたJavaスレッドのスタックサイズは  <code>-Xss</code> もしくは
<code>-XX:ThreadStackSize</code> パラメータ値が適用される。
</li>
<li>JVMランチャーから起動されたイニシャルスレッドのスタックサイズは <code>-Xss</code> パラメータの
み制御できる。
</li>
<li>JNI経由で外部からJVMにアタッチしたスレッドのスタックサイズはJVMの管理対象外である。
</li>
</ul>

<p>
<!-- more -->
</p>

<p>
JVMスタックに関して、公式のJVMスペックドキュメント (<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/">Java SE 7 Virtual Machine
Specification</a>) は次のように記載されています。
</p>

<ul class="org-ul">
<li><a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5.2">2.5.2. Java Virtual Machine Stacks</a>
<pre class="example">
Each Java Virtual Machine thread has a private Java Virtual Machine stack, created at
the same time as the thread. A Java Virtual Machine stack stores frames (§2.6). A
Java Virtual Machine stack is analogous to the stack of a conventional language such
as C: it holds local variables and partial results, and plays a part in method
invocation and return. Because the Java Virtual Machine stack is never manipulated
directly except to push and pop frames, frames may be heap allocated. The memory for
a Java Virtual Machine stack does not need to be contiguous.
</pre>
<p>
※メモ： VMスタック内のFrameはヒープ上に配置されるかも知れない。
</p>
</li>
<li><a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5.6">2.5.6. Native Method Stacks</a>
<pre class="example">
An implementation of the Java Virtual Machine may use conventional stacks,
colloquially called "C stacks," to support native methods (methods written in a
language other than the Java programming language). Native method stacks may also be
used by the implementation of an interpreter for the Java Virtual Machine's
instruction set in a language such as C. Java Virtual Machine implementations that
cannot load native methods and that do not themselves rely on conventional stacks
need not supply native method stacks. If supplied, native method stacks are typically
allocated per thread when each thread is created.
</pre>
</li>
</ul>

<p>
仕様上ではJVMに <code>Java Stack</code> と <code>Native Stack</code> ２種類のスタックメモリが定義されています。
</p>

<ul class="org-ul">
<li><code>Java Stack</code> ：Javaコード部分実行時に使われる領域
</li>
<li><code>Native Stack</code> ：はJNIライブラリを利用時に使われる領域
</li>
</ul>

<p>
以下は、JVMのメモリ論理構成イメージです。
</p>
<pre class="example">
+----------------+--------------+-------------+------------------------------------------------------+
|                |              |             |  +-----------------+  +----------+  +-------------+  |
|     Heap       |   PermGen    | Code Cache  |  | Program Counter |  |JavaStack |  |Native Stack |  |
|                |              |             |  +-----------------+  |          |  |             |  |
+----------------+--------------+-------------+                       +----------+  +-------------+  |
                                              |                       | Frame #2 |  |             |  |
                                              |                       +----------+  +-------------+  |
                                              |  &lt;&lt; Thread &gt;&gt;         | Frame #1 |  |             |  |
                                              |                       +----------+  +-------------+  |
                                              +------------------------------------------------------+
</pre>
<p>
<code>図1</code>
</p>

<p>
理論上は <code>Java Stack</code> と <code>Native Stack</code> がスレッド毎に領域が確保されいます。ただし、
実際のメモリページ構成はJDKの実装に依存するものです。
</p>

<p>
次の情報によると、HotSpotの実装は <code>Java Stack</code> と <code>Native Stack</code> が同じメモリ領域を共
有してる。
</p>

<ul class="org-ul">
<li><a href="http://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/toc.html">Troubleshooting Guide for HotSpot VM</a> の <a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/crashes.html#gbyzz">4.1.3 Crash due to Stack Overflow</a>
<pre class="example">
In the HotSpot implementation, Java methods share stack frames with C/C++ native
★~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
code, namely user native code and the virtual machine itself. Java methods generate
code that checks that stack space is available a fixed distance towards the end of
the stack so that the native code can be called without exceeding the stack
space. This distance towards the end of the stack is called “Shadow Pages.” The
size of the shadow pages is between 3 and 20 pages, depending on the platform. This
distance is tunable, so that applications with native code needing more than the
default distance can increase the shadow page size. The option to increase shadow
pages is -XX:StackShadowPages=n, where n is greater than the default stack shadow
pages for the platform.
</pre>
</li>

<li>OpenJDKの開発メーリングリストから拾った内容
<pre class="example">
The stock HotSpot VM (the one in Oracle's Java SE JDK and OpenJDK) uses the
same stack for Java and native methods for a Java thread; Java frames and
native frames can be mixed together in such a stack.
-Xss/-XX:ThreadStackSize controls the whole stack's size for Java threads.
</pre>
<p>
情報源： <a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2011-June/004272.html">What the difference between -Xss and -XX:ThreadStackSize is?</a>
</p>
</li>
</ul>
</div>
</div>




<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Javaスレッドのスタックページ構成</h2>
<div class="outline-text-2" id="text-3">
<p>
HotSpotの実装から見るとJVMから起動されたJavaスレッドのスタックページは次の形で構成さ
れると思います。VM内部スレッドやJITコンパイルスレッドのページ構成はまだ別です。
</p>
<pre class="example">
   --+--                         +------------------------+
     |                          /|                        |\
     |                         / |    StackRedPages       | -XX:StackRedPages=1(4Kb)
     |                        /  |                        |/
     |   HotSpot Guard Pages--   +------------------------+
     |                        \  |                        |\
     |                         \ |    StackYellowPages    | -XX:StackYellowPages=2(8Kb)
     |                          \|                        |/
     |                           +------------------------+
     |                          /|                        |\ ★Native Stackはここです★
     |                         / |    StackShadowPages    | -XX:StackShadowPages=20(80Kb)
-XX:ThreadStackSize           /  |                        |/
     |                       /   +------------------------+
     |                      /    |                        |\
     |                     /     |   +----------------+   | \
     |       Normal Stack--      |   |     Frame      |   |  \
     |                     \     |   +----------------+   |   \
     |                      \    |   |     Frame      |   |    ★Java Stackはここです★
     |                       \   |   +----------------+   |   /
     |                        \  |   |     Frame      |   |  /
     |                         \ |   +----------------+   | /
     |                          \|                        |/
   --+--                         +------------------------+
</pre>
<p>
<code>図2</code>
</p>
</div>
</div>




<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> HotSpotの実装</h2>
<div class="outline-text-2" id="text-4">
<p>
以下はHotSpotのソースコードのコメントに書かれたスタックページ構成図です。
</p>

<p>
<a href="http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/9b0ca45cd756/src/os_cpu/linux_x86/vm/os_linux_x86.cpp#l668">jdk7:hotspot/src/os_cpu/linux_x86/vm/os_linux_x86.cpp</a>
</p>
<pre class="example">
// Java thread:
//
//   Low memory addresses
//    +------------------------+
//    |                        |\  JavaThread created by VM does not have glibc
//    |    glibc guard page    | - guard, attached Java thread usually has
//    |                        |/  1 page glibc guard.
// P1 +------------------------+ Thread::stack_base() - Thread::stack_size()
//    |                        |\
//    |  HotSpot Guard Pages   | - red and yellow pages
//    |                        |/
//    +------------------------+ JavaThread::stack_yellow_zone_base()
//    |                        |\
//    |      Normal Stack      | -
//    |                        |/
// P2 +------------------------+ Thread::stack_base()
//
// Non-Java thread:
//
//   Low memory addresses
//    +------------------------+
//    |                        |\
//    |  glibc guard page      | - usually 1 page
//    |                        |/
// P1 +------------------------+ Thread::stack_base() - Thread::stack_size()
//    |                        |\
//    |      Normal Stack      | -
//    |                        |/
// P2 +------------------------+ Thread::stack_base()
//
// ** P1 (aka bottom) and size ( P2 = P1 - size) are the address and stack size returned from
//    pthread_attr_getstack()
</pre>
<p>
<code>図3</code>
</p>

<p>
図の内容によるとJavaスレッドと非Javaスレッドのスタックページ構成が異なる。
以下はJVMの非Javaスレッドのリストです。
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">スレッド名</th>
<th scope="col" class="left">説明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">VM thread</td>
<td class="left">JVM自身のコアスレッド</td>
</tr>

<tr>
<td class="left">Periodic task thread</td>
<td class="left">WatcherThreadのシングルトンインスタンス、定義的なVMタスクを実行する</td>
</tr>

<tr>
<td class="left">GC threads</td>
<td class="left">その名の通りです、メモリ管理自動化役を務める</td>
</tr>

<tr>
<td class="left">Compiler threads</td>
<td class="left">ByteCodeからアセンブラにコンパイルするスレッド</td>
</tr>

<tr>
<td class="left">Signal dispatcher thread</td>
<td class="left">外部からシグナルをハンドリングする役を務める</td>
</tr>
</tbody>
</table>

<p>
図3の各領域についてソースコードを見ながら解説していきます。
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> glibc guard page</h3>
<div class="outline-text-3" id="text-4-1">
<p>
<code>glibc guard page</code> はスタックポインタのオーバーフローを防ぐための－ガードページ。Java
スレッドには <code>HotSpot Guard Pages</code> が別途用意されているため、この領域のサイズが0であ
る。非Javaスレッドはスタック頂上位置に1ページ分のガードページが割り当てられる。以下は
その実装内容です。
</p>

<ul class="org-ul">
<li>スレッド作成時にglibcの <a href="http://linuxjm.sourceforge.jp/html/LDP_man-pages/man3/pthread_attr_setguardsize.3.html">pthread_attr_setguardsize</a> 関数にてガードページを作成してい
る

<p>
<a href="http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/9b0ca45cd756/src/os/linux/vm/os_linux.cpp#l923">jdk7/hotspot/src/os/linux/vm/os_linux.cpp#l923</a>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00cd66;">// </span><span style="color: #00cd66;">Thread start routine for all newly created threads</span>
<span style="color: #ffffff;">static</span> <span style="color: #7fffd4;">void</span> *<span style="color: #98fb98;">java_start</span>(<span style="color: #7fffd4;">Thread</span> *<span style="color: #9acd32;">thread</span>) {
    ..............
    <span style="color: #00cd66;">// </span><span style="color: #00cd66;">glibc guard page</span>
    pthread_attr_setguardsize(&amp;attr, <span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::default_guard_size(thr_type));
    ..............
}
</pre>
</div>
</li>
<li>スレッド種別によってガードページのサイズを決める

<p>
<a href="http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/9b0ca45cd756/src/os_cpu/linux_x86/vm/os_linux_x86.cpp#l662">jdk7/hotspot/src/os_cpu/linux_x86/vm/os_linux_x86.cpp#l662</a>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #7fffd4;">size_t</span> <span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::<span style="color: #98fb98;">default_guard_size</span>(<span style="color: #40e0d0;">os</span>::<span style="color: #7fffd4;">ThreadType</span> <span style="color: #9acd32;">thr_type</span>) {
  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">Creating guard page is very expensive. Java thread has HotSpot</span>
  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">guard page, only enable glibc guard page for non-Java threads.</span>
  <span style="color: #ffffff;">return</span> (thr_type == java_thread ? 0 : page_size());
}
</pre>
</div>
</li>
</ul>

<p>
<code>glibc guard page</code> の詳細について以下の情報が参考になると思います。
</p>
<ul class="org-ul">
<li><a href="http://docs.oracle.com/cd/E19455-01/806-2732/attrib-22/index.html">スタックガードの大きさの設定</a>
</li>
<li><a href="http://linuxjm.sourceforge.jp/html/LDP_man-pages/man3/pthread_attr_setguardsize.3.html">PTHREAD_ATTR_SETGUARDSIZE</a>
</li>
<li><a href="http://codezine.jp/article/detail/1970">pthreadについて（スタックサイズ）</a>
</li>
<li><a href="http://www.nminoru.jp/~nminoru/programming/stackoverflow_handling.html#get-stack-region">スタックオーバーフローのハンドリング (Stack Overflow Handling)</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> HotSpot Guard Pages</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Javaスレッドスタックオーバーフローを検出するために書き込み不可の <code>HotSpot Guard
Pages</code> 領域がスタック領域のトップ位置に設けている。また <code>HotSpot Guard Pages</code> は
<code>StackYellowPages</code> と <code>StackRedPages</code> から構成されている。
</p>

<p>
<code>StackYellowPages</code> はスタックオーバーフローの緩衝域として、余分のメモリーを割り当てま
す。 スタックポインターが <code>StackRedPages</code> まで行くとStackOverflowErrorが起きる。
</p>

<p>
以下はページの構成イメージです。
</p>
<pre class="example">
          +------------------------+
         /|                        |\
HotSpot / |    StackRedPages       | - 1ページ (4Kb)
Guard  /  |                        |/
Pages     +------------------------+
       \  |                        |\
        \ |    StackYellowPages    | - 2ページ (8Kb)
         \|                        |/
          +------------------------+
          |                        |
          |      Normal Stack      |
          |                        |
          +------------------------+
</pre>
<p>
<code>図4</code>
</p>

<p>
Linux/x86_64環境に置いて、 <code>StackYellowPages</code> と <code>StackRedPages</code> の初期値が2と1である。
それぞれの値は <code>-XX:StackYellowPages</code> と <code>-XX:StackRedPages</code> パラメータにて変更するこ
とが可能です。
</p>

<p>
下記は <code>HotSpot Guard Pages</code> の割当処理ロジックです。
</p>

<ul class="org-ul">
<li>Javaスレッド起動時のガードページ割当位置やサイズの計算処理

<p>
<a href="http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/9b0ca45cd756/src/share/vm/runtime/thread.cpp#l2257">jdk7:openjdk/hotspot/src/share/vm/runtime/thread.cpp</a>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #7fffd4;">void</span> <span style="color: #40e0d0;">JavaThread</span>::<span style="color: #98fb98;">create_stack_guard_pages</span>() {
  <span style="color: #ffffff;">if</span> (! <span style="color: #40e0d0;">os</span>::uses_stack_guard_pages() || _stack_guard_state != stack_guard_unused) <span style="color: #ffffff;">return</span>;

  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733; &#12460;&#12540;&#12489;&#12506;&#12540;&#12472;&#12398;&#20301;&#32622;&#12392;&#12469;&#12452;&#12474;&#12398;&#35336;&#31639;</span>
  <span style="color: #7fffd4;">address</span> <span style="color: #9acd32;">low_addr</span> = stack_base() - stack_size();
  <span style="color: #7fffd4;">size_t</span> <span style="color: #9acd32;">len</span> = (StackYellowPages + StackRedPages) * <span style="color: #40e0d0;">os</span>::vm_page_size();

  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733; &#12460;&#12540;&#12489;&#12506;&#12540;&#12472;&#21106;&#24403;&#20966;&#29702;&#12399;&#12503;&#12521;&#12483;&#12488;&#12501;&#12457;&#12540;&#12512;&#20381;&#23384;&#12398;&#12383;&#12417;&#12289;&#21029;&#38306;&#25968;&#12434;&#12467;&#12540;&#12523;</span>
  <span style="color: #7fffd4;">int</span> <span style="color: #9acd32;">allocate</span> = <span style="color: #40e0d0;">os</span>::allocate_stack_guard_pages();
  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">warning("Guarding at " PTR_FORMAT " for len " SIZE_FORMAT "\n", low_addr, len);</span>

  <span style="color: #ffffff;">if</span> (allocate &amp;&amp; !<span style="color: #40e0d0;">os</span>::create_stack_guard_pages((<span style="color: #7fffd4;">char</span> *) low_addr, len)) {
    warning(<span style="color: #bdb76b;">"Attempt to allocate stack guard pages failed."</span>);
    <span style="color: #ffffff;">return</span>;
  }

  <span style="color: #ffffff;">if</span> (<span style="color: #40e0d0;">os</span>::guard_memory((<span style="color: #7fffd4;">char</span> *) low_addr, len)) {
    _stack_guard_state = stack_guard_enabled;
  } <span style="color: #ffffff;">else</span> {
    warning(<span style="color: #bdb76b;">"Attempt to protect stack guard pages failed."</span>);
    <span style="color: #ffffff;">if</span> (<span style="color: #40e0d0;">os</span>::uncommit_memory((<span style="color: #7fffd4;">char</span> *) low_addr, len)) {
      warning(<span style="color: #bdb76b;">"Attempt to deallocate stack guard pages failed."</span>);
    }
  }
}
</pre>
</div>
</li>

<li>ガードページ割当処理

<p>
<a href="http://hg.openjdk.java.net/jdk7u/jdk7u60/hotspot/file/ba66650acf63/src/os/linux/vm/os_linux.cpp#l3062">jdk7u60:openjdk/hotspot/src/os/linux/vm/os_linux.cpp</a>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #7fffd4;">bool</span> <span style="color: #40e0d0;">os</span>::<span style="color: #98fb98;">pd_create_stack_guard_pages</span>(<span style="color: #7fffd4;">char</span>* <span style="color: #9acd32;">addr</span>, <span style="color: #7fffd4;">size_t</span> <span style="color: #9acd32;">size</span>) {

  <span style="color: #ffffff;">if</span> (<span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::is_initial_thread()) {
    <span style="color: #00cd66;">// </span><span style="color: #00cd66;">As we manually grow stack up to bottom inside create_attached_thread(),</span>
    <span style="color: #00cd66;">// </span><span style="color: #00cd66;">it's likely that os::Linux::initial_thread_stack_bottom is mapped and</span>
    <span style="color: #00cd66;">// </span><span style="color: #00cd66;">we don't need to do anything special.</span>
    <span style="color: #00cd66;">// </span><span style="color: #00cd66;">Check it first, before calling heavy function.</span>
    <span style="color: #7fffd4;">uintptr_t</span> <span style="color: #9acd32;">stack_extent</span> = (<span style="color: #7fffd4;">uintptr_t</span>) <span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::initial_thread_stack_bottom();
    <span style="color: #7fffd4;">unsigned</span> <span style="color: #7fffd4;">char</span> <span style="color: #9acd32;">vec</span>[1];

    <span style="color: #ffffff;">if</span> (mincore((<span style="color: #7fffd4;">address</span>)stack_extent, <span style="color: #40e0d0;">os</span>::vm_page_size(), vec) == -1) {
      <span style="color: #00cd66;">// </span><span style="color: #00cd66;">Fallback to slow path on all errors, including EAGAIN</span>
      stack_extent = (<span style="color: #7fffd4;">uintptr_t</span>) get_stack_commited_bottom(
                                    <span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::initial_thread_stack_bottom(),
                                    (<span style="color: #7fffd4;">size_t</span>)addr - stack_extent);
    }

    <span style="color: #ffffff;">if</span> (stack_extent &lt; (<span style="color: #7fffd4;">uintptr_t</span>)addr) {
      ::munmap((<span style="color: #7fffd4;">void</span>*)stack_extent, (<span style="color: #7fffd4;">uintptr_t</span>)(addr - stack_extent));
    }
  }

  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733;&#12371;&#12371;&#12363;&#12425; mmap&#12471;&#12473;&#12486;&#12512;&#12467;&#12540;&#12523;&#12364;&#30330;&#34892;&#12373;&#12428;&#12427;&#12290;</span>
  <span style="color: #00cd66;">//  </span><span style="color: #00cd66;">&#26368;&#24460;&#12398;&#24341;&#25968;&#12395;&#26360;&#12365;&#36796;&#12415;&#19981;&#21487;&#12398;&#12501;&#12521;&#12464;&#12364;&#20184;&#19982;&#12373;&#12428;&#12383;</span>
  <span style="color: #ffffff;">return</span> <span style="color: #40e0d0;">os</span>::commit_memory(addr, size, !ExecMem);
}
</pre>
</div>
</li>
</ul>

<p>
以下は <code>JBoss AS7</code> アプリケーションサーバ実行時にワーカスレッドのスタック仮想メモリ割
当状況です。
</p>

<pre class="example">
$ cat /proc/`ps -ef | grep [j]boss.modules.system | awk '{print $2}'`/smaps
...省略...
7ff751076000-7ff751079000 ---p 00000000 00:00 0
Size:                 12 kB    ★説明: StackRedPages(4Kb) + StackYellowPages(8Kb) = 12Kb
Rss:                   0 kB
Pss:                   0 kB
Shared_Clean:          0 kB
Shared_Dirty:          0 kB
Private_Clean:         0 kB
Private_Dirty:         0 kB
Referenced:            0 kB
Anonymous:             0 kB
AnonHugePages:         0 kB
Swap:                  0 kB
KernelPageSize:        4 kB
MMUPageSize:           4 kB
Locked:                0 kB
VmFlags: mr mw me ac          ★説明:書き込み不可
7ff751079000-7ff751177000 rw-p 00000000 00:00 0                          [stack:21275]
Size:               1016 kB   ★説明: ここからNormal Stackページ
Rss:                 108 kB
Pss:                 108 kB
Shared_Clean:          0 kB
Shared_Dirty:          0 kB
Private_Clean:         0 kB
Private_Dirty:       108 kB
Referenced:          108 kB
Anonymous:           108 kB
AnonHugePages:         0 kB
Swap:                  0 kB
KernelPageSize:        4 kB
MMUPageSize:           4 kB
Locked:                0 kB
VmFlags: rd wr mr mw me ac
...省略...
</pre>

<p>
次のSystemTapスクリプトで <code>HotSpot Guard Pages</code> の割当処理をトレースしてみた。
</p>

<p>
<code>jvm_memory_trace.stp</code>
</p>
<pre class="example">
#!/usr/bin/stap -p4
probe process("/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/server/libjvm.so").function("commit_memory_impl")
{
   printf("---------------------------------------------------------\n")
   printf("%d\t%s\n", tid(), $$parms)
   print_ustack(ubacktrace())
}
</pre>

<p>
出力結果
</p>
<pre class="example">
  |$ stap jvm_memory_trace.stp -c "java  -version"
  |Using a compile server.
  |WARNING: Missing unwind data for module, rerun with 'stap -d ...dk-1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/jli/libjli.so'
  |WARNING: Missing unwind data for module, rerun with 'stap -d /usr/lib64/libpthread-2.17.so'
  |java version "1.7.0_75"
  |OpenJDK Runtime Environment (rhel-2.5.4.7.el7_1-x86_64 u75-b13)
  |OpenJDK 64-Bit Server VM (build 24.75-b04, mixed mode)
  |
  |★省略★
  |--------------------------------------------------------------------------------------------------------------
①|12179   exec=0x0 size=0x3000 addr=0x7f1d05b57000  ★commit_memory_impl関数実行時の引数情報
  | 0x7f1d04808371 : _ZN2os16pd_commit_memoryEPcmb+0x1/0xf0 [...1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/server/libjvm.so]
  | 0x7f1d04802dee : _ZN2os13commit_memoryEPcmb+0x2e/0xd0 [...1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/server/libjvm.so]
②| 0x7f1d048092df : _ZN2os27pd_create_stack_guard_pagesEPcm+0x7f/0x180 [...1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/server/libjvm.so]
  | 0x7f1d04945519 : _ZN7Threads9create_vmEP14JavaVMInitArgsPb+0x339/0x1550 [...1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/server/libjvm.so]
  | 0x7f1d0463fca7 : JNI_CreateJavaVM+0x67/0x2a0 [...1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/server/libjvm.so]
  | 0x7f1d0562aa68 : 0x7f1d0562aa68 [...dk-1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/jli/libjli.so+0x2a68/0x20e000]
  |--------------------------------------------------------------------------------------------------------------
  |★以降省略★
</pre>

<p>
出力結果に①の <a href="http://hg.openjdk.java.net/jdk7u/jdk7u60/hotspot/file/ba66650acf63/src/os/linux/vm/os_linux.cpp#l2728">commit_memory_impl</a> 仮想メモリ割当処理の第２引数にメモリサイズを指定し
ています。 <code>size=0x3000</code> の値が16進数ですので、10進数に変換すると12Kbです。予測通りで
すね。
</p>

<p>
gdbを用いて上記出力結果から②のソースコード位置を特定する方法を以下に示す。
</p>
<pre class="example">
$ gdb /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/server/libjvm.so
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-64.el7
★一部内容省略★
Reading symbols from /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/server/libjvm.so...Reading symbols from /usr/lib/debug/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.75-2.5.4.7.el7_1.x86_64/jre/lib/amd64/server/libjvm.so.debug...done.
done.
★出力結果から関数名ぽいの文字列で関数を探す
(gdb) info functions pd_create_stack_guard_pages
All functions matching regular expression "pd_create_stack_guard_pages":

★検索結果
File /usr/src/debug/java-1.7.0-openjdk-1.7.0.75-2.5.4.7.el7_1.x86_64/openjdk/hotspot/src/os/linux/vm/os_linux.cpp:
bool os::pd_create_stack_guard_pages(char*, unsigned long);
(gdb)
</pre>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> Normal Stack</h3>
<div class="outline-text-3" id="text-4-3">
<p>
Javaスレッドを前提に置いて、 <code>Normal Stack</code> には通常Javaメソッド実行時のフレーム情報
が格納される。ただし、スレッドからC/C++メソッドを実行する時も <code>Normal Stack</code> が利用さ
れる。スタックのトップ位置にC/C++メソッド実行用の <code>StackShadowPages</code> が設けられている。
Linux/x86_64環境に置いて <code>StackShadowPages</code> の初期値が20である。
</p>

<pre class="example">
              +------------------------+
             /|                        |\
            / |    StackShadowPages    | -XX:StackShadowPages=20(80Kb)
           /  |                        |/ ★Native Stackはここです!
          /   +------------------------+
         /    |                        |\
        /     |   +----------------+   | \ 
Normal Stack  |   |     Frame      |   |  \
        \     |   +----------------+   |   \
         \    |   |     Frame      |   |    - ★Java Stackはここです！
          \   |   +----------------+   |   /
           \  |   |     Frame      |   |  /
            \ |   +----------------+   | /
             \|                        |/
              +------------------------+
</pre>
<p>
<code>図5</code>
</p>

<p>
以下は <code>StackShadowPages</code> 初期値の代入処理ロジックです。
</p>

<p>
<a href="http://hg.openjdk.java.net/jdk7u/jdk7u60/hotspot/file/ba66650acf63/src/cpu/x86/vm/globals_x86.hpp#l60">jdk7:hotspot/src/cpu/x86/vm/globals_x86.hpp#l60</a>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #b0c4de;">#ifdef</span> AMD64
<span style="color: #00cd66;">// </span><span style="color: #00cd66;">Very large C++ stack frames using solaris-amd64 optimized builds</span>
<span style="color: #00cd66;">// </span><span style="color: #00cd66;">due to lack of optimization caused by C++ compiler bugs</span>
define_pd_global(intx, StackShadowPages, NOT_WIN64(20) WIN64_ONLY(6) DEBUG_ONLY(+2));
<span style="color: #b0c4de;">#else</span>
define_pd_global(intx, StackShadowPages, 6 DEBUG_ONLY(+5));
<span style="color: #b0c4de;">#endif</span> <span style="color: #00cd66;">// </span><span style="color: #00cd66;">AMD64</span>
</pre>
</div>

<p>
<code>StackShadowPages</code> に関して以下の情報が参考になると思います。
</p>
<ul class="org-ul">
<li><a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/crashes.html#gbyzz">Troubleshooting Guide for HotSpot VM 4.1.3 Crash due to Stack Overflow</a>
</li>
<li><a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=7059899a">JDK-7059899 : Stack overflows in Java code cause 64-bit JVMs to exit due to SIGSEGV</a>
</li>
<li><a href="https://access.redhat.com/solutions/698483">What does the StackShadowPages JVM setting do?</a>
<pre class="example">
StackShadowPages reserves a portion of the thread stack for native layer
allocations. The page size usually is 4096b, which mean that 20 pages would occupy
80Kb. The thread stack is sized through -Xss.

Consider some config examples:

   -Xss1024k -XX:StackShadowPages=10

   [       984kb java stack    | 40kb native stack]

   -Xss1024k -XX:StackShadowPages=20

   [       944kb java stack    |   80kb native stack]

   -Xss512k -XX:StackShadowPages=10

   [ 472kb java stack | 40kb native stack]

If you decrease just -Xss, the overall stack is decreased, but the StackShadowPages
native reservation is not; only the java portion would lose space. Likewise if you
only increase -Xss, only the java portion gains space with the increased stack.

If you increase StackShadowPages, the java portion becomes smaller so that the native
portion can be larger. If the native portion of a stack is exhausted, the JVM can
fatally crash so sometimes StackShadowPages needs to be increased.
</pre>
</li>
</ul>
</div>
</div>
</div>




<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> スタックサイズの制御</h2>
<div class="outline-text-2" id="text-5">
<p>
従いましてJava Methodに使えるスタック領域(Java Stack)のサイズは次の式で計算出来る。
</p>
<font color="red"><strong>
<p>
Java Satck Size = Thread::stack_size() - ((StackRedPages + StackYellowPages + StackShadowPages) * PageSize)
</p>
</strong></font>

<p>
<code>Thread::stack_size()</code> の値はスレッド起動時にglibcの <a href="http://linuxjm.sourceforge.jp/html/LDP_man-pages/man3/pthread_attr_setstacksize.3.html">pthread_attr_setstacksize</a> 関数を
用いて設定される。以下はHotSpotの実装です。
</p>

<ul class="org-ul">
<li>JVM起動時に実行される処理
<a href="http://hg.openjdk.java.net/jdk7u/jdk7u60/hotspot/file/ba66650acf63/src/os/linux/vm/os_linux.cpp#l4820">jdk7/hotspot/src/os/linux/vm/os_linux.cpp#4820</a>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00cd66;">// </span><span style="color: #00cd66;">this is called _after_ the global arguments have been parsed</span>
<span style="color: #7fffd4;">jint</span> <span style="color: #40e0d0;">os</span>::<span style="color: #98fb98;">init_2</span>(<span style="color: #7fffd4;">void</span>)
{
  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733;&#19968;&#37096;&#30465;&#30053;&#9733;</span>


  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733;&#12473;&#12524;&#12483;&#12489;&#12395;&#21106;&#24403;&#12427;&#12473;&#12479;&#12483;&#12463;&#12469;&#12452;&#12474;&#12398;&#26368;&#23567;&#35377;&#23481;&#20516;&#12398;&#35336;&#31639;</span>

  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">Check minimum allowable stack size for thread creation and to initialize</span>
  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">the java system classes, including StackOverflowError - depends on page</span>
  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">size.  Add a page for compiler2 recursion in main thread.</span>
  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">Add in 2*BytesPerWord times page size to account for VM stack during</span>
  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">class initialization depending on 32 or 64 bit VM.</span>
  <span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::min_stack_allowed = MAX2(<span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::min_stack_allowed,
            (<span style="color: #7fffd4;">size_t</span>)(StackYellowPages+StackRedPages+StackShadowPages) * <span style="color: #40e0d0;">Linux</span>::page_size() +
                    (2*BytesPerWord COMPILER2_PRESENT(+1)) * <span style="color: #40e0d0;">Linux</span>::vm_default_page_size());

<span style="color: #b0c4de;">#ifdef</span> ZERO
  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">If this is Zero, allow at the very minimum one page each for the</span>
  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">Zero stack and the native stack.  This won't make any difference</span>
  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">for 4k pages, but is significant for large pages.</span>
  <span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::min_stack_allowed = MAX2(<span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::min_stack_allowed,
             (<span style="color: #7fffd4;">size_t</span>)(StackYellowPages+StackRedPages+StackShadowPages+2) * <span style="color: #40e0d0;">Linux</span>::page_size());
<span style="color: #b0c4de;">#endif</span>

  <span style="color: #7fffd4;">size_t</span> <span style="color: #9acd32;">threadStackSizeInBytes</span> = ThreadStackSize * K;
  <span style="color: #ffffff;">if</span> (threadStackSizeInBytes != 0 &amp;&amp;
      threadStackSizeInBytes &lt; <span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::min_stack_allowed) {
        tty-&gt;print_cr(<span style="color: #bdb76b;">"\nThe stack size specified is too small, "</span>
                      <span style="color: #bdb76b;">"Specify at least %dk"</span>,
                      <span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::min_stack_allowed/ K);
        <span style="color: #ffffff;">return</span> JNI_ERR;
  }

  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733;-XX:ThreadStackSize&#12398;&#20516;&#12434;&#38745;&#30340;_stack_size_at_create&#22793;&#25968;&#12395;&#20195;&#20837;&#12377;&#12427;</span>
  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">Make the stack size a multiple of the page size so that</span>
  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">the yellow/red zones can be guarded.</span>
  <span style="color: #40e0d0;">JavaThread</span>::set_stack_size_at_create(round_to(threadStackSizeInBytes,
        vm_page_size()));

  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733;&#12452;&#12491;&#12471;&#12515;&#12523;&#12473;&#12524;&#12483;&#12489;&#12398;&#12473;&#12479;&#12483;&#12463;&#12469;&#12452;&#12474;&#35373;&#23450;&#20966;&#29702;&#65288;&#9733;TODO: &#21029;&#36884;&#35519;&#26619;&#12377;&#12427;&#65289;</span>
  <span style="color: #40e0d0;">Linux</span>::capture_initial_stack(<span style="color: #40e0d0;">JavaThread</span>::stack_size_at_create());

  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733;&#20197;&#38477;&#30465;&#30053;&#9733;</span>
</pre>
</div>
</li>
<li>新規スレッド起動時の処理
<a href="http://hg.openjdk.java.net/jdk7u/jdk7u60/hotspot/file/ba66650acf63/src/os/linux/vm/os_linux.cpp#l901">jdk7:hotspot/src/os/linux/vm/os_linux.cpp#901</a>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #7fffd4;">bool</span> <span style="color: #40e0d0;">os</span>::<span style="color: #98fb98;">create_thread</span>(<span style="color: #7fffd4;">Thread</span>* <span style="color: #9acd32;">thread</span>, <span style="color: #7fffd4;">ThreadType</span> <span style="color: #9acd32;">thr_type</span>, <span style="color: #7fffd4;">size_t</span> <span style="color: #9acd32;">stack_size</span>) {

  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733;&#19968;&#37096;&#30465;&#30053;&#9733;</span>

  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733;&#12473;&#12524;&#12483;&#12489;&#31278;&#21029;&#27598;&#12395;&#12473;&#12479;&#12483;&#12463;&#12469;&#12452;&#12474;&#12434;&#27770;&#12417;&#12427;</span>
  <span style="color: #ffffff;">if</span> (<span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::supports_variable_stack_size()) {
    <span style="color: #00cd66;">// </span><span style="color: #00cd66;">calculate stack size if it's not specified by caller</span>
    <span style="color: #ffffff;">if</span> (stack_size == 0) {
      stack_size = <span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::default_stack_size(thr_type);

      <span style="color: #ffffff;">switch</span> (thr_type) {

      <span style="color: #00cd66;">//</span><span style="color: #00cd66;">&#9733;Java&#12527;&#12540;&#12459;&#12473;&#12524;&#12483;&#12489;&#12398;&#22580;&#21512;</span>
      <span style="color: #ffffff;">case</span> <span style="color: #40e0d0;">os</span>::java_thread:
        <span style="color: #00cd66;">// </span><span style="color: #00cd66;">Java threads use ThreadStackSize which default value can be</span>
        <span style="color: #00cd66;">// </span><span style="color: #00cd66;">changed with the flag -Xss</span>
        assert (<span style="color: #40e0d0;">JavaThread</span>::stack_size_at_create() &gt; 0, <span style="color: #bdb76b;">"this should be set"</span>);
        stack_size = <span style="color: #40e0d0;">JavaThread</span>::stack_size_at_create();
        <span style="color: #ffffff;">break</span>;

      <span style="color: #00cd66;">//</span><span style="color: #00cd66;">&#9733;JIT&#12467;&#12531;&#12497;&#12452;&#12521;&#12473;&#12524;&#12483;&#12489;&#12398;&#22580;&#21512;</span>
      <span style="color: #ffffff;">case</span> <span style="color: #40e0d0;">os</span>::compiler_thread:
        <span style="color: #ffffff;">if</span> (CompilerThreadStackSize &gt; 0) {
          stack_size = (<span style="color: #7fffd4;">size_t</span>)(CompilerThreadStackSize * K);
          <span style="color: #ffffff;">break</span>;
        } <span style="color: #00cd66;">// </span><span style="color: #00cd66;">else fall through:</span>
          <span style="color: #00cd66;">// </span><span style="color: #00cd66;">use VMThreadStackSize if CompilerThreadStackSize is not defined</span>

      <span style="color: #00cd66;">//</span><span style="color: #00cd66;">&#9733;VM&#12473;&#12524;&#12483;&#12489;&#12289;GC&#12473;&#12524;&#12483;&#12489;&#12289;&#12454;&#12457;&#12483;&#12481;&#12515;&#12540;&#12473;&#12524;&#12483;&#12489;&#12398;&#22580;&#21512;</span>
      <span style="color: #ffffff;">case</span> <span style="color: #40e0d0;">os</span>::vm_thread:
      <span style="color: #ffffff;">case</span> <span style="color: #40e0d0;">os</span>::pgc_thread:
      <span style="color: #ffffff;">case</span> <span style="color: #40e0d0;">os</span>::cgc_thread:
      <span style="color: #ffffff;">case</span> <span style="color: #40e0d0;">os</span>::watcher_thread:
        <span style="color: #ffffff;">if</span> (VMThreadStackSize &gt; 0) stack_size = (<span style="color: #7fffd4;">size_t</span>)(VMThreadStackSize * K);
        <span style="color: #ffffff;">break</span>;
      }
    }

    stack_size = MAX2(stack_size, <span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::min_stack_allowed);
    <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733;glic&#38306;&#25968;&#29992;&#12356;&#12390;stack&#38936;&#22495;&#12434;&#30906;&#20445;&#12377;&#12427;</span>
    pthread_attr_setstacksize(&amp;attr, stack_size);

    <span style="color: #00cd66;">// </span><span style="color: #00cd66;">&#9733;&#20197;&#38477;&#30465;&#30053;&#9733;</span>
</pre>
</div>
</li>
</ul>

<p>
以上コードの通り、JVMから起動されたスレッドの種別毎のスタックサイズが下記XXパラメータ値が適用されてい
る。
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">引数</th>
<th scope="col" class="left">Linux/x86_64環境初期値</th>
<th scope="col" class="left">適用範囲</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">-XX:ThreadStackSize</td>
<td class="left">1M</td>
<td class="left">Javaスレッド</td>
</tr>

<tr>
<td class="left">-XX:VMThreadStackSize</td>
<td class="left">1M</td>
<td class="left">VM thread、GC threads、VM Periodic Task Threadなど</td>
</tr>

<tr>
<td class="left">-XX:CompilerThreadStackSize</td>
<td class="left">4M</td>
<td class="left">C1 C2 CompilerThread</td>
</tr>
</tbody>
</table>

<p>
以下は実機にて確認された各パラメータの初期値です。
</p>
<pre class="example">
$ java -XX:+PrintFlagsFinal -version | grep -e "CompilerThreadStackSize\|ThreadStackSize\|VMThreadStackSize"
     intx CompilerThreadStackSize                   = 0               {pd product}
     intx ThreadStackSize                           = 1024            {pd product}
     intx VMThreadStackSize                         = 1024            {pd product}
java version "1.7.0_75"
OpenJDK Runtime Environment (rhel-2.5.4.7.el7_1-x86_64 u75-b13)
OpenJDK 64-Bit Server VM (build 24.75-b04, mixed mode)
</pre>

<p>
<code>CompilerThreadStackSize</code> が指定しない場合下記コードにて初期値が代入される。
</p>

<p>
<a href="http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/9b0ca45cd756/src/os_cpu/linux_x86/vm/os_linux_x86.cpp#l652">jdk7:hotspot/src/os_cpu/linux_x86/vm/os_linux_x86.cpp#652</a>
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00cd66;">// </span><span style="color: #00cd66;">return default stack size for thr_type</span>
<span style="color: #7fffd4;">size_t</span> <span style="color: #40e0d0;">os</span>::<span style="color: #40e0d0;">Linux</span>::<span style="color: #98fb98;">default_stack_size</span>(<span style="color: #40e0d0;">os</span>::<span style="color: #7fffd4;">ThreadType</span> <span style="color: #9acd32;">thr_type</span>) {
  <span style="color: #00cd66;">// </span><span style="color: #00cd66;">default stack size (compiler thread needs larger stack)</span>
<span style="color: #b0c4de;">#ifdef</span> AMD64
  <span style="color: #7fffd4;">size_t</span> <span style="color: #9acd32;">s</span> = (thr_type == <span style="color: #40e0d0;">os</span>::compiler_thread ? 4 * M : 1 * M);
<span style="color: #b0c4de;">#else</span>
  <span style="color: #7fffd4;">size_t</span> <span style="color: #9acd32;">s</span> = (thr_type == <span style="color: #40e0d0;">os</span>::compiler_thread ? 2 * M : 512 * K);
<span style="color: #b0c4de;">#endif</span> <span style="color: #00cd66;">// </span><span style="color: #00cd66;">AMD64</span>
  <span style="color: #ffffff;">return</span> s;
}
</pre>
</div>

<p>
次のサンプルプログラムを実行して、各スレッドのスタックサイズ値を実測してみる。
</p>

<p>
<code>HelloWorld.java</code>
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ffffff;">public</span> <span style="color: #ffffff;">class</span> <span style="color: #7fffd4;">HelloWorld</span> <span style="color: #ffffff;">implements</span> <span style="color: #7fffd4;">Runnable</span> {

    <span style="color: #ffffff;">public</span> <span style="color: #7fffd4;">void</span> <span style="color: #98fb98;">run</span>(){
        <span style="color: #ffffff;">while</span>(<span style="color: #40e0d0;">true</span>) {
            <span style="color: #ffffff;">try</span> {
                Thread.sleep(1 * 1000L);
                System.out.println(Thread.currentThread().toString() + <span style="color: #bdb76b;">": Hello World"</span>);
            } <span style="color: #ffffff;">catch</span> (<span style="color: #7fffd4;">Exception</span> <span style="color: #9acd32;">e</span>) {
            }
        }
    }

    <span style="color: #ffffff;">public</span> <span style="color: #ffffff;">static</span> <span style="color: #7fffd4;">void</span> <span style="color: #98fb98;">main</span>(<span style="color: #7fffd4;">String</span>[] <span style="color: #9acd32;">args</span>) <span style="color: #ffffff;">throws</span> <span style="color: #7fffd4;">Exception</span> {
        <span style="color: #7fffd4;">Thread</span>[] <span style="color: #9acd32;">t_arry</span> =  <span style="color: #ffffff;">new</span> <span style="color: #7fffd4;">Thread</span>[5];
        <span style="color: #ffffff;">for</span> (<span style="color: #7fffd4;">int</span> <span style="color: #9acd32;">i</span> = 0; i &lt; t_arry.<span style="color: #7fffd4;">length</span>; i++) {
            t_arry[i]  =  <span style="color: #ffffff;">new</span> <span style="color: #7fffd4;">Thread</span>(<span style="color: #ffffff;">new</span> <span style="color: #7fffd4;">HelloWorld</span>());
            t_arry[i].start();
        }
        <span style="color: #ffffff;">for</span> (<span style="color: #7fffd4;">int</span> <span style="color: #9acd32;">i</span> = 0; i &lt; t_arry.<span style="color: #7fffd4;">length</span>; i++) {
            t_arry[i].join();
        }

    }
}
</pre>
</div>

<p>
スタックサイズの実測値は次のスクリプトで取得しています。
</p>

<p>
<code>jvm_stacksize.sh</code>
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #00cd66;">#</span><span style="color: #00cd66;">!/bin/</span><span style="color: #ffffff;">sh</span>

<span style="color: #ffffff;">if</span> [ ! $<span style="color: #9acd32;">#</span> -eq 1 ]; <span style="color: #ffffff;">then</span>
    <span style="color: #b0c4de;">echo</span> <span style="color: #bdb76b;">"Usage ${0} &lt;JVM PID&gt;"</span>
    <span style="color: #ffffff;">exit</span> 1
<span style="color: #ffffff;">fi</span>

<span style="color: #b0c4de;">printf</span> <span style="color: #bdb76b;">"[ PID ]\t[StackSize]\t[GuardPages]\t[Thread Name]\n"</span>

<span style="color: #00cd66;"># </span><span style="color: #00cd66;">jstack&#12398;&#20986;&#21147;&#32080;&#26524;&#12363;&#12425;&#12473;&#12524;&#12483;&#12489;ID&#12392;&#21517;&#21069;&#12434;&#25277;&#20986;&#12377;&#12427;</span>
jstack $<span style="color: #9acd32;">1</span> | grep nid | sed -e <span style="color: #bdb76b;">"s/^\"\(.*\)\".*nid=\(0x[0-9|a-z]*\).*$/\2,\1/"</span> | sort | <span style="color: #ffffff;">while </span><span style="color: #b0c4de;">read</span> line
<span style="color: #ffffff;">do</span>
    <span style="color: #00cd66;"># </span><span style="color: #00cd66;">&#12473;&#12524;&#12483;&#12489;ID&#12434;&#20999;&#12426;&#20986;&#12377;</span>
    <span style="color: #9acd32;">pid_hex</span>=<span style="color: #fa8072;">`echo "${line}" | awk -F"," '{print $1}'`</span>

    <span style="color: #00cd66;"># </span><span style="color: #00cd66;">&#12473;&#12524;&#12483;&#12489;&#21517;&#12434;&#20999;&#12426;&#20986;&#12377;</span>
    <span style="color: #9acd32;">thread_name</span>=<span style="color: #fa8072;">`echo "${line}" | awk -F"," '{print $2}'`</span>

    <span style="color: #00cd66;"># </span><span style="color: #00cd66;">&#12473;&#12524;&#12483;&#12489;ID&#12434;10&#36914;&#25968;&#12395;&#22793;&#25563;</span>
    <span style="color: #9acd32;">pid</span>=<span style="color: #fa8072;">`printf '%d\n' ${pid_hex}`</span>

    <span style="color: #00cd66;"># </span><span style="color: #00cd66;">/proc/&lt;pid&gt;/smaps &#12501;&#12449;&#12452;&#12523;&#12363;&#12425;&#12473;&#12479;&#12483;&#12463;&#12469;&#12452;&#12474;&#12289;&#12460;&#12540;&#12489;&#12506;&#12540;&#12472;&#12469;&#12452;&#12474;&#12434;&#21462;&#24471;&#12377;&#12427;</span>
    <span style="color: #9acd32;">guard_page</span>=<span style="color: #fa8072;">`cat /proc/$1/smaps | grep -B15 "stack:${pid}"| head -1 | awk '{print $2}'`</span>
    <span style="color: #9acd32;">stack_page</span>=<span style="color: #fa8072;">`cat /proc/$1/smaps | grep -A1 "stack:${pid}" | tail -1 | awk '{print $2}'`</span>
    <span style="color: #9acd32;">stack_size</span>=<span style="color: #fa8072;">`expr ${guard_page} + ${stack_page}`</span>
    <span style="color: #b0c4de;">printf</span> <span style="color: #bdb76b;">"%7d\t%11s\t%12s\t%s\n"</span> <span style="color: #bdb76b;">"${pid}"</span> <span style="color: #bdb76b;">"${stack_size}Kb"</span> <span style="color: #bdb76b;">"${guard_page}Kb"</span> <span style="color: #bdb76b;">"${thread_name}"</span>
<span style="color: #ffffff;">done</span>
</pre>
</div>

<p>
スタックサイズを明示的に指定して、サンプルを実行する。
</p>
<ul class="org-ul">
<li>-XX:ThreadStackSize=512
</li>
<li>-XX:VMThreadStackSize: 2048
</li>
<li>-XX:CompilerThreadStackSize=3072
</li>
</ul>
<pre class="example">
java -XX:VMThreadStackSize=2048 -XX:CompilerThreadStackSize=3072 -XX:ThreadStackSize=512 HelloWorld
Thread[Thread-0,5,main]: Hello World
Thread[Thread-4,5,main]: Hello World
Thread[Thread-1,5,main]: Hello World
Thread[Thread-3,5,main]: Hello World
Thread[Thread-2,5,main]: Hello World
★以降は省略
</pre>

<p>
測定結果
</p>
<pre class="example">
$ ./jvm_stacksize.sh `ps -ef | grep "[j]ava.*HelloWorld" | awk '{print $2}'`
[ PID ] [StackSize] [GuardPages]    [Thread Name]
  17285      1048Kb         12Kb    main
  17286      2096Kb          4Kb    GC task thread#0 (ParallelGC)
  17287      2052Kb          4Kb    GC task thread#1 (ParallelGC)
  17288      2052Kb          4Kb    GC task thread#2 (ParallelGC)
  17289      2052Kb          4Kb    GC task thread#3 (ParallelGC)
  17290      2052Kb          4Kb    VM Thread
  17291     64584Kb         12Kb    Reference Handler
  17292       516Kb         12Kb    Finalizer
  17293       516Kb         12Kb    Signal Dispatcher
  17294      3076Kb         12Kb    C2 CompilerThread0
  17295      3076Kb         12Kb    C2 CompilerThread1
  17296       516Kb         12Kb    Service Thread
  17297      2052Kb          4Kb    VM Periodic Task Thread
  17298       516Kb         12Kb    Thread-0
  17299       516Kb         12Kb    Thread-1
  17300       516Kb         12Kb    Thread-2
  17301       516Kb         12Kb    Thread-3
  17302       516Kb         12Kb    Thread-4
  17342       516Kb         12Kb    Attach Listener
</pre>

<p>
実測値はXXパラメータで指定した値より１ページ分多い。これは <code>glibc</code> 内部の
<a href="https://www.sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=nptl/allocatestack.c;h=8e620c46e9523092a5cf141e77f35c94dcfd9810;hb=HEAD#l349">allocate_stack</a> 処理で追加されているものです。
</p>
</div>
</div>




<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> ulimit -sの影響範囲</h2>
<div class="outline-text-2" id="text-6">
<p>
Linux環境に置いて、JVM内のスレッドは全てglibcの <code>pthread_create</code> 関数経由で起動される。
スレッド起動時にスタックサイズ明示的に指定していない場合、 <code>ulimit -s</code> で設定された値
がスタックのデフォルトサイズとして適用される。前文に書いた通りJVMはスレッド起動時に明
示的 <code>pthread_attr_setstacksize</code> 関数でXXパラメータ値の元にスタックサイズを指定してい
るため、これらのスレッドのスタックサイズは <code>ulimit -s</code> の値に影響されないだ。
</p>

<p>
ただし、JVMランチャー自身は <code>ulimit -s</code> の制限値が適用される。
</p>

<p>
<code>ulimit</code> コマンドでスタックの上限値 <code>RLIMIT_STACK</code> を64Kbを設定し、サンプルプログラム
グライムを実行すると、ランチャーのスタックサイズが60Kbで収まった。
</p>
<pre class="example">
$ ulimit -s 64
$ java -Xss1024K -XX:VMThreadStackSize=2048 -XX:CompilerThreadStackSize=3072 -XX:ThreadStackSize=512 HelloWorld
Thread[Thread-1,5,main]: Hello World
Thread[Thread-3,5,main]: Hello World
Thread[Thread-0,5,main]: Hello World
Thread[Thread-2,5,main]: Hello World
Thread[Thread-4,5,main]: Hello World
★省略
</pre>

<p>
<code>pmap</code> コマンドで仮想メモリマップの最上位アドレス近くにランチャーのスタックサイズを確
認することができる。
</p>
<pre class="example">
$ pmap `ps -ef | grep "[j]ava.*HelloWorld" | awk '{print $2}'`
★省略
00007f39d068d000      4K r---- ld-2.17.so
00007f39d068e000      4K rw--- ld-2.17.so
00007f39d068f000      4K rw---   [ anon ]
00007fff7cf79000     60K rw---   [ stack ] ★ランチャーのスタックサイズ
00007fff7cffe000      8K r-x--   [ anon ]
ffffffffff600000      4K r-x--   [ anon ]
 total          3513684K
</pre>

<p>
JVM内の各スレッドのスタックサイズは下記の通りです、 <code>RLIMIT_STACK</code> に影響されていない
ことが分かります。
</p>
<pre class="example">
]$ ./jvm_stacksize.sh `ps -ef | grep "[j]ava.*HelloWorld" | awk '{print $2}'`
[ PID ] [StackSize] [GuardPages]    [Thread Name]
  10770      1048Kb         12Kb    main
  10771      2096Kb          4Kb    GC task thread#0 (ParallelGC)
  10772      2052Kb          4Kb    GC task thread#1 (ParallelGC)
  10773      2052Kb          4Kb    GC task thread#2 (ParallelGC)
  10774      2052Kb          4Kb    GC task thread#3 (ParallelGC)
  10775     15812Kb          4Kb    VM Thread
  10776       516Kb         12Kb    Reference Handler
  10777     63556Kb         12Kb    Finalizer
  10778       516Kb         12Kb    Signal Dispatcher
  10779      3076Kb         12Kb    C2 CompilerThread0
  10780      3076Kb         12Kb    C2 CompilerThread1
  10781       516Kb         12Kb    Service Thread
  10782      2052Kb          4Kb    VM Periodic Task Thread
  10783       516Kb         12Kb    Thread-0
  10784       516Kb         12Kb    Thread-1
  10785       516Kb         12Kb    Thread-2
  10786       516Kb         12Kb    Thread-3
  10787       516Kb         12Kb    Thread-4
  11203       516Kb         12Kb    Attach Listener
</pre>
</div>
</div>




<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> -Xssと-XX:ThreadStackSizeの違い</h2>
<div class="outline-text-2" id="text-7">
<p>
<code>-Xss</code> と <code>-XX:ThreadStackSize</code> 両方ともJavaスレッドのスタックを指定するパラメータで
ある。 ただし、JVMランチャーから起動されたイニシャルスレッドのスタックサイズの制御は
<code>-Xss</code> パラメータのみできる。
</p>

<p>
以下はJVMランチャーからイニシャルスレッド起動するまでの流れ
</p>
<pre class="example">
行
 | ★ランチャーの実行
1| openjdk/jdk/src/share/bin/main.c:93           ==&gt; int main(int, char **);
2| openjdk/jdk/src/share/bin/java.c:170            ==&gt; int JLI_Launch(int, char **, int, const char **, int, const char **, const char *, const char *, const char *, const char *, jboolean, jboolean, jboolean, jint);
3| openjdk/jdk/src/share/bin/java.c:1835             ==&gt; int ContinueInNewThread(InvocationFunctions *, jlong, int, char **, int, char *, int);
 | ★イニシャルスレッド起動
4| openjdk/jdk/src/solaris/bin/java_md_solinux.c:1021  ==&gt; int ContinueInNewThread0(int (JNICALL *continuation)(void *), jlong stack_size, void * args)
5| openjdk/jdk/src/share/bin/java.c:337                  ==&gt; int JavaMain(void *);
 | openjdk/jdk/src/share/bin/java.c:1097                 ==&gt; jboolean InitializeJVM(JavaVM **pvm, JNIEnv **penv, InvocationFunctions *ifn)
6| openjdk/hotspot/src/share/vm/prims/jni.cpp            ==&gt; jint JNI_CreateJavaVM(JavaVM**, void**, void*);
7| openjdk/hotspot/src/share/vm/runtime/thread.cpp:3271    ==&gt; jint Threads::create_vm(JavaVMInitArgs*, bool*);
8| openjdk/hotspot/src/os/linux/vm/os_linux.cpp:4898         ==&gt; jint os::init_2(void)
9| openjdk/hotspot/src/os/linux/vm/os_linux.cpp:1205           ==&gt; void os::Linux::capture_initial_stack(size_t max_size)
</pre>

<ul class="org-ul">
<li>行1: JVMランチャーのmain関数
</li>
<li>行2: <code>JLI_Launch</code> 関数にてコマンドラインパラメータのパーシング処理が実行される。
</li>
<li>行3: <code>-Xss</code> パラメータが指定されていない場合、デフォルト値(1024Kb)を取得し(4)に渡す。
</li>
<li>行4: glibcの <code>pthread_create</code> 関数を用いてイニシャルスレッドを起動する。 <code>-Xss</code> の
値がスタックサイズに適用される。
</li>
</ul>

<p>
<code>-Xss</code> と <code>-XX:ThreadStackSize</code> 片方指定する場合、と両方指定する場合効果が違うので要注意です。
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">&#xa0;</th>
<th scope="col" class="left">イニシャルスレッド</th>
<th scope="col" class="left">ワーカスレッド</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">-Xss2048K</td>
<td class="left">2048K</td>
<td class="left">2048K</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">-XX:ThreadStackSize=2048</td>
<td class="left">1024K</td>
<td class="left">2048K</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="left">-Xss2048K</td>
<td class="left">2048K</td>
<td class="left">512K</td>
</tr>

<tr>
<td class="left">-XX:ThreadStackSize=512</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>


<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 参考</h2>
<div class="outline-text-2" id="text-8">
<p>
本記事書く際に下記コンテンツを参考した。
</p>
<ul class="org-ul">
<li><a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2011-June/004272.html">What the difference between -Xss and -XX:ThreadStackSize is?</a>
</li>
<li><a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/toc.html">Troubleshooting Guide for HotSpot VM</a>
</li>
<li><a href="http://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html">HotSpot Runtime Overview</a>
</li>
<li><a href="http://xmlandmore.blogspot.jp/2014/09/jdk-8-thread-stack-size-tuning.html?m=1">JDK 8: Thread Stack Size Tuning </a>
</li>
<li><a href="http://www.slideshare.net/m0nstermind/java-runtime-jvm">Java Runtime: повседневные обязанности</a>
</li>
<li><a href="http://brakkee.org/site/2012/10/13/java-from-the-trenches-crash-free-and-responsive-servers/">Java from the trenches: improving reliability</a>
</li>
<li><a href="https://help.blackboard.com/en-us/Learn/9.1_SP_12_and_SP_13/Administrator/010_Release_Notes/020_SP_12_Release_Notes/Performance_and_Scalability/Recommended_JVM_Tuning_Set">Recommended JVM Tuning Set</a>
</li>
<li><a href="http://stackoverflow.com/questions/11025459/where-is-the-java-stack-allocated">where is the Java stack allocated?</a>
</li>
<li><a href="http://unix.stackexchange.com/questions/145557/how-does-stack-allocation-work-in-linux">How does stack allocation work in Linux?</a>
</li>
<li><a href="http://www.oracle.com/technetwork/articles/servers-storage-dev/mem-alloc-1557798.html">How Memory Allocation Affects Performance in Multithreaded Programs</a>
</li>
<li><a href="http://stackoverflow.com/questions/15251250/what-do-the-different-hotspot-jvm-thread-types-do">What do the different (HotSpot) JVM thread types do?</a>
</li>
<li><a href="http://stackoverflow.com/questions/25309748/what-is-thread-stack-size-option-xss-given-to-jvm-why-does-it-have-a-limit-of">What is thread stack size option(-Xss) given to jvm? Why does it have a limit of atleast 68k in a windows pc?</a>
</li>
<li><a href="http://j2eedebug.blogspot.jp/2008/12/mapping-java-thread-to-pstack-and-pmap.html?m=1">Mapping java thread to pstack and pmap</a>
</li>
<li><a href="http://msugai.fc2web.com/java/perform/storage.html">JVM のメモリ構造</a>
</li>
<li><a href="http://codezine.jp/article/detail/1970?p=2">pthreadについて（スタックサイズ）</a>
</li>
<li><a href="http://www.megadriver.info/~fumi/2010/11/linux-%25E3%2581%25AE-pthread-%25E3%2581%25AE%25E3%2583%2587%25E3%2583%2595%25E3%2582%25A9%25E3%2583%25AB%25E3%2583%2588%25E3%2582%25B9%25E3%2582%25BF%25E3%2583%2583%25E3%2582%25AF%25E3%2582%25B5%25E3%2582%25A4%25E3%2582%25BA%25E3%2581%25AB%25E3%2581%25A4%25E3%2581%2584%25E3%2581%25A6/">Linux の pthread のデフォルトスタックサイズについて</a>
</li>
<li><a href="http://linuxjm.sourceforge.jp/html/LDP_man-pages/man3/pthread_attr_setstacksize.3.html">PTHREAD_ATTR_SETSTACKSIZE</a>
</li>
<li><a href="http://docs.oracle.com/cd/E19455-01/806-2732/6jbu8v6ol/index.html#attrib-33670">マルチスレッドのプログラミング - スタックについて</a>
</li>
<li><a href="http://th0x4c.github.io/blog/2012/10/10/os-virtual-memory-map/">{OS} 仮想メモリ空間のメモリマップを調べる</a>
</li>
<li><a href="http://gntm-mdk.hatenadiary.com/entry/2015/01/21/231258">VSS RSS PSS USS の説明</a>
</li>
<li><a href="http://hllvm.group.iteye.com/group/topic/37717">咨询各位大神，使用jni，当栈内空间使用为1M时，会触发core</a>
</li>
</ul>
</div>
</div>

]]></content>
  </entry>
  
</feed>
